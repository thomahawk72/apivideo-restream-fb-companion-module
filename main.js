/*! For license information please see main.js.LICENSE.txt */
(()=>{var __webpack_modules__={"./actions.js":module=>{eval("{module.exports = function (self) {\n\treturn {\n\t\tprepare_live: {\n\t\t\tname: 'Prepare Facebook Restream',\n\t\t\tdescription: 'Create Facebook Live Video and add as restream destination to selected api.video live stream',\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'static-text',\n\t\t\t\t\tid: 'info',\n\t\t\t\t\twidth: 12,\n\t\t\t\t\tlabel: 'Action Information',\n\t\t\t\t\tvalue: 'This action will:\\n1. Create a new Facebook Live Video\\n2. Add the Facebook streaming URL as a restream destination to your selected api.video live stream\\n\\nMake sure you have selected a live stream in the module configuration.',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttype: 'textinput',\n\t\t\t\t\tid: 'title',\n\t\t\t\t\tlabel: 'Facebook Live Title',\n\t\t\t\t\twidth: 12,\n\t\t\t\t\tdefault: 'Live Stream via api.video',\n\t\t\t\t\ttooltip: 'Title for the Facebook Live Video (optional)',\n\t\t\t\t},\n\t\t\t\t{\n\t\t\t\t\ttype: 'textinput',\n\t\t\t\t\tid: 'description',\n\t\t\t\t\tlabel: 'Facebook Live Description',\n\t\t\t\t\twidth: 12,\n\t\t\t\t\tdefault: 'Automated live stream setup',\n\t\t\t\t\ttooltip: 'Description for the Facebook Live Video (optional)',\n\t\t\t\t},\n\t\t\t],\n\t\t\tcallback: async (action, context) => {\n\t\t\t\t// Get title and description from action options, with fallbacks\n\t\t\t\tconst title = action.options.title || 'Live Stream via api.video'\n\t\t\t\tconst description = action.options.description || 'Automated live stream setup'\n\t\t\t\t\n\t\t\t\t// Parse variables in title and description\n\t\t\t\tconst parsedTitle = await context.parseVariablesInString(title)\n\t\t\t\tconst parsedDescription = await context.parseVariablesInString(description)\n\t\t\t\t\n\t\t\t\t// Execute the prepare live action with custom title/description\n\t\t\t\tawait self.executePrepareLife(parsedTitle, parsedDescription)\n\t\t\t},\n\t\t},\n\t\t\n\t\trefresh_streams: {\n\t\t\tname: 'Refresh Live Streams',\n\t\t\tdescription: 'Reload the list of available live streams from api.video',\n\t\t\toptions: [],\n\t\t\tcallback: async (action, context) => {\n\t\t\t\tself.log('info', 'Refreshing live streams list...')\n\t\t\t\tawait self.loadLiveStreams()\n\t\t\t\tself.log('info', 'Live streams list refreshed')\n\t\t\t},\n\t\t},\n\t\t\n\t\treset_status: {\n\t\t\tname: 'Reset Status',\n\t\t\tdescription: 'Reset the module status back to idle',\n\t\t\toptions: [],\n\t\t\tcallback: async (action, context) => {\n\t\t\t\tself.log('info', 'Resetting module status to idle')\n\t\t\t\tself.setFeedbackState('idle')\n\t\t\t},\n\t\t},\n\t}\n}\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./actions.js?\n}")},"./api.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("{const got = __webpack_require__(/*! got */ \"./node_modules/got/dist/source/index.js\")\n\nclass ApiClient {\n\tconstructor(logger) {\n\t\tthis.log = logger\n\t}\n\n\t/**\n\t * Fetch all live streams from api.video\n\t * @param {string} apiKey - api.video API key\n\t * @returns {Promise<Array>} Array of live stream objects\n\t */\n\tasync getApiVideoLiveStreams(apiKey) {\n\t\ttry {\n\t\t\tconst response = await got('https://ws.api.video/live-streams', {\n\t\t\t\theaders: {\n\t\t\t\t\t'Authorization': `Bearer ${apiKey}`,\n\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t},\n\t\t\t\tresponseType: 'json',\n\t\t\t\ttimeout: 10000,\n\t\t\t})\n\n\t\t\tif (response.body && response.body.data) {\n\t\t\t\treturn response.body.data.map(stream => ({\n\t\t\t\t\tid: stream.liveStreamId,\n\t\t\t\t\tlabel: stream.name || `Live Stream ${stream.liveStreamId}`,\n\t\t\t\t\tname: stream.name,\n\t\t\t\t\tstreamKey: stream.streamKey,\n\t\t\t\t\trtmpUrl: stream.rtmpUrl,\n\t\t\t\t}))\n\t\t\t}\n\n\t\t\treturn []\n\t\t} catch (error) {\n\t\t\tthis.log('error', `Failed to fetch api.video live streams: ${error.message}`)\n\t\t\tthrow new Error(`api.video API error: ${error.message}`)\n\t\t}\n\t}\n\n\t/**\n\t * Update api.video live stream with Facebook restream destination\n\t * @param {string} apiKey - api.video API key\n\t * @param {string} liveStreamId - api.video live stream ID\n\t * @param {string} fbServerUrl - Facebook RTMP server URL\n\t * @param {string} fbStreamKey - Facebook stream key\n\t * @returns {Promise<Object>} Updated live stream object\n\t */\n\tasync updateApiVideoRestream(apiKey, liveStreamId, fbServerUrl, fbStreamKey) {\n\t\ttry {\n\t\t\t// First, get current restreams to avoid overwriting existing ones\n\t\t\tconst currentResponse = await got(`https://ws.api.video/live-streams/${liveStreamId}`, {\n\t\t\t\theaders: {\n\t\t\t\t\t'Authorization': `Bearer ${apiKey}`,\n\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t},\n\t\t\t\tresponseType: 'json',\n\t\t\t\ttimeout: 10000,\n\t\t\t})\n\n\t\t\tconst currentRestreams = currentResponse.body.restreams || []\n\t\t\t\n\t\t\t// Add Facebook restream (remove existing Facebook restreams first)\n\t\t\tconst filteredRestreams = currentRestreams.filter(r => !r.name?.toLowerCase().includes('facebook'))\n\t\t\tconst updatedRestreams = [\n\t\t\t\t...filteredRestreams,\n\t\t\t\t{\n\t\t\t\t\tname: 'Facebook Live',\n\t\t\t\t\tserverUrl: fbServerUrl,\n\t\t\t\t\tstreamKey: fbStreamKey,\n\t\t\t\t}\n\t\t\t]\n\n\t\t\tconst response = await got.patch(`https://ws.api.video/live-streams/${liveStreamId}`, {\n\t\t\t\theaders: {\n\t\t\t\t\t'Authorization': `Bearer ${apiKey}`,\n\t\t\t\t\t'Content-Type': 'application/json',\n\t\t\t\t},\n\t\t\t\tjson: {\n\t\t\t\t\trestreams: updatedRestreams,\n\t\t\t\t},\n\t\t\t\tresponseType: 'json',\n\t\t\t\ttimeout: 10000,\n\t\t\t})\n\n\t\t\tthis.log('info', `Successfully updated api.video live stream ${liveStreamId} with Facebook restream`)\n\t\t\treturn response.body\n\t\t} catch (error) {\n\t\t\tthis.log('error', `Failed to update api.video restream: ${error.message}`)\n\t\t\tthrow new Error(`api.video restream update error: ${error.message}`)\n\t\t}\n\t}\n\n\t/**\n\t * Create a new Facebook Live Video and get streaming URL\n\t * @param {string} userToken - Facebook User Access Token\n\t * @param {string} pageId - Facebook Page ID\n\t * @param {string} title - Live video title\n\t * @param {string} description - Live video description\n\t * @returns {Promise<Object>} Facebook Live Video object with streaming URL\n\t */\n\tasync createFacebookLiveVideo(userToken, pageId, title = 'Live Stream', description = 'Live stream via api.video') {\n\t\ttry {\n\t\t\tconst response = await got.post(`https://graph.facebook.com/v18.0/${pageId}/live_videos`, {\n\t\t\t\tform: {\n\t\t\t\t\ttitle: title,\n\t\t\t\t\tdescription: description,\n\t\t\t\t\taccess_token: userToken,\n\t\t\t\t},\n\t\t\t\tresponseType: 'json',\n\t\t\t\ttimeout: 10000,\n\t\t\t})\n\n\t\t\tif (response.body && response.body.secure_stream_url) {\n\t\t\t\tconst streamUrl = response.body.secure_stream_url\n\t\t\t\tconst streamKey = response.body.stream_url ? response.body.stream_url.split('/').pop() : null\n\n\t\t\t\t// Parse RTMP URL to get server and key\n\t\t\t\tconst rtmpMatch = streamUrl.match(/^(rtmps?:\\/\\/[^\\/]+\\/)(.+)$/)\n\t\t\t\tif (rtmpMatch) {\n\t\t\t\t\tconst serverUrl = rtmpMatch[1]\n\t\t\t\t\tconst key = rtmpMatch[2]\n\n\t\t\t\t\tthis.log('info', `Successfully created Facebook Live Video: ${response.body.id}`)\n\t\t\t\t\treturn {\n\t\t\t\t\t\tid: response.body.id,\n\t\t\t\t\t\tstreamUrl: streamUrl,\n\t\t\t\t\t\tserverUrl: serverUrl,\n\t\t\t\t\t\tstreamKey: key,\n\t\t\t\t\t\ttitle: title,\n\t\t\t\t\t\tdescription: description,\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\tthrow new Error('Could not parse Facebook streaming URL')\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthrow new Error('Facebook API did not return streaming URL')\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.log('error', `Failed to create Facebook Live Video: ${error.message}`)\n\t\t\t\n\t\t\t// Provide more specific error messages for common issues\n\t\t\tif (error.response && error.response.body) {\n\t\t\t\tconst fbError = error.response.body.error\n\t\t\t\tif (fbError) {\n\t\t\t\t\tif (fbError.code === 190) {\n\t\t\t\t\t\tthrow new Error('Facebook token is invalid or expired')\n\t\t\t\t\t} else if (fbError.code === 200) {\n\t\t\t\t\t\tthrow new Error('Insufficient permissions - need publish_video permission')\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthrow new Error(`Facebook API error: ${fbError.message}`)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tthrow new Error(`Facebook Live Video creation error: ${error.message}`)\n\t\t}\n\t}\n\n\t/**\n\t * Parse RTMP URL into server URL and stream key components\n\t * @param {string} rtmpUrl - Full RTMP URL\n\t * @returns {Object} Object with serverUrl and streamKey\n\t */\n\tparseRtmpUrl(rtmpUrl) {\n\t\tconst match = rtmpUrl.match(/^(rtmps?:\\/\\/[^\\/]+\\/)(.+)$/)\n\t\tif (match) {\n\t\t\treturn {\n\t\t\t\tserverUrl: match[1],\n\t\t\t\tstreamKey: match[2],\n\t\t\t}\n\t\t}\n\t\tthrow new Error('Invalid RTMP URL format')\n\t}\n}\n\nmodule.exports = ApiClient\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./api.js?\n}")},"./config.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("{const { Regex } = __webpack_require__(/*! @companion-module/base */ \"./node_modules/@companion-module/base/dist/index.js\")\n\nmodule.exports = function (self) {\n\treturn [\n\t\t{\n\t\t\ttype: 'static-text',\n\t\t\tid: 'info',\n\t\t\twidth: 12,\n\t\t\tlabel: 'Information',\n\t\t\tvalue: 'This module integrates Facebook Live with api.video for automated restreaming setup.',\n\t\t},\n\t\t{\n\t\t\ttype: 'textinput',\n\t\t\tid: 'fb_page_id',\n\t\t\tlabel: 'Facebook Page ID',\n\t\t\twidth: 6,\n\t\t\tregex: Regex.NUMBER,\n\t\t\trequired: true,\n\t\t\ttooltip: 'The numeric ID of your Facebook Page (found in Page settings)',\n\t\t},\n\t\t{\n\t\t\ttype: 'textinput',\n\t\t\tid: 'fb_user_token',\n\t\t\tlabel: 'Facebook User Access Token',\n\t\t\twidth: 12,\n\t\t\trequired: true,\n\t\t\ttooltip: 'User Access Token with publish_video permission for your Facebook Page',\n\t\t},\n\t\t{\n\t\t\ttype: 'textinput',\n\t\t\tid: 'apivideo_api_key',\n\t\t\tlabel: 'api.video API Key',\n\t\t\twidth: 12,\n\t\t\trequired: true,\n\t\t\ttooltip: 'Your api.video API key (found in your api.video dashboard)',\n\t\t},\n\t\t{\n\t\t\ttype: 'dropdown',\n\t\t\tid: 'apivideo_livestream_id',\n\t\t\tlabel: 'api.video Live Stream',\n\t\t\twidth: 12,\n\t\t\tchoices: self.liveStreams || [{ id: '', label: 'No live streams available - check API key' }],\n\t\t\tdefault: '',\n\t\t\ttooltip: 'Select the api.video live stream to add Facebook restream to',\n\t\t},\n\t\t{\n\t\t\ttype: 'static-text',\n\t\t\tid: 'help',\n\t\t\twidth: 12,\n\t\t\tlabel: 'Setup Instructions',\n\t\t\tvalue: `\n1. Get your Facebook Page ID from your Page settings\n2. Generate a User Access Token with 'publish_video' permission using Facebook's Graph API Explorer\n3. Get your api.video API key from your api.video dashboard\n4. Save configuration to load available live streams\n5. Select the live stream you want to add Facebook restreaming to\n\t\t\t`.trim(),\n\t\t},\n\t]\n}\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./config.js?\n}")},"./feedbacks.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("{const { combineRgb } = __webpack_require__(/*! @companion-module/base */ \"./node_modules/@companion-module/base/dist/index.js\")\n\nmodule.exports = function (self) {\n\treturn {\n\t\trestream_status: {\n\t\t\ttype: 'boolean',\n\t\t\tname: 'Restream Preparation Status',\n\t\t\tdescription: 'Change button appearance based on restream preparation status',\n\t\t\tdefaultStyle: {\n\t\t\t\tbgcolor: combineRgb(0, 0, 0),\n\t\t\t\tcolor: combineRgb(255, 255, 255),\n\t\t\t},\n\t\t\toptions: [\n\t\t\t\t{\n\t\t\t\t\ttype: 'dropdown',\n\t\t\t\t\tid: 'status',\n\t\t\t\t\tlabel: 'Status to check',\n\t\t\t\t\tdefault: 'ok',\n\t\t\t\t\tchoices: [\n\t\t\t\t\t\t{ id: 'idle', label: 'Idle (not started)' },\n\t\t\t\t\t\t{ id: 'in_progress', label: 'In Progress' },\n\t\t\t\t\t\t{ id: 'ok', label: 'Success (OK)' },\n\t\t\t\t\t\t{ id: 'fail', label: 'Failed' },\n\t\t\t\t\t],\n\t\t\t\t},\n\t\t\t],\n\t\t\tcallback: (feedback) => {\n\t\t\t\treturn self.feedbackState === feedback.options.status\n\t\t\t},\n\t\t},\n\n\t\thas_error: {\n\t\t\ttype: 'boolean',\n\t\t\tname: 'Has Error',\n\t\t\tdescription: 'Indicates if the last operation resulted in an error',\n\t\t\tdefaultStyle: {\n\t\t\t\tbgcolor: combineRgb(255, 0, 0),\n\t\t\t\tcolor: combineRgb(255, 255, 255),\n\t\t\t},\n\t\t\toptions: [],\n\t\t\tcallback: () => {\n\t\t\t\treturn self.feedbackState === 'fail' && self.lastError !== ''\n\t\t\t},\n\t\t},\n\n\t\tis_ready: {\n\t\t\ttype: 'boolean',\n\t\t\tname: 'Ready for Operation',\n\t\t\tdescription: 'Indicates if the module is properly configured and ready to prepare restreams',\n\t\t\tdefaultStyle: {\n\t\t\t\tbgcolor: combineRgb(0, 255, 0),\n\t\t\t\tcolor: combineRgb(0, 0, 0),\n\t\t\t},\n\t\t\toptions: [],\n\t\t\tcallback: () => {\n\t\t\t\t// Check if all required config is present and a live stream is selected\n\t\t\t\treturn (\n\t\t\t\t\tself.config &&\n\t\t\t\t\tself.config.fb_page_id &&\n\t\t\t\t\tself.config.fb_user_token &&\n\t\t\t\t\tself.config.apivideo_api_key &&\n\t\t\t\t\tself.config.apivideo_livestream_id &&\n\t\t\t\t\tself.feedbackState !== 'in_progress'\n\t\t\t\t)\n\t\t\t},\n\t\t},\n\n\t\toperation_in_progress: {\n\t\t\ttype: 'boolean',\n\t\t\tname: 'Operation in Progress',\n\t\t\tdescription: 'Indicates if a restream preparation is currently in progress',\n\t\t\tdefaultStyle: {\n\t\t\t\tbgcolor: combineRgb(255, 165, 0),\n\t\t\t\tcolor: combineRgb(0, 0, 0),\n\t\t\t},\n\t\t\toptions: [],\n\t\t\tcallback: () => {\n\t\t\t\treturn self.feedbackState === 'in_progress'\n\t\t\t},\n\t\t},\n\n\t\tlive_stream_selected: {\n\t\t\ttype: 'boolean',\n\t\t\tname: 'Live Stream Selected',\n\t\t\tdescription: 'Indicates if an api.video live stream is selected in configuration',\n\t\t\tdefaultStyle: {\n\t\t\t\tbgcolor: combineRgb(0, 100, 255),\n\t\t\t\tcolor: combineRgb(255, 255, 255),\n\t\t\t},\n\t\t\toptions: [],\n\t\t\tcallback: () => {\n\t\t\t\treturn self.config && self.config.apivideo_livestream_id && self.config.apivideo_livestream_id !== ''\n\t\t\t},\n\t\t},\n\t}\n}\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./feedbacks.js?\n}")},"./main.js":(__unused_webpack_module,__unused_webpack_exports,__webpack_require__)=>{eval("{const { InstanceBase, runEntrypoint, InstanceStatus } = __webpack_require__(/*! @companion-module/base */ \"./node_modules/@companion-module/base/dist/index.js\")\nconst ApiClient = __webpack_require__(/*! ./api */ \"./api.js\")\nconst getConfigFields = __webpack_require__(/*! ./config */ \"./config.js\")\nconst getActions = __webpack_require__(/*! ./actions */ \"./actions.js\")\nconst getFeedbacks = __webpack_require__(/*! ./feedbacks */ \"./feedbacks.js\")\nconst getVariables = __webpack_require__(/*! ./variables */ \"./variables.js\")\n\nclass FacebookApiVideoInstance extends InstanceBase {\n\tconstructor(internal) {\n\t\tsuper(internal)\n\t\t\n\t\t// Initialize API client\n\t\tthis.api = new ApiClient((level, message) => this.log(level, message))\n\t\t\n\t\t// Initialize state\n\t\tthis.liveStreams = []\n\t\tthis.feedbackState = 'idle' // idle, in_progress, ok, fail\n\t\tthis.lastError = ''\n\t\tthis.lastFacebookVideoId = ''\n\t}\n\n\tasync init(config) {\n\t\tthis.config = config\n\t\tthis.log('info', 'Initializing Facebook & api.video module')\n\n\t\t// Validate configuration\n\t\tif (!this.validateConfig(config)) {\n\t\t\tthis.updateStatus(InstanceStatus.BadConfig, 'Missing required configuration')\n\t\t\treturn\n\t\t}\n\n\t\t// Load live streams from api.video\n\t\tawait this.loadLiveStreams()\n\n\t\t// Initialize actions, feedbacks, and variables\n\t\tthis.updateActions()\n\t\tthis.updateFeedbacks()\n\t\tthis.updateVariableDefinitions()\n\t\tthis.updateVariableValues()\n\n\t\tthis.updateStatus(InstanceStatus.Ok)\n\t\tthis.log('info', 'Module initialized successfully')\n\t}\n\n\tasync destroy() {\n\t\tthis.log('debug', 'Module destroyed')\n\t}\n\n\tasync configUpdated(config) {\n\t\tthis.config = config\n\t\tthis.log('info', 'Configuration updated')\n\n\t\t// Validate new configuration\n\t\tif (!this.validateConfig(config)) {\n\t\t\tthis.updateStatus(InstanceStatus.BadConfig, 'Missing required configuration')\n\t\t\treturn\n\t\t}\n\n\t\t// Reload live streams if api.video key changed\n\t\tawait this.loadLiveStreams()\n\n\t\t// Update actions and feedbacks with new config\n\t\tthis.updateActions()\n\t\tthis.updateFeedbacks()\n\t\tthis.updateVariableValues()\n\n\t\tthis.updateStatus(InstanceStatus.Ok)\n\t}\n\n\t/**\n\t * Validate that all required configuration fields are present\n\t */\n\tvalidateConfig(config) {\n\t\tconst required = ['fb_page_id', 'fb_user_token', 'apivideo_api_key']\n\t\t\n\t\tfor (const field of required) {\n\t\t\tif (!config[field] || config[field].trim() === '') {\n\t\t\t\tthis.log('warn', `Missing required configuration field: ${field}`)\n\t\t\t\treturn false\n\t\t\t}\n\t\t}\n\n\t\treturn true\n\t}\n\n\t/**\n\t * Load live streams from api.video and update configuration choices\n\t */\n\tasync loadLiveStreams() {\n\t\tif (!this.config.apivideo_api_key) {\n\t\t\tthis.liveStreams = [{ id: '', label: 'No API key configured' }]\n\t\t\treturn\n\t\t}\n\n\t\ttry {\n\t\t\tthis.log('info', 'Loading live streams from api.video...')\n\t\t\tconst streams = await this.api.getApiVideoLiveStreams(this.config.apivideo_api_key)\n\t\t\t\n\t\t\tif (streams.length === 0) {\n\t\t\t\tthis.liveStreams = [{ id: '', label: 'No live streams found' }]\n\t\t\t\tthis.log('warn', 'No live streams found in api.video account')\n\t\t\t} else {\n\t\t\t\tthis.liveStreams = streams.map(stream => ({\n\t\t\t\t\tid: stream.id,\n\t\t\t\t\tlabel: stream.label,\n\t\t\t\t}))\n\t\t\t\tthis.log('info', `Loaded ${streams.length} live streams from api.video`)\n\t\t\t}\n\t\t} catch (error) {\n\t\t\tthis.liveStreams = [{ id: '', label: 'Error loading streams - check API key' }]\n\t\t\tthis.log('error', `Failed to load live streams: ${error.message}`)\n\t\t}\n\n\t\t// Update configuration to refresh dropdown choices\n\t\tthis.configUpdated(this.config)\n\t}\n\n\t/**\n\t * Get configuration fields\n\t */\n\tgetConfigFields() {\n\t\treturn getConfigFields(this)\n\t}\n\n\t/**\n\t * Update actions\n\t */\n\tupdateActions() {\n\t\tthis.setActionDefinitions(getActions(this))\n\t}\n\n\t/**\n\t * Update feedbacks\n\t */\n\tupdateFeedbacks() {\n\t\tthis.setFeedbackDefinitions(getFeedbacks(this))\n\t}\n\n\t/**\n\t * Update variable definitions\n\t */\n\tupdateVariableDefinitions() {\n\t\tthis.setVariableDefinitions(getVariables(this))\n\t}\n\n\t/**\n\t * Set feedback state and trigger feedback updates\n\t */\n\tsetFeedbackState(state, error = '') {\n\t\tthis.feedbackState = state\n\t\tthis.lastError = error\n\t\t\n\t\t// Update all variables\n\t\tthis.updateVariableValues()\n\n\t\t// Trigger feedback updates\n\t\tthis.checkFeedbacks()\n\t\t\n\t\tthis.log('debug', `Feedback state changed to: ${state}`)\n\t}\n\n\t/**\n\t * Update all variable values\n\t */\n\tupdateVariableValues() {\n\t\tconst selectedStream = this.liveStreams.find(s => s.id === this.config.apivideo_livestream_id)\n\t\tconst isReady = this.config && \n\t\t\tthis.config.fb_page_id && \n\t\t\tthis.config.fb_user_token && \n\t\t\tthis.config.apivideo_api_key && \n\t\t\tthis.config.apivideo_livestream_id\n\n\t\tthis.setVariableValues({\n\t\t\tstatus: this.feedbackState,\n\t\t\tlast_error: this.lastError,\n\t\t\tfacebook_video_id: this.lastFacebookVideoId,\n\t\t\tselected_livestream: selectedStream ? selectedStream.label : 'None',\n\t\t\tlivestreams_count: this.liveStreams.length.toString(),\n\t\t\tmodule_ready: isReady ? 'true' : 'false',\n\t\t})\n\t}\n\n\t/**\n\t * Execute the prepare live action\n\t */\n\tasync executePrepareLife(title = 'Live Stream via api.video', description = 'Automated live stream setup') {\n\t\tthis.log('info', 'Starting Facebook restream preparation...')\n\t\tthis.setFeedbackState('in_progress')\n\n\t\ttry {\n\t\t\t// Validate that a live stream is selected\n\t\t\tif (!this.config.apivideo_livestream_id) {\n\t\t\t\tthrow new Error('No api.video live stream selected')\n\t\t\t}\n\n\t\t\t// Step 1: Create Facebook Live Video\n\t\t\tthis.log('info', 'Creating Facebook Live Video...')\n\t\t\tconst fbLiveVideo = await this.api.createFacebookLiveVideo(\n\t\t\t\tthis.config.fb_user_token,\n\t\t\t\tthis.config.fb_page_id,\n\t\t\t\ttitle,\n\t\t\t\tdescription\n\t\t\t)\n\n\t\t\tthis.lastFacebookVideoId = fbLiveVideo.id\n\t\t\tthis.log('info', `Facebook Live Video created: ${fbLiveVideo.id}`)\n\n\t\t\t// Step 2: Update api.video restream\n\t\t\tthis.log('info', 'Updating api.video restream destination...')\n\t\t\tawait this.api.updateApiVideoRestream(\n\t\t\t\tthis.config.apivideo_api_key,\n\t\t\t\tthis.config.apivideo_livestream_id,\n\t\t\t\tfbLiveVideo.serverUrl,\n\t\t\t\tfbLiveVideo.streamKey\n\t\t\t)\n\n\t\t\tthis.log('info', 'Facebook restream preparation completed successfully')\n\t\t\tthis.setFeedbackState('ok')\n\n\t\t} catch (error) {\n\t\t\tthis.log('error', `Facebook restream preparation failed: ${error.message}`)\n\t\t\tthis.setFeedbackState('fail', error.message)\n\t\t}\n\t}\n}\n\nrunEntrypoint(FacebookApiVideoInstance, [])\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./main.js?\n}")},"./node_modules/@companion-module/base/dist/common/json-value.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\n// Copied from https://github.com/sindresorhus/type-fest/blob/main/source/json-value.d.ts\n// Under MIT License - Sindre Sorhus <sindresorhus@gmail.com>\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=json-value.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/common/json-value.js?\n}')},"./node_modules/@companion-module/base/dist/common/osc.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\n/**\n * Warning: these types are used in various stable apis.\n * BE VERY CAREFUL WHEN MAKING CHANGES\n */\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=osc.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/common/osc.js?\n}')},"./node_modules/@companion-module/base/dist/entrypoint.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.runEntrypoint = runEntrypoint;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\n/* eslint-disable n/no-process-exit */\nconst versions_js_1 = __webpack_require__(/*! ./host-api/versions.js */ \"./node_modules/@companion-module/base/dist/host-api/versions.js\");\nconst promises_1 = tslib_1.__importDefault(__webpack_require__(/*! fs/promises */ \"fs/promises\"));\nconst util_js_1 = __webpack_require__(/*! ./util.js */ \"./node_modules/@companion-module/base/dist/util.js\");\nconst ipc_wrapper_js_1 = __webpack_require__(/*! ./host-api/ipc-wrapper.js */ \"./node_modules/@companion-module/base/dist/host-api/ipc-wrapper.js\");\nconst path_1 = tslib_1.__importDefault(__webpack_require__(/*! path */ \"path\"));\nlet hasEntrypoint = false;\n// eslint-disable-next-line @typescript-eslint/no-unused-vars\nlet moduleInstance;\n// async function readFileUrl(url: URL): Promise<string> {\n// \t// Hack to make json files be loadable after being inlined by webpack\n// \tconst prefix = 'application/json;base64,'\n// \tif (url.pathname.startsWith(prefix)) {\n// \t\tconst base64 = url.pathname.substring(prefix.length)\n// \t\treturn Buffer.from(base64, 'base64').toString()\n// \t}\n// \t// Fallback to reading from disk\n// \tconst buf = await fs.readFile(url)\n// \treturn buf.toString()\n// }\n/**\n * Setup the module for execution\n * This should be called once per-module, to register the class that should be executed\n * @param factory The class for the module\n * @param upgradeScripts Upgrade scripts\n */\nfunction runEntrypoint(factory, upgradeScripts) {\n    Promise.resolve()\n        .then(async () => {\n        // const pkgJsonStr = (await fs.readFile(path.join(__dirname, '../package.json'))).toString()\n        // const pkgJson = JSON.parse(pkgJsonStr)\n        // if (!pkgJson || pkgJson.name !== '@companion-module/base')\n        // \tthrow new Error('Failed to find the package.json for @companion-module/base')\n        // if (!pkgJson.version) throw new Error('Missing version field in the package.json for @companion-module/base')\n        // Ensure only called once per module\n        if (hasEntrypoint)\n            throw new Error(`runEntrypoint can only be called once`);\n        hasEntrypoint = true;\n        // Validate that the upgrade scripts look sane\n        if (!upgradeScripts)\n            upgradeScripts = [];\n        if (!Array.isArray(upgradeScripts))\n            throw new Error('upgradeScripts must be an array');\n        for (const upgradeScript of upgradeScripts) {\n            if (typeof upgradeScript !== 'function')\n                throw new Error('upgradeScripts must be an array of functions');\n        }\n        const manifestPath = process.env.MODULE_MANIFEST;\n        if (!manifestPath)\n            throw new Error('Module initialise is missing MODULE_MANIFEST');\n        // check manifest api field against apiVersion\n        const manifestBlob = await promises_1.default.readFile(manifestPath);\n        const manifestJson = JSON.parse(manifestBlob.toString());\n        if (manifestJson.runtime?.api !== versions_js_1.HostApiNodeJsIpc)\n            throw new Error(`Module manifest 'api' mismatch`);\n        if (!manifestJson.runtime.apiVersion)\n            throw new Error(`Module manifest 'apiVersion' missing`);\n        let apiVersion = manifestJson.runtime.apiVersion;\n        if (apiVersion === '0.0.0') {\n            // It looks like the module is in dev mode. lets attempt to load the package.json from this module instead\n            try {\n                const baseJsonStr = await promises_1.default.readFile(path_1.default.join(__dirname, '../package.json'));\n                const baseJson = JSON.parse(baseJsonStr.toString());\n                if (baseJson.name === '@companion-module/base') {\n                    apiVersion = baseJson.version;\n                }\n            }\n            catch (_e) {\n                throw new Error('Failed to determine module api version');\n            }\n        }\n        if (!process.send)\n            throw new Error('Module is not being run with ipc');\n        console.log(`Starting up module class: ${factory.name}`);\n        const connectionId = process.env.CONNECTION_ID;\n        if (typeof connectionId !== 'string' || !connectionId)\n            throw new Error('Module initialise is missing CONNECTION_ID');\n        const verificationToken = process.env.VERIFICATION_TOKEN;\n        if (typeof verificationToken !== 'string' || !verificationToken)\n            throw new Error('Module initialise is missing VERIFICATION_TOKEN');\n        // Allow the DSN to be provided as an env variable\n        // const sentryDsn = process.env.SENTRY_DSN\n        // const sentryUserId = process.env.SENTRY_USERID\n        // const sentryCompanionVersion = process.env.SENTRY_COMPANION_VERSION\n        // if (sentryDsn && sentryUserId && sentryDsn.substring(0, 8) == 'https://') {\n        // \tconsole.log('Sentry enabled')\n        // \tinit({\n        // \t\tdsn: sentryDsn,\n        // \t\trelease: `${manifestJson.name}@${manifestJson.version}`,\n        // \t\tbeforeSend(event) {\n        // \t\t\tif (event.exception) {\n        // \t\t\t\tconsole.log('sentry', 'error', event.exception)\n        // \t\t\t}\n        // \t\t\treturn event\n        // \t\t},\n        // \t})\n        // \t{\n        // \t\tconst scope = getCurrentScope()\n        // \t\tscope.setUser({ id: sentryUserId })\n        // \t\tscope.setTag('companion', sentryCompanionVersion)\n        // \t}\n        // } else {\n        // \tconsole.log('Sentry disabled')\n        // }\n        const ipcWrapper = new ipc_wrapper_js_1.IpcWrapper({}, (msg) => {\n            process.send(msg);\n        }, 5000);\n        process.once('message', (msg) => {\n            ipcWrapper.receivedMessage(msg);\n        });\n        moduleInstance = new factory((0, util_js_1.literal)({\n            id: connectionId,\n            upgradeScripts,\n            _isInstanceBaseProps: true,\n        }));\n        ipcWrapper.sendWithCb('register', { apiVersion, connectionId, verificationToken }).then(() => {\n            console.log(`Module-host accepted registration`);\n        }, (err) => {\n            console.error('Module registration failed', err);\n            // Kill the process\n            process.exit(11);\n        });\n    })\n        .catch((e) => {\n        console.error(`Failed to startup module:`);\n        console.error(e.stack || e.message);\n        process.exit(1);\n    });\n}\n//# sourceMappingURL=entrypoint.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/entrypoint.js?\n}")},"./node_modules/@companion-module/base/dist/helpers/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.UDPHelper = exports.TelnetHelper = exports.TCPHelper = void 0;\nvar tcp_js_1 = __webpack_require__(/*! ./tcp.js */ "./node_modules/@companion-module/base/dist/helpers/tcp.js");\nObject.defineProperty(exports, "TCPHelper", ({ enumerable: true, get: function () { return tcp_js_1.TCPHelper; } }));\nvar telnet_js_1 = __webpack_require__(/*! ./telnet.js */ "./node_modules/@companion-module/base/dist/helpers/telnet.js");\nObject.defineProperty(exports, "TelnetHelper", ({ enumerable: true, get: function () { return telnet_js_1.TelnetHelper; } }));\nvar udp_js_1 = __webpack_require__(/*! ./udp.js */ "./node_modules/@companion-module/base/dist/helpers/udp.js");\nObject.defineProperty(exports, "UDPHelper", ({ enumerable: true, get: function () { return udp_js_1.UDPHelper; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/helpers/index.js?\n}')},"./node_modules/@companion-module/base/dist/helpers/tcp.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n/*\n * This file is part of the Companion project\n * Copyright (c) 2018 Bitfocus AS\n * Authors: William Viker <william@bitfocus.io>, Håkon Nessjøen <haakon@bitfocus.io>\n *\n * This program is free software.\n * You should have received a copy of the MIT licence as well as the Bitfocus\n * Individual Contributor License Agreement for companion along with\n * this program.\n *\n * You can be released from the requirements of the license by purchasing\n * a commercial license. Buying such a license is mandatory as soon as you\n * develop commercial activities involving the Companion software without\n * disclosing the source code of your own applications.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TCPHelper = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst net_1 = tslib_1.__importDefault(__webpack_require__(/*! net */ \"net\"));\nconst eventemitter3_1 = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\nconst enums_js_1 = __webpack_require__(/*! ../module-api/enums.js */ \"./node_modules/@companion-module/base/dist/module-api/enums.js\");\nclass TCPHelper extends eventemitter3_1.EventEmitter {\n    #host;\n    #port;\n    _socket;\n    #options;\n    #connected = false;\n    #connecting = false;\n    #destroyed = false;\n    #lastStatus;\n    #reconnectTimer;\n    #missingErrorHandlerTimer;\n    get isConnected() {\n        return this.#connected;\n    }\n    get isConnecting() {\n        return this.#connecting;\n    }\n    get isDestroyed() {\n        return this.#destroyed;\n    }\n    constructor(host, port, options) {\n        super();\n        this.#host = host;\n        this.#port = port;\n        this.#options = {\n            reconnect_interval: 2000,\n            reconnect: true,\n            ...options,\n        };\n        this._socket = new net_1.default.Socket();\n        this._socket.setKeepAlive(true);\n        this._socket.setNoDelay(true);\n        this._socket.on('error', (err) => {\n            this.#connecting = false;\n            this.#connected = false;\n            if (this.#options.reconnect) {\n                this.#queueReconnect();\n            }\n            this.#new_status(enums_js_1.InstanceStatus.UnknownError, err.message);\n            this.emit('error', err);\n        });\n        this._socket.on('ready', () => {\n            this.#connected = true;\n            this.#connecting = false;\n            this.#new_status(enums_js_1.InstanceStatus.Ok);\n            this.emit('connect');\n        });\n        this._socket.on('end', () => {\n            this.#connected = false;\n            this.#new_status(enums_js_1.InstanceStatus.Disconnected);\n            if (!this.#connecting && this.#options.reconnect) {\n                this.#queueReconnect();\n            }\n            this.emit('end');\n        });\n        this._socket.on('data', (data) => this.emit('data', data));\n        this._socket.on('drain', () => this.emit('drain'));\n        // Let caller install event handlers first\n        setImmediate(() => {\n            if (!this.#destroyed)\n                this.connect();\n        });\n        this.#missingErrorHandlerTimer = setTimeout(() => {\n            this.#missingErrorHandlerTimer = undefined;\n            if (!this.#destroyed && !this.listenerCount('error')) {\n                // The socket is active and has no listeners. Log an error for the module devs!\n                console.error(`Danger: TCP client for ${this.#host}:${this.#port} is missing an error handler!`);\n            }\n        }, 5000);\n    }\n    connect() {\n        if (this.#destroyed)\n            throw new Error('Cannot connect destroyed socket');\n        if (this.#connecting)\n            return false;\n        this.#connecting = true;\n        this._socket.connect(this.#port, this.#host);\n        return true;\n    }\n    async send(message) {\n        if (this.#destroyed || this._socket.destroyed)\n            throw new Error('Cannot write to destroyed socket');\n        if (!message || !message.length)\n            throw new Error('No message to send');\n        if (!this.#connected) {\n            return false;\n        }\n        try {\n            return new Promise((resolve, reject) => {\n                this._socket.write(message, (error) => {\n                    if (error) {\n                        reject(error);\n                        return;\n                    }\n                    resolve(true);\n                });\n            });\n        }\n        catch (error) {\n            this.#connected = false;\n            const error2 = error instanceof Error ? error : new Error(`${error}`);\n            // Unhandeled socket error\n            this.#new_status(enums_js_1.InstanceStatus.UnknownError, error2.message);\n            this.emit('error', error2);\n            throw error2;\n        }\n    }\n    destroy() {\n        this.#destroyed = true;\n        if (this.#reconnectTimer !== undefined) {\n            clearTimeout(this.#reconnectTimer);\n            this.#reconnectTimer = undefined;\n        }\n        if (this.#missingErrorHandlerTimer !== undefined) {\n            clearTimeout(this.#missingErrorHandlerTimer);\n            this.#missingErrorHandlerTimer = undefined;\n        }\n        this._socket.removeAllListeners();\n        this.removeAllListeners();\n        this._socket.destroy();\n    }\n    #queueReconnect() {\n        if (this.#reconnectTimer !== undefined) {\n            clearTimeout(this.#reconnectTimer);\n        }\n        this.#reconnectTimer = setTimeout(() => {\n            this.#reconnectTimer = undefined;\n            this.#new_status(enums_js_1.InstanceStatus.Connecting);\n            this.connect();\n        }, this.#options.reconnect_interval);\n    }\n    // Private function\n    #new_status(status, message) {\n        if (this.#lastStatus != status) {\n            this.#lastStatus = status;\n            this.emit('status_change', status, message);\n        }\n    }\n}\nexports.TCPHelper = TCPHelper;\n//# sourceMappingURL=tcp.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/helpers/tcp.js?\n}")},"./node_modules/@companion-module/base/dist/helpers/telnet.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n/*\n * This file is part of the Companion project\n * Copyright (c) 2018 Bitfocus AS\n * Authors: William Viker <william@bitfocus.io>, Håkon Nessjøen <haakon@bitfocus.io>\n *\n * This program is free software.\n * You should have received a copy of the MIT licence as well as the Bitfocus\n * Individual Contributor License Agreement for companion along with\n * this program.\n *\n * You can be released from the requirements of the license by purchasing\n * a commercial license. Buying such a license is mandatory as soon as you\n * develop commercial activities involving the Companion software without\n * disclosing the source code of your own applications.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TelnetHelper = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst eventemitter3_1 = tslib_1.__importDefault(__webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\"));\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst tcp_js_1 = __webpack_require__(/*! ./tcp.js */ \"./node_modules/@companion-module/base/dist/helpers/tcp.js\");\n// const NULL = 0\nconst DATA = 0;\nconst SE = 240;\nconst SB = 250;\nconst WILL = 251;\nconst WONT = 252;\nconst DO = 253;\nconst DONT = 254;\nconst IAC = 255;\nclass TelnetHelper extends eventemitter3_1.default {\n    #tcp;\n    #stream;\n    #missingErrorHandlerTimer;\n    get isConnected() {\n        return this.#tcp.isConnected;\n    }\n    get isConnecting() {\n        return this.#tcp.isConnecting;\n    }\n    get isDestroyed() {\n        return this.#tcp.isDestroyed;\n    }\n    constructor(host, port, options) {\n        super();\n        this.#tcp = new tcp_js_1.TCPHelper(host, port, options);\n        this.#stream = new TelnetStream();\n        this.#tcp._socket.pipe(this.#stream);\n        this.#tcp.on('connect', () => this.emit('connect'));\n        this.#tcp.on('end', () => this.emit('end'));\n        this.#tcp.on('error', (error) => this.emit('error', error));\n        this.#tcp.on('status_change', (status, message) => this.emit('status_change', status, message));\n        // Ignore drain and data, they go via the stream\n        this.#stream.on('iac', (a, b) => this.emit('iac', a, b));\n        this.#stream.on('sb', (buffer) => this.emit('sb', buffer));\n        this.#stream.on('data', (data) => this.emit('data', data));\n        this.#stream.on('drain', () => this.emit('drain'));\n        this.#missingErrorHandlerTimer = setTimeout(() => {\n            this.#missingErrorHandlerTimer = undefined;\n            if (!this.isDestroyed && !this.listenerCount('error')) {\n                // The socket is active and has no listeners. Log an error for the module devs!\n                console.error(`Danger: Telnet client for ${host}:${port} is missing an error handler!`);\n            }\n        }, 5000);\n    }\n    connect() {\n        return this.#tcp.connect();\n    }\n    async send(message) {\n        return this.#tcp.send(message);\n    }\n    destroy() {\n        this.#tcp.destroy();\n        if (this.#missingErrorHandlerTimer !== undefined) {\n            clearTimeout(this.#missingErrorHandlerTimer);\n            this.#missingErrorHandlerTimer = undefined;\n        }\n        this.#stream.removeAllListeners();\n        this.#stream.destroy();\n    }\n}\nexports.TelnetHelper = TelnetHelper;\n/*\n * TelnetStream\n */\nclass TelnetStream extends stream_1.Transform {\n    #buffer;\n    #subbuffer;\n    #state;\n    constructor(options) {\n        super(options);\n        this.#buffer = Buffer.alloc(0);\n        this.#subbuffer = Buffer.alloc(0);\n        this.#state = DATA;\n    }\n    _transform(obj, _encoding, callback) {\n        for (let i = 0; i < obj.length; ++i) {\n            this.#handleByte(obj[i]);\n        }\n        const data = this.#getData();\n        if (data.length) {\n            this.push(data);\n        }\n        callback();\n    }\n    #handleByte(byte) {\n        if (this.#state === DATA) {\n            if (byte === IAC) {\n                this.#state = IAC;\n                return;\n            }\n            this.#buffer = Buffer.concat([this.#buffer, Buffer.from([byte])]);\n        }\n        else if (this.#state === IAC) {\n            switch (byte) {\n                case SB:\n                case WILL:\n                case WONT:\n                case DO:\n                case DONT:\n                    this.#state = byte;\n                    break;\n                default:\n                    this.#state = DATA;\n                    break;\n            }\n        }\n        else if (this.#state >= WILL && this.#state <= DONT) {\n            let iac = undefined;\n            switch (this.#state) {\n                case WILL:\n                    iac = 'WILL';\n                    break;\n                case WONT:\n                    iac = 'WONT';\n                    break;\n                case DO:\n                    iac = 'DO';\n                    break;\n                case DONT:\n                    iac = 'DONT';\n                    break;\n                default:\n                    // never hit\n                    return;\n            }\n            this.emit('iac', iac, byte);\n            this.#state = DATA;\n            return;\n        }\n        else if (this.#state === SB) {\n            if (byte === SE) {\n                this.emit('sb', this.#subbuffer);\n                this.#state = DATA;\n                this.#subbuffer = Buffer.alloc(0);\n                return;\n            }\n            this.#subbuffer = Buffer.concat([this.#subbuffer, Buffer.from([byte])]);\n        }\n    }\n    #getData() {\n        const buff = this.#buffer;\n        this.#buffer = Buffer.alloc(0);\n        return buff;\n    }\n}\n//# sourceMappingURL=telnet.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/helpers/telnet.js?\n}")},"./node_modules/@companion-module/base/dist/helpers/udp.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\n/*\n * This file is part of the Companion project\n * Copyright (c) 2018 Bitfocus AS\n * Authors: William Viker <william@bitfocus.io>, Håkon Nessjøen <haakon@bitfocus.io>\n *\n * This program is free software.\n * You should have received a copy of the MIT licence as well as the Bitfocus\n * Individual Contributor License Agreement for companion along with\n * this program.\n *\n * You can be released from the requirements of the license by purchasing\n * a commercial license. Buying such a license is mandatory as soon as you\n * develop commercial activities involving the Companion software without\n * disclosing the source code of your own applications.\n *\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UDPHelper = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst dgram_1 = tslib_1.__importDefault(__webpack_require__(/*! dgram */ \"dgram\"));\nconst eventemitter3_1 = __webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\");\nconst enums_js_1 = __webpack_require__(/*! ../module-api/enums.js */ \"./node_modules/@companion-module/base/dist/module-api/enums.js\");\nclass UDPHelper extends eventemitter3_1.EventEmitter {\n    #host;\n    #port;\n    #socket;\n    #options;\n    #destroyed = false;\n    #lastStatus;\n    #missingErrorHandlerTimer;\n    get isDestroyed() {\n        return this.#destroyed;\n    }\n    constructor(host, port, options) {\n        super();\n        this.#host = host;\n        this.#port = port;\n        this.#options = { ...options };\n        // this.bound = false\n        // this.pending_memberships = []\n        this.#socket = dgram_1.default.createSocket('udp4');\n        try {\n            this.#socket.bind(this.#options.bind_port || 0, this.#options.bind_ip);\n        }\n        catch (_e) {\n            throw new Error(`Unable to bind to ip/port: ${this.#options.bind_ip || '0.0.0.0'}:${this.#options.bind_port || 0}`);\n        }\n        if (this.#options.ttl !== undefined) {\n            this.#socket.setTTL(this.#options.ttl);\n        }\n        if (this.#options.multicast_ttl !== undefined) {\n            this.#socket.setMulticastTTL(this.#options.multicast_ttl);\n        }\n        this.#socket.on('error', (error) => {\n            this.#new_status(enums_js_1.InstanceStatus.UnknownError, error.message);\n            this.emit('error', error);\n        });\n        this.#socket.on('listening', () => {\n            // this.bound = true\n            // if (this.pending_memberships.length) {\n            // \twhile (this.pending_memberships.length > 0) {\n            // \t\tthis.socket.addMembership(member.shift())\n            // \t}\n            // }\n            // Needed to be called after bind() had completed\n            if (this.#options.broadcast) {\n                this.#socket.setBroadcast(true);\n            }\n            if (this.#options.multicast_interface) {\n                this.#socket.setMulticastInterface(this.#options.multicast_interface);\n            }\n            this.#new_status(enums_js_1.InstanceStatus.Ok);\n            this.emit('listening');\n        });\n        // Passing on rinfo to emit instead of omitting it\n        this.#socket.on('message', (data, rinfo) => this.emit('data', data, rinfo));\n        this.#missingErrorHandlerTimer = setTimeout(() => {\n            if (!this.#destroyed && !this.listenerCount('error')) {\n                // The socket is active and has no listeners. Log an error for the module devs!\n                console.error(`Danger: UDP socket for ${this.#host}:${this.#port} is missing an error handler!`);\n            }\n        }, 5000);\n    }\n    async send(message) {\n        if (this.#destroyed)\n            throw new Error('Cannot write to destroyed socket');\n        if (!message || !message.length)\n            throw new Error('No message to send');\n        return new Promise((resolve, reject) => {\n            this.#socket.send(message, this.#port, this.#host, (error) => {\n                if (error) {\n                    reject(error);\n                    return;\n                }\n                resolve();\n            });\n        });\n    }\n    // addMembership(member) {\n    // \tif (!this.bound) {\n    // \t\tthis.pending_memberships.push(member)\n    // \t} else {\n    // \t\tthis.socket.addMembership(member)\n    // \t}\n    // }\n    destroy() {\n        this.#destroyed = true;\n        if (this.#missingErrorHandlerTimer !== undefined) {\n            clearTimeout(this.#missingErrorHandlerTimer);\n            this.#missingErrorHandlerTimer = undefined;\n        }\n        this.#socket.removeAllListeners();\n        this.#socket.close();\n        this.removeAllListeners();\n    }\n    // Private function\n    #new_status(status, message) {\n        if (this.#lastStatus != status) {\n            this.#lastStatus = status;\n            this.emit('status_change', status, message);\n        }\n    }\n}\nexports.UDPHelper = UDPHelper;\n//# sourceMappingURL=udp.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/helpers/udp.js?\n}")},"./node_modules/@companion-module/base/dist/host-api/ipc-wrapper.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.IpcWrapper = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst util_js_1 = __webpack_require__(/*! ../util.js */ \"./node_modules/@companion-module/base/dist/util.js\");\nconst ejson_1 = tslib_1.__importDefault(__webpack_require__(/*! ejson */ \"./node_modules/ejson/index.js\"));\nconst MAX_CALLBACK_ID = 1 << 28;\nclass IpcWrapper {\n    #handlers;\n    #sendMessage;\n    #defaultTimeout;\n    #nextCallbackId = 1;\n    #pendingCallbacks = new Map();\n    constructor(handlers, sendMessage, defaultTimeout) {\n        this.#handlers = handlers;\n        this.#sendMessage = sendMessage;\n        this.#defaultTimeout = defaultTimeout;\n    }\n    async sendWithCb(name, msg, defaultResponse, timeout = 0) {\n        if (timeout <= 0)\n            timeout = this.#defaultTimeout;\n        const callbacks = { timeout: undefined, resolve: () => null, reject: () => null };\n        const promise = new Promise((resolve, reject) => {\n            callbacks.resolve = resolve;\n            callbacks.reject = reject;\n        });\n        // Reset the id when it gets really high\n        if (this.#nextCallbackId > MAX_CALLBACK_ID)\n            this.#nextCallbackId = 1;\n        const id = this.#nextCallbackId++;\n        this.#pendingCallbacks.set(id, callbacks);\n        this.#sendMessage({\n            direction: 'call',\n            name: String(name),\n            payload: ejson_1.default.stringify(msg),\n            callbackId: id,\n        });\n        // Setup a timeout, creating the error in the call, so that the stack trace is useful\n        const timeoutError = new Error('Call timed out');\n        callbacks.timeout = setTimeout(() => {\n            callbacks.reject(defaultResponse ? defaultResponse() : timeoutError);\n            this.#pendingCallbacks.delete(id);\n        }, timeout);\n        return promise;\n    }\n    sendWithNoCb(name, msg) {\n        this.#sendMessage({\n            direction: 'call',\n            name: String(name),\n            payload: ejson_1.default.stringify(msg),\n            callbackId: undefined,\n        });\n    }\n    receivedMessage(msg) {\n        const rawMsg = msg;\n        switch (msg.direction) {\n            case 'call': {\n                const handler = this.#handlers[msg.name];\n                if (!handler) {\n                    if (msg.callbackId) {\n                        this.#sendMessage({\n                            direction: 'response',\n                            callbackId: msg.callbackId,\n                            success: false,\n                            payload: ejson_1.default.stringify({ message: `Unknown command \"${msg.name}\"` }),\n                        });\n                    }\n                    return;\n                }\n                // TODO - should anything be logged here?\n                const data = msg.payload ? ejson_1.default.parse(msg.payload) : undefined;\n                handler(data).then((res) => {\n                    if (msg.callbackId) {\n                        this.#sendMessage({\n                            direction: 'response',\n                            callbackId: msg.callbackId,\n                            success: true,\n                            payload: ejson_1.default.stringify(res),\n                        });\n                    }\n                }, (err) => {\n                    if (msg.callbackId) {\n                        this.#sendMessage({\n                            direction: 'response',\n                            callbackId: msg.callbackId,\n                            success: false,\n                            payload: err instanceof Error ? JSON.stringify(err, Object.getOwnPropertyNames(err)) : ejson_1.default.stringify(err),\n                        });\n                    }\n                });\n                break;\n            }\n            case 'response': {\n                if (!msg.callbackId) {\n                    console.error(`Ipc: Response message has no callbackId`);\n                    return;\n                }\n                const callbacks = this.#pendingCallbacks.get(msg.callbackId);\n                this.#pendingCallbacks.delete(msg.callbackId);\n                if (!callbacks) {\n                    // Likely timed out, we should ignore\n                    return;\n                }\n                clearTimeout(callbacks.timeout);\n                const data = msg.payload ? ejson_1.default.parse(msg.payload) : undefined;\n                if (msg.success) {\n                    callbacks.resolve(data);\n                }\n                else {\n                    let err = data;\n                    if (data && typeof data === 'object' && 'message' in data) {\n                        err = new Error(data.message);\n                        if (data.stack)\n                            err.stack = data.stack;\n                    }\n                    callbacks.reject(err);\n                }\n                break;\n            }\n            default:\n                (0, util_js_1.assertNever)(msg);\n                console.error(`Ipc: Message of unknown direction \"${rawMsg.direction}\"`);\n                break;\n        }\n    }\n}\nexports.IpcWrapper = IpcWrapper;\n//# sourceMappingURL=ipc-wrapper.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/host-api/ipc-wrapper.js?\n}")},"./node_modules/@companion-module/base/dist/host-api/versions.js":(__unused_webpack_module,exports)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.HostApiNodeJsIpc = void 0;\nexports.HostApiNodeJsIpc = 'nodejs-ipc';\n//# sourceMappingURL=versions.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/host-api/versions.js?\n}")},"./node_modules/@companion-module/base/dist/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.runEntrypoint = exports.substituteEscapeCharacters = exports.parseEscapeCharacters = exports.assertNever = exports.splitHex = exports.splitHsv = exports.splitHsl = exports.splitRgb = exports.combineRgb = exports.literal = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");\ntslib_1.__exportStar(__webpack_require__(/*! ./manifest.js */ "./node_modules/@companion-module/base/dist/manifest.js"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./module-api/index.js */ "./node_modules/@companion-module/base/dist/module-api/index.js"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./common/osc.js */ "./node_modules/@companion-module/base/dist/common/osc.js"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./common/json-value.js */ "./node_modules/@companion-module/base/dist/common/json-value.js"), exports);\nvar util_js_1 = __webpack_require__(/*! ./util.js */ "./node_modules/@companion-module/base/dist/util.js");\nObject.defineProperty(exports, "literal", ({ enumerable: true, get: function () { return util_js_1.literal; } }));\nObject.defineProperty(exports, "combineRgb", ({ enumerable: true, get: function () { return util_js_1.combineRgb; } }));\nObject.defineProperty(exports, "splitRgb", ({ enumerable: true, get: function () { return util_js_1.splitRgb; } }));\nObject.defineProperty(exports, "splitHsl", ({ enumerable: true, get: function () { return util_js_1.splitHsl; } }));\nObject.defineProperty(exports, "splitHsv", ({ enumerable: true, get: function () { return util_js_1.splitHsv; } }));\nObject.defineProperty(exports, "splitHex", ({ enumerable: true, get: function () { return util_js_1.splitHex; } }));\nObject.defineProperty(exports, "assertNever", ({ enumerable: true, get: function () { return util_js_1.assertNever; } }));\nObject.defineProperty(exports, "parseEscapeCharacters", ({ enumerable: true, get: function () { return util_js_1.parseEscapeCharacters; } }));\nObject.defineProperty(exports, "substituteEscapeCharacters", ({ enumerable: true, get: function () { return util_js_1.substituteEscapeCharacters; } }));\ntslib_1.__exportStar(__webpack_require__(/*! ./helpers/index.js */ "./node_modules/@companion-module/base/dist/helpers/index.js"), exports);\nvar entrypoint_js_1 = __webpack_require__(/*! ./entrypoint.js */ "./node_modules/@companion-module/base/dist/entrypoint.js");\nObject.defineProperty(exports, "runEntrypoint", ({ enumerable: true, get: function () { return entrypoint_js_1.runEntrypoint; } }));\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/index.js?\n}')},"./node_modules/@companion-module/base/dist/internal/actions.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.ActionManager = void 0;\nconst base_js_1 = __webpack_require__(/*! ./base.js */ \"./node_modules/@companion-module/base/dist/internal/base.js\");\nfunction convertActionInstanceToEvent(action) {\n    return {\n        id: action.id,\n        actionId: action.actionId,\n        controlId: action.controlId,\n        options: action.options,\n    };\n}\nclass ActionManager {\n    #parseVariablesInString;\n    #setActionDefinitions;\n    #setCustomVariableValue;\n    #log;\n    #actionDefinitions = new Map();\n    #actionInstances = new Map();\n    constructor(parseVariablesInString, setActionDefinitions, setCustomVariableValue, log) {\n        this.#parseVariablesInString = parseVariablesInString;\n        this.#setActionDefinitions = setActionDefinitions;\n        this.#setCustomVariableValue = setCustomVariableValue;\n        this.#log = log;\n    }\n    async handleExecuteAction(msg) {\n        const actionDefinition = this.#actionDefinitions.get(msg.action.actionId);\n        if (!actionDefinition)\n            throw new Error(`Unknown action: ${msg.action.actionId}`);\n        const context = {\n            parseVariablesInString: async (text) => {\n                const res = await this.#parseVariablesInString({\n                    text: text,\n                    controlId: msg.action.controlId,\n                    actionInstanceId: msg.action.id,\n                    feedbackInstanceId: undefined,\n                });\n                return res.text;\n            },\n            setCustomVariableValue: (variableName, value) => {\n                this.#setCustomVariableValue({\n                    customVariableId: variableName,\n                    value,\n                    controlId: msg.action.controlId,\n                });\n            },\n        };\n        await actionDefinition.callback({\n            id: msg.action.id,\n            actionId: msg.action.actionId,\n            controlId: msg.action.controlId,\n            options: msg.action.options,\n            surfaceId: msg.surfaceId,\n        }, context);\n    }\n    handleUpdateActions(actions) {\n        for (const [id, action] of Object.entries(actions)) {\n            const existing = this.#actionInstances.get(id);\n            if (existing) {\n                // Call unsubscribe\n                const definition = this.#actionDefinitions.get(existing.actionId);\n                if (definition?.unsubscribe && !definition.skipUnsubscribeOnOptionsChange) {\n                    const context = {\n                        parseVariablesInString: async (text) => {\n                            // No-op, any values parsed here will not be stable\n                            return text;\n                        },\n                        setCustomVariableValue: () => {\n                            throw new Error(`setCustomVariableValue is not available during unsubscribe`);\n                        },\n                    };\n                    Promise.resolve(definition.unsubscribe(convertActionInstanceToEvent(existing), context)).catch((e) => {\n                        this.#log('error', `Action unsubscribe failed: ${JSON.stringify(existing)} - ${e?.message ?? e} ${e?.stack}`);\n                    });\n                }\n            }\n            if (!action || action.disabled) {\n                // Deleted\n                this.#actionInstances.delete(id);\n            }\n            else {\n                // TODO module-lib - deep freeze the action to avoid mutation?\n                this.#actionInstances.set(id, action);\n                // Inserted or updated\n                const definition = this.#actionDefinitions.get(action.actionId);\n                if (definition?.subscribe) {\n                    const context = {\n                        parseVariablesInString: async (text) => {\n                            // No-op, any values parsed here will not be stable\n                            return text;\n                        },\n                        setCustomVariableValue: () => {\n                            throw new Error(`setCustomVariableValue is not available during subscribe`);\n                        },\n                    };\n                    Promise.resolve(definition.subscribe(convertActionInstanceToEvent(action), context)).catch((e) => {\n                        this.#log('error', `Action subscribe failed: ${JSON.stringify(action)} - ${e?.message ?? e} ${e?.stack}`);\n                    });\n                }\n            }\n        }\n    }\n    async handleLearnAction(msg) {\n        const definition = this.#actionDefinitions.get(msg.action.actionId);\n        if (definition && definition.learn) {\n            const context = {\n                parseVariablesInString: async (text) => {\n                    const res = await this.#parseVariablesInString({\n                        text: text,\n                        controlId: msg.action.controlId,\n                        actionInstanceId: msg.action.id,\n                        feedbackInstanceId: undefined,\n                    });\n                    return res.text;\n                },\n                setCustomVariableValue: () => {\n                    throw new Error(`setCustomVariableValue is not available during learn`);\n                },\n            };\n            const newOptions = await definition.learn({\n                id: msg.action.id,\n                actionId: msg.action.actionId,\n                controlId: msg.action.controlId,\n                options: msg.action.options,\n                surfaceId: undefined,\n            }, context);\n            return {\n                options: newOptions,\n            };\n        }\n        else {\n            // Not supported\n            return {\n                options: undefined,\n            };\n        }\n    }\n    setActionDefinitions(actions) {\n        const hostActions = [];\n        this.#actionDefinitions.clear();\n        for (const [actionId, action] of Object.entries(actions)) {\n            if (action) {\n                hostActions.push({\n                    id: actionId,\n                    name: action.name,\n                    description: action.description,\n                    options: (0, base_js_1.serializeIsVisibleFn)(action.options),\n                    optionsToIgnoreForSubscribe: action.optionsToIgnoreForSubscribe,\n                    hasLearn: !!action.learn,\n                    learnTimeout: action.learnTimeout,\n                    hasLifecycleFunctions: !!action.subscribe || !!action.unsubscribe,\n                });\n                // Remember the definition locally\n                this.#actionDefinitions.set(actionId, action);\n            }\n        }\n        this.#setActionDefinitions({ actions: hostActions });\n    }\n    subscribeActions(actionIds) {\n        let actions = Array.from(this.#actionInstances.values());\n        const actionIdSet = new Set(actionIds);\n        if (actionIdSet.size)\n            actions = actions.filter((fb) => actionIdSet.has(fb.actionId));\n        for (const act of actions) {\n            const def = this.#actionDefinitions.get(act.actionId);\n            if (def?.subscribe) {\n                const context = {\n                    parseVariablesInString: async (text) => {\n                        // No-op, any values parsed here will not be stable\n                        return text;\n                    },\n                    setCustomVariableValue: () => {\n                        throw new Error(`setCustomVariableValue is not available during subscribe`);\n                    },\n                };\n                Promise.resolve(def.subscribe(convertActionInstanceToEvent(act), context)).catch((e) => {\n                    this.#log('error', `Action subscribe failed: ${JSON.stringify(act)} - ${e?.message ?? e} ${e?.stack}`);\n                });\n            }\n        }\n    }\n    unsubscribeActions(actionIds) {\n        let actions = Array.from(this.#actionInstances.values());\n        const actionIdSet = new Set(actionIds);\n        if (actionIdSet.size)\n            actions = actions.filter((fb) => actionIdSet.has(fb.actionId));\n        for (const act of actions) {\n            const def = this.#actionDefinitions.get(act.actionId);\n            if (def && def.unsubscribe) {\n                const context = {\n                    parseVariablesInString: async (text) => {\n                        // No-op, any values parsed here will not be stable\n                        return text;\n                    },\n                    setCustomVariableValue: () => {\n                        throw new Error(`setCustomVariableValue is not available during unsubscribe`);\n                    },\n                };\n                Promise.resolve(def.unsubscribe(convertActionInstanceToEvent(act), context)).catch((e) => {\n                    this.#log('error', `Action unsubscribe failed: ${JSON.stringify(act)} - ${e?.message ?? e} ${e?.stack}`);\n                });\n            }\n        }\n    }\n}\nexports.ActionManager = ActionManager;\n//# sourceMappingURL=actions.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/internal/actions.js?\n}")},"./node_modules/@companion-module/base/dist/internal/base.js":(__unused_webpack_module,exports)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.serializeIsVisibleFn = serializeIsVisibleFn;\nexports.isInstanceBaseProps = isInstanceBaseProps;\nfunction serializeIsVisibleFn(options) {\n    return (options ?? []).map((option) => {\n        if ('isVisibleExpression' in option && typeof option.isVisibleExpression === 'string') {\n            return {\n                ...option,\n                isVisibleFnType: 'expression',\n                isVisibleFn: option.isVisibleExpression,\n                isVisible: undefined,\n                isVisibleExpression: undefined,\n            };\n        }\n        else if ('isVisible' in option && typeof option.isVisible === 'function') {\n            return {\n                ...option,\n                isVisibleFn: option.isVisible.toString(),\n                isVisibleFnType: 'function',\n                isVisible: undefined,\n                isVisibleExpression: undefined,\n            };\n        }\n        // ignore any existing `isVisibleFn` to avoid code injection\n        return {\n            ...option,\n            isVisible: undefined,\n            isVisibleFn: undefined,\n            isVisibleFnType: undefined,\n            isVisibleExpression: undefined,\n        };\n    });\n}\nfunction isInstanceBaseProps(obj) {\n    const obj2 = obj;\n    return typeof obj2 === 'object' && typeof obj2.id === 'string' && obj2._isInstanceBaseProps === true;\n}\n//# sourceMappingURL=base.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/internal/base.js?\n}")},"./node_modules/@companion-module/base/dist/internal/feedback.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.FeedbackManager = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst base_js_1 = __webpack_require__(/*! ./base.js */ \"./node_modules/@companion-module/base/dist/internal/base.js\");\n// eslint-disable-next-line n/no-missing-import\nconst index_js_1 = tslib_1.__importDefault(__webpack_require__(/*! ../../lib/debounce-fn/index.js */ \"./node_modules/@companion-module/base/lib/debounce-fn/index.js\"));\nconst util_js_1 = __webpack_require__(/*! ../util.js */ \"./node_modules/@companion-module/base/dist/util.js\");\nfunction convertFeedbackInstanceToEvent(type, feedback) {\n    return {\n        type: type,\n        id: feedback.id,\n        feedbackId: feedback.feedbackId,\n        controlId: feedback.controlId,\n        options: feedback.options,\n    };\n}\nclass FeedbackManager {\n    #parseVariablesInString;\n    #updateFeedbackValues;\n    #setFeedbackDefinitions;\n    #log;\n    #feedbackDefinitions = new Map();\n    #feedbackInstances = new Map();\n    // Feedback values waiting to be sent\n    #pendingFeedbackValues = new Map();\n    // Feedbacks currently being checked\n    #feedbacksBeingChecked = new Map();\n    // while in a context which provides an alternate parseVariablesInString, we should log when the original is called\n    #parseVariablesContext;\n    get parseVariablesContext() {\n        return this.#parseVariablesContext;\n    }\n    constructor(parseVariablesInString, updateFeedbackValues, setFeedbackDefinitions, log) {\n        this.#parseVariablesInString = parseVariablesInString;\n        this.#updateFeedbackValues = updateFeedbackValues;\n        this.#setFeedbackDefinitions = setFeedbackDefinitions;\n        this.#log = log;\n    }\n    getDefinitionIds() {\n        return Array.from(this.#feedbackDefinitions.keys());\n    }\n    getInstanceIds() {\n        return Array.from(this.#feedbackInstances.keys());\n    }\n    handleUpdateFeedbacks(feedbacks) {\n        for (const [id, feedback] of Object.entries(feedbacks)) {\n            const existing = this.#feedbackInstances.get(id);\n            if (existing && !feedback) {\n                // Call unsubscribe\n                const definition = this.#feedbackDefinitions.get(existing.feedbackId);\n                if (definition?.unsubscribe) {\n                    const context = {\n                        parseVariablesInString: async (text) => {\n                            // No-op, any values parsed here will not be stable\n                            return text;\n                        },\n                    };\n                    Promise.resolve(definition.unsubscribe(convertFeedbackInstanceToEvent(definition.type, existing), context)).catch((e) => {\n                        this.#log('error', `Feedback unsubscribe failed: ${JSON.stringify(existing)} - ${e?.message ?? e} ${e?.stack}`);\n                    });\n                }\n            }\n            if (!feedback || feedback.disabled) {\n                // Deleted\n                this.#feedbackInstances.delete(id);\n            }\n            else {\n                // TODO module-lib - deep freeze the feedback to avoid mutation?\n                this.#feedbackInstances.set(id, { ...feedback });\n                // Inserted\n                if (!existing) {\n                    const definition = this.#feedbackDefinitions.get(feedback.feedbackId);\n                    if (definition?.subscribe) {\n                        const context = {\n                            parseVariablesInString: async (text) => {\n                                // No-op, any values parsed here will not be stable\n                                return text;\n                            },\n                        };\n                        Promise.resolve(definition.subscribe(convertFeedbackInstanceToEvent(definition.type, feedback), context)).catch((e) => {\n                            this.#log('error', `Feedback subscribe failed: ${JSON.stringify(feedback)} - ${e?.message ?? e} ${e?.stack}`);\n                        });\n                    }\n                }\n                // update the feedback value\n                this.#triggerCheckFeedback(id);\n            }\n        }\n    }\n    async handleLearnFeedback(msg) {\n        const definition = this.#feedbackDefinitions.get(msg.feedback.feedbackId);\n        if (definition && definition.learn) {\n            const context = {\n                parseVariablesInString: async (text) => {\n                    const res = await this.#parseVariablesInString({\n                        text: text,\n                        controlId: msg.feedback.controlId,\n                        actionInstanceId: undefined,\n                        feedbackInstanceId: msg.feedback.id,\n                    });\n                    return res.text;\n                },\n            };\n            const newOptions = await definition.learn({\n                id: msg.feedback.id,\n                feedbackId: msg.feedback.feedbackId,\n                controlId: msg.feedback.controlId,\n                options: msg.feedback.options,\n                type: definition.type,\n            }, context);\n            return {\n                options: newOptions,\n            };\n        }\n        else {\n            // Not supported\n            return {\n                options: undefined,\n            };\n        }\n    }\n    #triggerCheckFeedback(id) {\n        const existingRecheck = this.#feedbacksBeingChecked.get(id);\n        if (existingRecheck) {\n            // Already being checked\n            existingRecheck.needsRecheck = true;\n            return;\n        }\n        const feedback0 = this.#feedbackInstances.get(id);\n        if (!feedback0)\n            return;\n        const feedback = feedback0;\n        const feedbackCheckStatus = {\n            needsRecheck: false,\n        };\n        // mark it as being checked\n        this.#feedbacksBeingChecked.set(id, feedbackCheckStatus);\n        Promise.resolve()\n            .then(async () => {\n            const definition = this.#feedbackDefinitions.get(feedback.feedbackId);\n            let value;\n            // Calculate the new value for the feedback\n            if (definition) {\n                // Set this while the promise starts executing\n                this.#parseVariablesContext = `Feedback ${feedback.feedbackId} (${id})`;\n                const context = {\n                    parseVariablesInString: async (text) => {\n                        const res = await this.#parseVariablesInString({\n                            text: text,\n                            controlId: feedback.controlId,\n                            actionInstanceId: undefined,\n                            feedbackInstanceId: id,\n                        });\n                        return res.text;\n                    },\n                };\n                switch (definition.type) {\n                    case 'boolean':\n                        value = definition.callback({\n                            ...convertFeedbackInstanceToEvent('boolean', feedback),\n                            type: 'boolean',\n                        }, context);\n                        break;\n                    case 'value':\n                        value = definition.callback({\n                            ...convertFeedbackInstanceToEvent('value', feedback),\n                            type: 'value',\n                        }, context);\n                        break;\n                    case 'advanced':\n                        value = definition.callback({\n                            ...convertFeedbackInstanceToEvent('advanced', feedback),\n                            type: 'advanced',\n                            image: feedback.image,\n                        }, context);\n                        break;\n                    default:\n                        (0, util_js_1.assertNever)(definition);\n                        break;\n                }\n                this.#parseVariablesContext = undefined;\n            }\n            // Await the value before looking at this.#pendingFeedbackValues, to avoid race conditions\n            const resolvedValue = await value;\n            this.#pendingFeedbackValues.set(id, {\n                id: id,\n                controlId: feedback.controlId,\n                value: resolvedValue,\n            });\n            this.#sendFeedbackValues();\n        })\n            .catch((e) => {\n            console.error(`Feedback check failed: ${JSON.stringify(feedback)} - ${e?.message ?? e} ${e?.stack}`);\n        })\n            .finally(() => {\n            // ensure this.#parseVariablesContext is cleared\n            this.#parseVariablesContext = undefined;\n            // it is no longer being checked\n            this.#feedbacksBeingChecked.delete(id);\n            // If queued, trigger a check\n            if (feedbackCheckStatus.needsRecheck) {\n                setImmediate(() => {\n                    this.#triggerCheckFeedback(id);\n                });\n            }\n        });\n    }\n    /**\n     * Send pending feedback values (from this.#pendingFeedbackValues) to companion, with a debounce\n     */\n    #sendFeedbackValues = (0, index_js_1.default)(() => {\n        const newValues = this.#pendingFeedbackValues;\n        this.#pendingFeedbackValues = new Map();\n        // Send the new values back\n        if (newValues.size > 0) {\n            this.#updateFeedbackValues({\n                values: Array.from(newValues.values()),\n            });\n        }\n    }, {\n        wait: 5,\n        maxWait: 25,\n    });\n    setFeedbackDefinitions(feedbacks) {\n        const hostFeedbacks = [];\n        this.#feedbackDefinitions.clear();\n        for (const [feedbackId, feedback] of Object.entries(feedbacks)) {\n            if (feedback) {\n                hostFeedbacks.push({\n                    id: feedbackId,\n                    name: feedback.name,\n                    description: feedback.description,\n                    options: (0, base_js_1.serializeIsVisibleFn)(feedback.options),\n                    type: feedback.type,\n                    defaultStyle: feedback.type === 'boolean' ? feedback.defaultStyle : undefined,\n                    hasLearn: !!feedback.learn,\n                    learnTimeout: feedback.learnTimeout,\n                    showInvert: feedback.type === 'boolean' ? feedback.showInvert : false,\n                });\n                // Remember the definition locally\n                this.#feedbackDefinitions.set(feedbackId, feedback);\n            }\n        }\n        this.#setFeedbackDefinitions({ feedbacks: hostFeedbacks });\n    }\n    checkFeedbacks(feedbackTypes) {\n        const types = new Set(feedbackTypes);\n        for (const [id, feedback] of this.#feedbackInstances.entries()) {\n            const definition = this.#feedbackDefinitions.get(feedback.feedbackId);\n            if (definition) {\n                if (types.size === 0 || types.has(feedback.feedbackId)) {\n                    // update the feedback value\n                    this.#triggerCheckFeedback(id);\n                }\n            }\n        }\n    }\n    checkFeedbacksById(feedbackIds) {\n        for (const id of feedbackIds) {\n            // update the feedback value\n            this.#triggerCheckFeedback(id);\n        }\n    }\n    subscribeFeedbacks(feedbackIds) {\n        let feedbacks = Array.from(this.#feedbackInstances.values());\n        const feedbackIdSet = new Set(feedbackIds);\n        if (feedbackIdSet.size)\n            feedbacks = feedbacks.filter((fb) => feedbackIdSet.has(fb.feedbackId));\n        for (const fb of feedbacks) {\n            const def = this.#feedbackDefinitions.get(fb.feedbackId);\n            if (def?.subscribe) {\n                const context = {\n                    parseVariablesInString: async (text) => {\n                        // No-op, any values parsed here will not be stable\n                        return text;\n                    },\n                };\n                Promise.resolve(def.subscribe(convertFeedbackInstanceToEvent(def.type, fb), context)).catch((e) => {\n                    this.#log('error', `Feedback subscribe failed: ${JSON.stringify(fb)} - ${e?.message ?? e} ${e?.stack}`);\n                });\n            }\n        }\n    }\n    unsubscribeFeedbacks(feedbackIds) {\n        let feedbacks = Array.from(this.#feedbackInstances.values());\n        const feedbackIdSet = new Set(feedbackIds);\n        if (feedbackIdSet.size)\n            feedbacks = feedbacks.filter((fb) => feedbackIdSet.has(fb.feedbackId));\n        for (const fb of feedbacks) {\n            const def = this.#feedbackDefinitions.get(fb.feedbackId);\n            if (def && def.unsubscribe) {\n                const context = {\n                    parseVariablesInString: async (text) => {\n                        // No-op, any values parsed here will not be stable\n                        return text;\n                    },\n                };\n                Promise.resolve(def.unsubscribe(convertFeedbackInstanceToEvent(def.type, fb), context)).catch((e) => {\n                    this.#log('error', `Feedback unsubscribe failed: ${JSON.stringify(fb)} - ${e?.message ?? e} ${e?.stack}`);\n                });\n            }\n        }\n    }\n}\nexports.FeedbackManager = FeedbackManager;\n//# sourceMappingURL=feedback.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/internal/feedback.js?\n}")},"./node_modules/@companion-module/base/dist/internal/upgrade.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.runThroughUpgradeScripts = runThroughUpgradeScripts;\nconst util_js_1 = __webpack_require__(/*! ../util.js */ \"./node_modules/@companion-module/base/dist/util.js\");\nfunction clone(val) {\n    return JSON.parse(JSON.stringify(val));\n}\n/**\n * Run through the upgrade scripts for the given data\n * Note: this updates the inputs in place, but the result needs to be sent back to companion\n * @param allActions Actions that may need upgrading\n * @param allFeedbacks Feedbacks that may need upgrading\n * @param defaultUpgradeIndex The lastUpgradeIndex of the connection, if known\n * @param upgradeScripts The scripts that may be run\n * @param config The current config of the module\n * @param skipConfigAndSecretsUpgrade Whether to skip upgrading the config and secrets\n * @returns The upgraded data that needs persisting\n */\nfunction runThroughUpgradeScripts(allActionsArray, allFeedbacksArray, defaultUpgradeIndex, upgradeScripts, config, secrets, skipConfigAndSecretsUpgrade) {\n    // First we group all the actions and feedbacks by the version they currently are.\n    const pendingUpgradesGrouped = new Map();\n    const getPendingUpgradeGroup = (i) => {\n        let v = pendingUpgradesGrouped.get(i);\n        if (!v) {\n            v = { actions: [], feedbacks: [], config: false };\n            pendingUpgradesGrouped.set(i, v);\n        }\n        return v;\n    };\n    for (const action of allActionsArray) {\n        const upgradeIndex = action?.upgradeIndex ?? defaultUpgradeIndex;\n        if (action && typeof upgradeIndex === 'number') {\n            const pending = getPendingUpgradeGroup(upgradeIndex);\n            pending.actions.push(action.id);\n        }\n    }\n    for (const feedback of allFeedbacksArray) {\n        const upgradeIndex = feedback?.upgradeIndex ?? defaultUpgradeIndex;\n        if (feedback && typeof upgradeIndex === 'number') {\n            const pending = getPendingUpgradeGroup(upgradeIndex);\n            pending.feedbacks.push(feedback.id);\n        }\n    }\n    if (!skipConfigAndSecretsUpgrade) {\n        // If there is config we still need to upgrade that\n        for (let i = defaultUpgradeIndex ?? -1; i < upgradeScripts.length; i++) {\n            // ensure the group is registered\n            getPendingUpgradeGroup(i).config = true;\n        }\n    }\n    const allActions = Object.fromEntries(allActionsArray.map((a) => [a.id, a]));\n    const allFeedbacks = Object.fromEntries(allFeedbacksArray.map((a) => [a.id, a]));\n    const updatedFeedbacks = {};\n    const updatedActions = {};\n    let updatedConfig;\n    let updatedSecrets;\n    if (pendingUpgradesGrouped.size > 0) {\n        // Figure out which script to run first. Note: we track the last index we ran, so it is offset by one\n        const pendingUpgradeGroups = Array.from(pendingUpgradesGrouped.keys()).sort();\n        const firstUpgradeGroup = Math.min(...pendingUpgradeGroups, defaultUpgradeIndex ?? -1) + 1;\n        // Start building arrays of the ids which we are upgrading as we go\n        const actionsIdsToUpgrade = [];\n        const feedbackIdsToUpgrade = [];\n        // Perform the upgrades. We start on the first batch/instance, and work our way up to the last\n        const targetCount = upgradeScripts.length;\n        for (let i = firstUpgradeGroup; i < targetCount; i++) {\n            const group = pendingUpgradesGrouped.get(i - 1);\n            if (group) {\n                // Update the list of objects that need upgrading\n                actionsIdsToUpgrade.push(...group.actions);\n                feedbackIdsToUpgrade.push(...group.feedbacks);\n            }\n            // Only upgrade the config, if we are past the last version we had for it\n            const upgradeConfigAndSecrets = !!group?.config;\n            // Ensure there is something to upgrade\n            if (!upgradeConfigAndSecrets && actionsIdsToUpgrade.length === 0 && feedbackIdsToUpgrade.length === 0)\n                continue;\n            const inputConfig = updatedConfig ?? config;\n            const inputSecrets = updatedSecrets ?? secrets;\n            // We have an upgrade script that can be run\n            const fcn = upgradeScripts[i];\n            const res = fcn({\n                // Pass a clone to avoid mutations\n                currentConfig: clone(inputConfig),\n            }, {\n                config: upgradeConfigAndSecrets ? inputConfig : null,\n                secrets: upgradeConfigAndSecrets ? inputSecrets : null,\n                // Only pass the actions & feedbacks which need upgrading from this version\n                actions: actionsIdsToUpgrade\n                    .map((id) => {\n                    const inst = allActions[id];\n                    if (inst) {\n                        return (0, util_js_1.literal)({\n                            id: inst.id,\n                            controlId: inst.controlId,\n                            actionId: inst.actionId,\n                            options: inst.options !== undefined ? clone(inst.options) : {},\n                        });\n                    }\n                })\n                    .filter((v) => !!v),\n                feedbacks: feedbackIdsToUpgrade\n                    .map((id) => {\n                    const inst = allFeedbacks[id];\n                    if (inst) {\n                        return (0, util_js_1.literal)({\n                            id: inst.id,\n                            controlId: inst.controlId,\n                            feedbackId: inst.feedbackId,\n                            options: inst.options !== undefined ? clone(inst.options) : {},\n                            // TODO - style?\n                            isInverted: inst.isInverted,\n                        });\n                    }\n                })\n                    .filter((v) => !!v),\n            });\n            // Apply changes\n            if (upgradeConfigAndSecrets && res.updatedConfig)\n                updatedConfig = res.updatedConfig;\n            if (upgradeConfigAndSecrets && res.updatedSecrets)\n                updatedSecrets = res.updatedSecrets;\n            for (const action of res.updatedActions) {\n                if (action) {\n                    const instance = allActions[action.id];\n                    if (instance) {\n                        instance.actionId = action.actionId;\n                        instance.options = action.options;\n                        instance.upgradeIndex = i;\n                        // Mark it as changed\n                        updatedActions[action.id] = instance;\n                    }\n                }\n            }\n            for (const feedback of res.updatedFeedbacks) {\n                if (feedback) {\n                    const instance = allFeedbacks[feedback.id];\n                    if (instance) {\n                        instance.feedbackId = feedback.feedbackId;\n                        instance.options = feedback.options;\n                        instance.upgradeIndex = i;\n                        // Mark it as changed\n                        updatedFeedbacks[feedback.id] = {\n                            ...instance,\n                            style: updatedFeedbacks[feedback.id]?.style ?? feedback.style,\n                            isInverted: feedback.isInverted ?? false,\n                        };\n                    }\n                }\n            }\n        }\n        // Make sure that everything with a upgradeIndex set is sent back\n        for (const [id, action] of Object.entries(allActions)) {\n            if (!updatedActions[id] && typeof action?.upgradeIndex === 'number') {\n                // Send it back to acknowledge that it has been 'upgraded'\n                updatedActions[id] = action;\n            }\n        }\n        for (const [id, feedback] of Object.entries(allFeedbacks)) {\n            if (!updatedFeedbacks[id] && typeof feedback?.upgradeIndex === 'number') {\n                // Send it back to acknowledge that it has been 'upgraded'\n                updatedFeedbacks[id] = feedback;\n            }\n        }\n    }\n    return {\n        updatedActions: Object.values(updatedActions),\n        updatedFeedbacks: Object.values(updatedFeedbacks),\n        updatedConfig,\n        updatedSecrets,\n        latestUpgradeIndex: upgradeScripts.length - 1,\n    };\n}\n//# sourceMappingURL=upgrade.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/internal/upgrade.js?\n}")},"./node_modules/@companion-module/base/dist/manifest.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.validateManifest = validateManifest;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\n// @ts-expect-error no typings\n// eslint-disable-next-line n/no-missing-import\nconst validate_manifest_js_1 = tslib_1.__importDefault(__webpack_require__(/*! ../generated/validate_manifest.js */ \"./node_modules/@companion-module/base/generated/validate_manifest.js\"));\n/** Validate that a manifest looks correctly populated */\nfunction validateManifest(manifest, looseChecks) {\n    if (!looseChecks) {\n        const manifestStr = JSON.stringify(manifest);\n        if (manifestStr.includes('companion-module-your-module-name'))\n            throw new Error(`Manifest incorrectly references template module 'companion-module-your-module-name'`);\n        if (manifestStr.includes('module-shortname'))\n            throw new Error(`Manifest incorrectly references template module 'module-shortname'`);\n        if (manifestStr.includes('A short one line description of your module'))\n            throw new Error(`Manifest incorrectly references template module 'A short one line description of your module'`);\n        if (manifestStr.includes('Your name'))\n            throw new Error(`Manifest incorrectly references template module 'Your name'`);\n        if (manifestStr.includes('Your email'))\n            throw new Error(`Manifest incorrectly references template module 'Your email'`);\n        if (manifestStr.includes('Your company'))\n            throw new Error(`Manifest incorrectly references template module 'Your company'`);\n        if (manifestStr.includes('Your product'))\n            throw new Error(`Manifest incorrectly references template module 'Your product'`);\n    }\n    if (manifest.legacyIds.includes(manifest.id)) {\n        throw new Error(`Manifest contains itself '${manifest.id}' in legacyIds`);\n    }\n    if (!(0, validate_manifest_js_1.default)(manifest)) {\n        const errors = validate_manifest_js_1.default.errors;\n        if (!errors)\n            throw new Error(`Manifest failed validation with unknown reason`);\n        throw new Error(`Manifest validation failed: ${JSON.stringify(errors)}`);\n    }\n}\n//# sourceMappingURL=manifest.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/manifest.js?\n}")},"./node_modules/@companion-module/base/dist/module-api/action.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=action.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/module-api/action.js?\n}')},"./node_modules/@companion-module/base/dist/module-api/base.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.InstanceBase = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst util_js_1 = __webpack_require__(/*! ../util.js */ \"./node_modules/@companion-module/base/dist/util.js\");\nconst p_queue_1 = tslib_1.__importDefault(__webpack_require__(/*! p-queue */ \"./node_modules/p-queue/dist/index.js\"));\nconst base_js_1 = __webpack_require__(/*! ../internal/base.js */ \"./node_modules/@companion-module/base/dist/internal/base.js\");\nconst upgrade_js_1 = __webpack_require__(/*! ../internal/upgrade.js */ \"./node_modules/@companion-module/base/dist/internal/upgrade.js\");\nconst feedback_js_1 = __webpack_require__(/*! ../internal/feedback.js */ \"./node_modules/@companion-module/base/dist/internal/feedback.js\");\nconst ipc_wrapper_js_1 = __webpack_require__(/*! ../host-api/ipc-wrapper.js */ \"./node_modules/@companion-module/base/dist/host-api/ipc-wrapper.js\");\nconst actions_js_1 = __webpack_require__(/*! ../internal/actions.js */ \"./node_modules/@companion-module/base/dist/internal/actions.js\");\nconst shared_udp_socket_js_1 = __webpack_require__(/*! ./shared-udp-socket.js */ \"./node_modules/@companion-module/base/dist/module-api/shared-udp-socket.js\");\nclass InstanceBase {\n    #ipcWrapper;\n    #upgradeScripts;\n    id;\n    #lifecycleQueue = new p_queue_1.default({ concurrency: 1 });\n    #initialized = false;\n    #recordingActions = false;\n    #lastConfig = {};\n    #lastSecrets = {};\n    #actionManager;\n    #feedbackManager;\n    #sharedUdpSocketHandlers = new Map();\n    #variableDefinitions = new Map();\n    #variableValues = new Map();\n    #options;\n    #label;\n    get instanceOptions() {\n        return this.#options;\n    }\n    /**\n     * The user chosen name for this instance.\n     * This can be changed just before `configUpdated` is called\n     */\n    get label() {\n        return this.#label;\n    }\n    /**\n     * Create an instance of the module\n     */\n    constructor(internal) {\n        if (!(0, base_js_1.isInstanceBaseProps)(internal) || !internal._isInstanceBaseProps)\n            throw new Error(`Module instance is being constructed incorrectly. Make sure you aren't trying to do this manually`);\n        this.createSharedUdpSocket = this.createSharedUdpSocket.bind(this);\n        this.#options = {\n            disableVariableValidation: false,\n        };\n        this.#ipcWrapper = new ipc_wrapper_js_1.IpcWrapper({\n            init: this._handleInit.bind(this),\n            destroy: this._handleDestroy.bind(this),\n            updateConfigAndLabel: this._handleConfigUpdateAndLabel.bind(this),\n            updateConfig: async () => undefined, // Replaced by updateConfigAndLabel\n            executeAction: this._handleExecuteAction.bind(this),\n            updateFeedbacks: this._handleUpdateFeedbacks.bind(this),\n            updateActions: this._handleUpdateActions.bind(this),\n            upgradeActionsAndFeedbacks: this._handleUpgradeActionsAndFeedbacks.bind(this),\n            getConfigFields: this._handleGetConfigFields.bind(this),\n            handleHttpRequest: this._handleHttpRequest.bind(this),\n            learnAction: this._handleLearnAction.bind(this),\n            learnFeedback: this._handleLearnFeedback.bind(this),\n            startStopRecordActions: this._handleStartStopRecordActions.bind(this),\n            variablesChanged: async () => undefined, // Not needed since 1.13.0\n            sharedUdpSocketMessage: this._handleSharedUdpSocketMessage.bind(this),\n            sharedUdpSocketError: this._handleSharedUdpSocketError.bind(this),\n        }, (msg) => {\n            process.send(msg);\n        }, 5000);\n        process.on('message', (msg) => {\n            this.#ipcWrapper.receivedMessage(msg);\n        });\n        const parseVariablesInStringIfNeeded = async (msg) => {\n            // Shortcut in case there is definitely nothing to parse\n            if (!msg.text.includes('$('))\n                return {\n                    text: msg.text,\n                    variableIds: undefined,\n                };\n            return this.#ipcWrapper.sendWithCb('parseVariablesInString', msg);\n        };\n        this.#actionManager = new actions_js_1.ActionManager(parseVariablesInStringIfNeeded, (msg) => this.#ipcWrapper.sendWithNoCb('setActionDefinitions', msg), (msg) => this.#ipcWrapper.sendWithNoCb('setCustomVariable', msg), this.log.bind(this));\n        this.#feedbackManager = new feedback_js_1.FeedbackManager(parseVariablesInStringIfNeeded, (msg) => this.#ipcWrapper.sendWithNoCb('updateFeedbackValues', msg), (msg) => this.#ipcWrapper.sendWithNoCb('setFeedbackDefinitions', msg), this.log.bind(this));\n        this.#upgradeScripts = internal.upgradeScripts;\n        this.id = internal.id;\n        this.#label = internal.id; // Temporary\n        this.log('debug', 'Initializing');\n    }\n    async _handleInit(msg) {\n        return this.#lifecycleQueue.add(async () => {\n            if (this.#initialized)\n                throw new Error('Already initialized');\n            this.#lastConfig = msg.config;\n            this.#lastSecrets = msg.secrets;\n            this.#label = msg.label;\n            // Create initial config object\n            if (msg.isFirstInit) {\n                const newConfig = {};\n                const newSecrets = {};\n                const fields = this.getConfigFields();\n                for (const field of fields) {\n                    if ('default' in field) {\n                        if (field.type.startsWith('secret')) {\n                            newSecrets[field.id] = field.default;\n                        }\n                        else {\n                            newConfig[field.id] = field.default;\n                        }\n                    }\n                }\n                this.#lastConfig = newConfig;\n                this.#lastSecrets = newSecrets;\n                this.saveConfig(this.#lastConfig, this.#lastSecrets);\n                // this is new, so there is no point attempting to run any upgrade scripts\n                msg.lastUpgradeIndex = this.#upgradeScripts.length - 1;\n            }\n            /**\n             * Making this handle actions/feedbacks is hard now due to the structure of options, so instead we just upgrade the config, and the actions/feedbacks will be handled in their own calls soon after this\n             */\n            const { updatedConfig, updatedSecrets } = (0, upgrade_js_1.runThroughUpgradeScripts)([], [], msg.lastUpgradeIndex, this.#upgradeScripts, this.#lastConfig, this.#lastSecrets, false);\n            this.#lastConfig = updatedConfig ?? this.#lastConfig;\n            this.#lastSecrets = updatedSecrets ?? this.#lastSecrets;\n            // Now we can initialise the module\n            try {\n                await this.init(this.#lastConfig, !!msg.isFirstInit, this.#lastSecrets);\n                this.#initialized = true;\n            }\n            catch (e) {\n                console.trace(`Init failed: ${e}`);\n                throw e;\n            }\n            return {\n                hasHttpHandler: typeof this.handleHttpRequest === 'function',\n                hasRecordActionsHandler: typeof this.handleStartStopRecordActions == 'function',\n                newUpgradeIndex: this.#upgradeScripts.length - 1,\n                updatedConfig: this.#lastConfig,\n                updatedSecrets: this.#lastSecrets,\n            };\n        });\n    }\n    async _handleDestroy() {\n        await this.#lifecycleQueue.add(async () => {\n            if (!this.#initialized)\n                throw new Error('Not initialized');\n            await this.destroy();\n            this.#initialized = false;\n        });\n    }\n    async _handleConfigUpdateAndLabel(msg) {\n        await this.#lifecycleQueue.add(async () => {\n            if (!this.#initialized)\n                throw new Error('Not initialized');\n            this.#label = msg.label;\n            this.#lastConfig = msg.config;\n            await this.configUpdated(this.#lastConfig, this.#lastSecrets);\n        });\n    }\n    async _handleExecuteAction(msg) {\n        return this.#actionManager.handleExecuteAction(msg);\n    }\n    async _handleUpdateFeedbacks(msg) {\n        this.#feedbackManager.handleUpdateFeedbacks(msg.feedbacks);\n    }\n    async _handleUpdateActions(msg) {\n        this.#actionManager.handleUpdateActions(msg.actions);\n    }\n    async _handleUpgradeActionsAndFeedbacks(msg) {\n        return (0, upgrade_js_1.runThroughUpgradeScripts)(msg.actions, msg.feedbacks, null, this.#upgradeScripts, this.#lastConfig, this.#lastSecrets, true);\n    }\n    async _handleGetConfigFields(_msg) {\n        return {\n            fields: (0, base_js_1.serializeIsVisibleFn)(this.getConfigFields()),\n        };\n    }\n    async _handleHttpRequest(msg) {\n        if (!this.handleHttpRequest)\n            throw new Error(`handleHttpRequest is not supported!`);\n        const res = await this.handleHttpRequest(msg.request);\n        return { response: res };\n    }\n    async _handleLearnAction(msg) {\n        return this.#actionManager.handleLearnAction(msg);\n    }\n    async _handleLearnFeedback(msg) {\n        return this.#feedbackManager.handleLearnFeedback(msg);\n    }\n    async _handleStartStopRecordActions(msg) {\n        if (!msg.recording) {\n            if (!this.#recordingActions) {\n                // Already stopped\n                return;\n            }\n        }\n        else {\n            if (this.#recordingActions) {\n                // Already running\n                return;\n            }\n        }\n        if (!this.handleStartStopRecordActions) {\n            this.#recordingActions = false;\n            throw new Error('Recording actions is not supported by this module!');\n        }\n        this.#recordingActions = msg.recording;\n        this.handleStartStopRecordActions(this.#recordingActions);\n    }\n    async _handleSharedUdpSocketMessage(msg) {\n        for (const socket of this.#sharedUdpSocketHandlers.values()) {\n            if (socket.handleId === msg.handleId) {\n                socket.receiveSocketMessage(msg);\n            }\n        }\n    }\n    async _handleSharedUdpSocketError(msg) {\n        for (const socket of this.#sharedUdpSocketHandlers.values()) {\n            if (socket.handleId === msg.handleId) {\n                socket.receiveSocketError(msg.error);\n            }\n        }\n    }\n    /**\n     * Save an updated configuration object\n     * Note: The whole config object and the keys of the secrets object are reported to the webui, so be careful how sensitive data is stored\n     * @param newConfig The new config object, or undefined to not update the config\n     * @param newSecrets The new secrets object, or undefined to not update the secrets\n     */\n    saveConfig(newConfig, newSecrets) {\n        if (newConfig)\n            this.#lastConfig = newConfig;\n        if (newSecrets)\n            this.#lastSecrets = newSecrets;\n        this.#ipcWrapper.sendWithNoCb('saveConfig', { config: newConfig, secrets: newSecrets });\n    }\n    /**\n     * Set the action definitions for this instance\n     * @param actions The action definitions\n     */\n    setActionDefinitions(actions) {\n        this.#actionManager.setActionDefinitions(actions);\n    }\n    /**\n     * Set the feedback definitions for this instance\n     * @param feedbacks The feedback definitions\n     */\n    setFeedbackDefinitions(feedbacks) {\n        this.#feedbackManager.setFeedbackDefinitions(feedbacks);\n    }\n    /**\n     * Set the peset definitions for this instance\n     * @param presets The preset definitions\n     */\n    setPresetDefinitions(presets) {\n        const hostPresets = [];\n        for (const [id, preset] of Object.entries(presets)) {\n            if (preset) {\n                hostPresets.push({\n                    ...preset,\n                    id,\n                });\n            }\n        }\n        this.#ipcWrapper.sendWithNoCb('setPresetDefinitions', { presets: hostPresets });\n    }\n    /**\n     * Set the variable definitions for this instance\n     * @param variables The variable definitions\n     */\n    setVariableDefinitions(variables) {\n        const hostVariables = [];\n        const hostValues = [];\n        this.#variableDefinitions.clear();\n        for (const variable of variables) {\n            hostVariables.push({\n                id: variable.variableId,\n                name: variable.name,\n            });\n            // Remember the definition locally\n            this.#variableDefinitions.set(variable.variableId, variable);\n            if (!this.#variableValues.has(variable.variableId)) {\n                // Give us a local cached value of something\n                this.#variableValues.set(variable.variableId, '');\n                hostValues.push({\n                    id: variable.variableId,\n                    value: '',\n                });\n            }\n        }\n        if (!this.#options.disableVariableValidation) {\n            const validIds = new Set(this.#variableDefinitions.keys());\n            for (const id of this.#variableValues.keys()) {\n                if (!validIds.has(id)) {\n                    // Delete any local cached value\n                    this.#variableValues.delete(id);\n                    hostValues.push({\n                        id: id,\n                        value: undefined,\n                    });\n                }\n            }\n        }\n        this.#ipcWrapper.sendWithNoCb('setVariableDefinitions', { variables: hostVariables, newValues: hostValues });\n    }\n    /**\n     * Set the values of some variables\n     * @param values The new values for the variables\n     */\n    setVariableValues(values) {\n        const hostValues = [];\n        for (const [variableId, value] of Object.entries(values)) {\n            if (this.#options.disableVariableValidation) {\n                // update the cached value\n                if (value === undefined) {\n                    this.#variableValues.delete(variableId);\n                }\n                else {\n                    this.#variableValues.set(variableId, value);\n                }\n                hostValues.push({\n                    id: variableId,\n                    value: value,\n                });\n            }\n            else if (this.#variableDefinitions.has(variableId)) {\n                // update the cached value\n                this.#variableValues.set(variableId, value ?? '');\n                hostValues.push({\n                    id: variableId,\n                    value: value ?? '',\n                });\n            }\n            else {\n                // tell companion to delete the value\n                hostValues.push({\n                    id: variableId,\n                    value: undefined,\n                });\n            }\n        }\n        this.#ipcWrapper.sendWithNoCb('setVariableValues', { newValues: hostValues });\n    }\n    /**\n     * Get the last set value of a variable from this connection\n     * @param variableId id of the variable\n     * @returns The value\n     */\n    getVariableValue(variableId) {\n        return this.#variableValues.get(variableId);\n    }\n    /**\n     * @deprecated Companion now handles this for you, for actions and feedbacks. If you need this for another purpose, let us know as we intend to remove this\n     *\n     * Parse and replace all the variables in a string\n     * Note: You must not use this for feedbacks, as your feedback will not update when the variable changes.\n     * There is an alternate version of this supplied to each of the action/feedback callbacks that tracks\n     * usages properly and will retrigger the feedback when the variables change.\n     * @param text The text to parse\n     * @returns The string with variables replaced with their values\n     */\n    async parseVariablesInString(text) {\n        const currentContext = this.#feedbackManager.parseVariablesContext;\n        if (currentContext) {\n            this.log('debug', `parseVariablesInString called while in: ${currentContext}. You should use the parseVariablesInString provided to the callback instead`);\n        }\n        // If there are no variables, just return the text\n        if (!text.includes('$('))\n            return text;\n        const res = await this.#ipcWrapper.sendWithCb('parseVariablesInString', {\n            text: text,\n            controlId: undefined,\n            actionInstanceId: undefined,\n            feedbackInstanceId: undefined,\n        });\n        return res.text;\n    }\n    /**\n     * Request all feedbacks of the specified types to be checked for changes\n     * @param feedbackTypes The feedback types to check\n     */\n    checkFeedbacks(...feedbackTypes) {\n        this.#feedbackManager.checkFeedbacks(feedbackTypes);\n    }\n    /**\n     * Request the specified feedback instances to be checked for changes\n     * @param feedbackIds The ids of the feedback instances to check\n     */\n    checkFeedbacksById(...feedbackIds) {\n        this.#feedbackManager.checkFeedbacksById(feedbackIds);\n    }\n    /**\n     * Call subscribe on all currently known placed actions.\n     * It can be useful to trigger this upon establishing a connection, to ensure all data is loaded.\n     * @param actionIds The actionIds to call subscribe for. If no values are provided, then all are called.\n     */\n    subscribeActions(...actionIds) {\n        this.#actionManager.subscribeActions(actionIds);\n    }\n    /**\n     * Call unsubscribe on all currently known placed actions.\n     * It can be useful to do some cleanup upon a connection closing.\n     * @param actionIds The actionIds to call subscribe for. If no values are provided, then all are called.\n     */\n    unsubscribeActions(...actionIds) {\n        this.#actionManager.unsubscribeActions(actionIds);\n    }\n    /**\n     * Call subscribe on all currently known placed feedbacks.\n     * It can be useful to trigger this upon establishing a connection, to ensure all data is loaded.\n     * @param feedbackIds The feedbackIds to call subscribe for. If no values are provided, then all are called.\n     */\n    subscribeFeedbacks(...feedbackIds) {\n        this.#feedbackManager.subscribeFeedbacks(feedbackIds);\n    }\n    /**\n     * Call unsubscribe on all currently known placed feedbacks.\n     * It can be useful to do some cleanup upon a connection closing.\n     * @param feedbackIds The feedbackIds to call subscribe for. If no values are provided, then all are called.\n     */\n    unsubscribeFeedbacks(...feedbackIds) {\n        this.#feedbackManager.unsubscribeFeedbacks(feedbackIds);\n    }\n    /**\n     * Add an action to the current recording session\n     * @param action The action to be added to the recording session\n     * @param uniquenessId A unique id for the action being recorded. This should be different for each action, but by passing the same as a previous call will replace the previous value.\n     */\n    recordAction(action, uniquenessId) {\n        if (!this.#recordingActions)\n            throw new Error('Not currently recording actions');\n        this.#ipcWrapper.sendWithNoCb('recordAction', {\n            uniquenessId: uniquenessId ?? null,\n            actionId: action.actionId,\n            options: action.options,\n            delay: action.delay,\n        });\n    }\n    /**\n     * Send an osc message from the system osc sender\n     * @param host destination ip address\n     * @param port destination port number\n     * @param path message path\n     * @param args mesage arguments\n     */\n    oscSend(host, port, path, args) {\n        this.#ipcWrapper.sendWithNoCb('send-osc', (0, util_js_1.literal)({\n            host,\n            port,\n            path,\n            args,\n        }));\n    }\n    /**\n     * Update the status of this connection\n     * @param status The status level\n     * @param message Additional information about the status\n     *\n     * ### Example\n     * ```js\n     * this.updateStatus(InstanceStatus.Ok)\n     * ```\n     */\n    updateStatus(status, message) {\n        this.#ipcWrapper.sendWithNoCb('set-status', (0, util_js_1.literal)({\n            status,\n            message: message ?? null,\n        }));\n    }\n    /**\n     * Write a line to the log\n     * @param level The level of the message\n     * @param message The message text to write\n     */\n    log(level, message) {\n        this.#ipcWrapper.sendWithNoCb('log-message', (0, util_js_1.literal)({\n            level,\n            message,\n        }));\n    }\n    createSharedUdpSocket(typeOrOptions, callback) {\n        const options = typeof typeOrOptions === 'string' ? { type: typeOrOptions } : typeOrOptions;\n        const socket = new shared_udp_socket_js_1.SharedUdpSocketImpl(this.#ipcWrapper, this.#sharedUdpSocketHandlers, options);\n        if (callback)\n            socket.on('message', callback);\n        return socket;\n    }\n}\nexports.InstanceBase = InstanceBase;\n//# sourceMappingURL=base.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/module-api/base.js?\n}")},"./node_modules/@companion-module/base/dist/module-api/config.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=config.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/module-api/config.js?\n}')},"./node_modules/@companion-module/base/dist/module-api/enums.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.Regex = exports.InstanceStatus = void 0;\n/**\n * All the possible status levels that an instance can use.\n * Note: When adding more, companion needs to be updated to know how they should be displayed\n */\nvar InstanceStatus;\n(function (InstanceStatus) {\n    InstanceStatus["Ok"] = "ok";\n    InstanceStatus["Connecting"] = "connecting";\n    InstanceStatus["Disconnected"] = "disconnected";\n    InstanceStatus["ConnectionFailure"] = "connection_failure";\n    InstanceStatus["BadConfig"] = "bad_config";\n    InstanceStatus["UnknownError"] = "unknown_error";\n    InstanceStatus["UnknownWarning"] = "unknown_warning";\n    InstanceStatus["AuthenticationFailure"] = "authentication_failure";\n})(InstanceStatus || (exports.InstanceStatus = InstanceStatus = {}));\n// eslint-disable-next-line @typescript-eslint/no-namespace\nvar Regex;\n(function (Regex) {\n    // TODO - are all of these needed?\n    Regex.IP = \'/^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\\\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/\';\n    Regex.HOSTNAME = \'/^(([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]*[a-zA-Z0-9])\\\\.)*([A-Za-z0-9]|[A-Za-z0-9][A-Za-z0-9-]*[A-Za-z0-9])$/\';\n    Regex.BOOLEAN = \'/^(true|false|0|1)$/i\';\n    Regex.PORT = \'/^([1-9]|[1-8][0-9]|9[0-9]|[1-8][0-9]{2}|9[0-8][0-9]|99[0-9]|[1-8][0-9]{3}|9[0-8][0-9]{2}|99[0-8][0-9]|999[0-9]|[1-5][0-9]{4}|6[0-4][0-9]{3}|65[0-4][0-9]{2}|655[0-2][0-9]|6553[0-4])$/\';\n    Regex.MAC_ADDRESS = \'/^(?:[a-fA-F0-9]{2}:){5}([a-fA-F0-9]{2})$/\';\n    Regex.PERCENT = \'/^(100|[0-9]|[0-9][0-9])$/\';\n    Regex.FLOAT = \'/^([0-9]*\\\\.)?[0-9]+$/\';\n    Regex.SIGNED_FLOAT = \'/^[+-]?([0-9]*\\\\.)?[0-9]+$/\';\n    Regex.FLOAT_OR_INT = \'/^([0-9]+)(\\\\.[0-9]+)?$/\';\n    Regex.NUMBER = \'/^\\\\d+$/\';\n    Regex.SIGNED_NUMBER = \'/^[+-]?\\\\d+$/\';\n    Regex.SOMETHING = \'/^.+$/\';\n    Regex.TIMECODE = \'/^(0*[0-9]|1[0-9]|2[0-4]):(0*[0-9]|[1-5][0-9]|60):(0*[0-9]|[1-5][0-9]|60):(0*[0-9]|[12][0-9]|30)$/\';\n})(Regex || (exports.Regex = Regex = {}));\n//# sourceMappingURL=enums.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/module-api/enums.js?\n}')},"./node_modules/@companion-module/base/dist/module-api/feedback.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=feedback.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/module-api/feedback.js?\n}')},"./node_modules/@companion-module/base/dist/module-api/http.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=http.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/module-api/http.js?\n}')},"./node_modules/@companion-module/base/dist/module-api/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst tslib_1 = __webpack_require__(/*! tslib */ "./node_modules/tslib/tslib.es6.mjs");\ntslib_1.__exportStar(__webpack_require__(/*! ./action.js */ "./node_modules/@companion-module/base/dist/module-api/action.js"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./base.js */ "./node_modules/@companion-module/base/dist/module-api/base.js"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./config.js */ "./node_modules/@companion-module/base/dist/module-api/config.js"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./enums.js */ "./node_modules/@companion-module/base/dist/module-api/enums.js"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./feedback.js */ "./node_modules/@companion-module/base/dist/module-api/feedback.js"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./http.js */ "./node_modules/@companion-module/base/dist/module-api/http.js"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./input.js */ "./node_modules/@companion-module/base/dist/module-api/input.js"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./preset.js */ "./node_modules/@companion-module/base/dist/module-api/preset.js"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./style.js */ "./node_modules/@companion-module/base/dist/module-api/style.js"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./upgrade.js */ "./node_modules/@companion-module/base/dist/module-api/upgrade.js"), exports);\ntslib_1.__exportStar(__webpack_require__(/*! ./variable.js */ "./node_modules/@companion-module/base/dist/module-api/variable.js"), exports);\n//# sourceMappingURL=index.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/module-api/index.js?\n}')},"./node_modules/@companion-module/base/dist/module-api/input.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=input.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/module-api/input.js?\n}')},"./node_modules/@companion-module/base/dist/module-api/preset.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=preset.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/module-api/preset.js?\n}')},"./node_modules/@companion-module/base/dist/module-api/shared-udp-socket.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.SharedUdpSocketImpl = void 0;\nconst tslib_1 = __webpack_require__(/*! tslib */ \"./node_modules/tslib/tslib.es6.mjs\");\nconst eventemitter3_1 = tslib_1.__importDefault(__webpack_require__(/*! eventemitter3 */ \"./node_modules/eventemitter3/index.js\"));\nconst util_js_1 = __webpack_require__(/*! ../util.js */ \"./node_modules/@companion-module/base/dist/util.js\");\nclass SharedUdpSocketImpl extends eventemitter3_1.default {\n    #ipcWrapper;\n    #moduleUdpSockets;\n    #options;\n    get handleId() {\n        return this.boundState?.handleId;\n    }\n    get portNumber() {\n        return this.boundState?.portNumber;\n    }\n    get boundState() {\n        if (this.#state && typeof this.#state === 'object') {\n            return this.#state;\n        }\n        else {\n            return undefined;\n        }\n    }\n    #state = 'pending';\n    constructor(ipcWrapper, moduleUdpSockets, options) {\n        super();\n        this.#ipcWrapper = ipcWrapper;\n        this.#moduleUdpSockets = moduleUdpSockets;\n        this.#options = { ...options };\n    }\n    bind(port, _address, callback) {\n        if (this.#state && typeof this.#state === 'object')\n            throw new Error('Socket is already bound');\n        switch (this.#state) {\n            case 'fatalError':\n                throw new Error('Socket has encountered fatal error');\n            case 'binding':\n                throw new Error('Socket is already bound');\n            case 'closed':\n                throw new Error('Socket is closing');\n            case 'pending':\n                break;\n            default:\n                (0, util_js_1.assertNever)(this.#state);\n                throw new Error('Invalid socket state');\n        }\n        this.#state = 'binding';\n        if (callback)\n            this.on('listening', callback);\n        this.#ipcWrapper\n            .sendWithCb('sharedUdpSocketJoin', {\n            family: this.#options.type,\n            portNumber: port,\n            // Future: use address?\n        })\n            .then((handleId) => {\n            this.#state = { portNumber: port, handleId };\n            this.#moduleUdpSockets.set(handleId, this);\n            this.emit('listening');\n        }, (err) => {\n            this.#state = 'closed';\n            this.emit('error', err instanceof Error ? err : new Error(err));\n        })\n            .catch(() => null); // Make sure any errors in user code don't cause a crash\n    }\n    close(callback) {\n        if (this.#state && typeof this.#state === 'object') {\n            // OK\n        }\n        else {\n            switch (this.#state) {\n                case 'fatalError':\n                    throw new Error('Socket has encountered fatal error');\n                case 'pending':\n                case 'closed':\n                case 'binding':\n                    throw new Error('Socket is not open');\n                default:\n                    (0, util_js_1.assertNever)(this.#state);\n                    throw new Error('Invalid socket state');\n            }\n        }\n        const handleId = this.#state.handleId;\n        this.#state = 'closed';\n        if (callback)\n            this.on('close', callback);\n        this.#ipcWrapper\n            .sendWithCb('sharedUdpSocketLeave', {\n            handleId: handleId,\n        })\n            .then(() => {\n            this.#moduleUdpSockets.delete(handleId);\n            this.emit('close');\n        }, (err) => {\n            this.#moduleUdpSockets.delete(handleId);\n            this.emit('error', err instanceof Error ? err : new Error(err));\n        })\n            .catch(() => null); // Make sure any errors in user code don't cause a crash\n    }\n    send(bufferOrList, offsetOrPort, lengthOrAddress, portOrCallback, address, callback) {\n        if (typeof offsetOrPort !== 'number')\n            throw new Error('Invalid arguments');\n        if (typeof lengthOrAddress === 'number') {\n            if (typeof portOrCallback !== 'number' || typeof address !== 'string')\n                throw new Error('Invalid arguments');\n            if (callback !== undefined && typeof callback !== 'function')\n                throw new Error('Invalid arguments');\n            const buffer = this.#processBuffer(bufferOrList, offsetOrPort, lengthOrAddress);\n            this.#sendInner(buffer, portOrCallback, address, callback);\n        }\n        else if (typeof lengthOrAddress === 'string') {\n            if (portOrCallback !== undefined && typeof portOrCallback !== 'function')\n                throw new Error('Invalid arguments');\n            const buffer = this.#processBuffer(bufferOrList, 0, undefined);\n            this.#sendInner(buffer, offsetOrPort, lengthOrAddress, portOrCallback);\n        }\n        else {\n            throw new Error('Invalid arguments');\n        }\n    }\n    #processBuffer(bufferOrList, offset, length) {\n        let buffer;\n        if (typeof bufferOrList === 'string') {\n            buffer = Buffer.from(bufferOrList, 'utf-8');\n        }\n        else if (Buffer.isBuffer(bufferOrList)) {\n            buffer = bufferOrList;\n        }\n        else if (Array.isArray(bufferOrList)) {\n            // Don't apply length checks\n            return Buffer.from(bufferOrList);\n        }\n        else {\n            buffer = Buffer.from(bufferOrList.buffer, bufferOrList.byteOffset, bufferOrList.byteLength);\n        }\n        return buffer.subarray(offset, length !== undefined ? length + offset : undefined);\n    }\n    #sendInner(buffer, port, address, callback) {\n        if (!this.#state || typeof this.#state !== 'object')\n            throw new Error('Socket is not open');\n        this.#ipcWrapper\n            .sendWithCb('sharedUdpSocketSend', {\n            handleId: this.#state.handleId,\n            message: buffer,\n            address: address,\n            port: port,\n        })\n            .then(() => {\n            callback?.();\n        }, (err) => {\n            this.emit('error', err instanceof Error ? err : new Error(err));\n        })\n            .catch(() => null); // Make sure any errors in user code don't cause a crash\n    }\n    receiveSocketMessage(message) {\n        try {\n            this.emit('message', message.message, message.source);\n        }\n        catch (_e) {\n            // Ignore\n        }\n    }\n    receiveSocketError(error) {\n        this.#state = 'fatalError';\n        const boundState = this.boundState;\n        if (boundState)\n            this.#moduleUdpSockets.delete(boundState.handleId);\n        try {\n            this.emit('error', error);\n        }\n        catch (_e) {\n            // Ignore\n        }\n    }\n}\nexports.SharedUdpSocketImpl = SharedUdpSocketImpl;\n//# sourceMappingURL=shared-udp-socket.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/module-api/shared-udp-socket.js?\n}")},"./node_modules/@companion-module/base/dist/module-api/style.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=style.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/module-api/style.js?\n}')},"./node_modules/@companion-module/base/dist/module-api/upgrade.js":(__unused_webpack_module,exports)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.EmptyUpgradeScript = void 0;\nexports.CreateConvertToBooleanFeedbackUpgradeScript = CreateConvertToBooleanFeedbackUpgradeScript;\nexports.CreateUseBuiltinInvertForFeedbacksUpgradeScript = CreateUseBuiltinInvertForFeedbacksUpgradeScript;\n/**\n * A helper upgrade script, which does nothing.\n * Useful to replace a script which is no longer needed\n */\nconst EmptyUpgradeScript = () => ({\n    updatedConfig: null,\n    updatedSecrets: null,\n    updatedActions: [],\n    updatedFeedbacks: [],\n});\nexports.EmptyUpgradeScript = EmptyUpgradeScript;\n/**\n * A helper script to automate the bulk of the process to upgrade feedbacks from 'advanced' to 'boolean'.\n * There are some built-in rules for properties names based on the most common cases.\n * @param upgradeMap The feedbacks to upgrade and the properties to convert\n */\nfunction CreateConvertToBooleanFeedbackUpgradeScript(upgradeMap) {\n    // Warning: the unused parameters will often be null\n    return (_context, props) => {\n        const changedFeedbacks = [];\n        for (const feedback of props.feedbacks) {\n            let upgrade_rules = upgradeMap[feedback.feedbackId];\n            if (upgrade_rules === true) {\n                // These are some automated built in rules. They can help make it easier to migrate\n                upgrade_rules = {\n                    bg: 'bgcolor',\n                    bgcolor: 'bgcolor',\n                    fg: 'color',\n                    color: 'color',\n                    png64: 'png64',\n                    png: 'png64',\n                };\n            }\n            if (upgrade_rules) {\n                if (!feedback.style)\n                    feedback.style = {};\n                for (const [option_key, style_key] of Object.entries(upgrade_rules)) {\n                    if (feedback.options[option_key] !== undefined) {\n                        feedback.style[style_key] = feedback.options[option_key];\n                        delete feedback.options[option_key];\n                        changedFeedbacks.push(feedback);\n                    }\n                }\n            }\n        }\n        return {\n            updatedConfig: null,\n            updatedSecrets: null,\n            updatedActions: [],\n            updatedFeedbacks: changedFeedbacks,\n        };\n    };\n}\n/**\n * A helper script to automate the bulk of the process to upgrade feedbacks from having a module defined 'invert' field, to use the builtin one.\n * The feedback definitions must be updated manually, this can only help update existing usages of the feedback.\n * @param upgradeMap The feedbacks to upgrade and the id of the option to convert\n */\nfunction CreateUseBuiltinInvertForFeedbacksUpgradeScript(upgradeMap) {\n    // Warning: the unused parameters will often be null\n    return (_context, props) => {\n        const changedFeedbacks = [];\n        for (const feedback of props.feedbacks) {\n            const propertyName = upgradeMap[feedback.feedbackId];\n            if (typeof propertyName !== 'string')\n                continue;\n            // Retrieve and delete the old value\n            const rawValue = feedback.options[propertyName];\n            if (rawValue === undefined)\n                continue;\n            delete feedback.options[propertyName];\n            // Interpret it to a boolean, it could be stored in a few ways\n            feedback.isInverted = rawValue === 'true' || Boolean(rawValue) === true || Number(rawValue) > 0;\n            // if (!rawValue.isExpression) {\n            // feedback.isInverted = rawValue.value === 'true' || Boolean(rawValue.value) === true || Number(rawValue.value) > 0\n            // } else {\n            // \t// We can't fix this case for them\n            // \tfeedback.isInverted = false\n            // }\n            changedFeedbacks.push(feedback);\n        }\n        return {\n            updatedConfig: null,\n            updatedSecrets: null,\n            updatedActions: [],\n            updatedFeedbacks: changedFeedbacks,\n        };\n    };\n}\n//# sourceMappingURL=upgrade.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/module-api/upgrade.js?\n}")},"./node_modules/@companion-module/base/dist/module-api/variable.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n//# sourceMappingURL=variable.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/module-api/variable.js?\n}')},"./node_modules/@companion-module/base/dist/util.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.literal = literal;\nexports.assertNever = assertNever;\nexports.combineRgb = combineRgb;\nexports.splitRgb = splitRgb;\nexports.splitHsl = splitHsl;\nexports.splitHsv = splitHsv;\nexports.splitHex = splitHex;\nexports.parseEscapeCharacters = parseEscapeCharacters;\nexports.substituteEscapeCharacters = substituteEscapeCharacters;\nconst colord_1 = __webpack_require__(/*! colord */ \"./node_modules/colord/index.js\");\n/**\n * Assert a certain type for a literal.\n * This can be used to correctly type parts of an object in TypeScript.\n *\n * ### Example\n *  ```ts\n * {\n *  [ActionId.MyAction]: literal<CompanionActionDefinition>({\n *   name: 'My Action',\n *   // ...\n *  })\n * }\n * ```\n *\n * instead of this\n * ```ts\n * {\n *  [ActionId.MyAction]: {\n *   name: 'My Action',\n *   // ...\n *  }\n * }\n * ```\n */\nfunction literal(v) {\n    return v;\n}\n/** Type assert that a value is never */\nfunction assertNever(_val) {\n    // Nothing to do\n}\n/**\n * Combine separate RGB component to one single numerical value.\n * The RGB component have to be in a range of 0-255.\n * There can also be an alpha component in a range of 0.0-1.0 (0 = transparent).\n *\n * **Note:** Companion's components can use any CSS color string and you should prefer these strings. E.g.for a button style you can also use `'#ff8800'` or `'rgb(255, 128, 0)'` without calling a function.\n *\n * ### Example\n *\n * ```js\n * defaultStyle: {\n *  bgcolor: combineRgb(255, 0, 0),\n *  color: combineRgb(255, 255, 255),\n * }\n * ```\n */\nfunction combineRgb(r, g, b, a) {\n    let colorNumber = ((r & 0xff) << 16) | ((g & 0xff) << 8) | (b & 0xff);\n    if (a && a >= 0 && a < 1) {\n        colorNumber += 0x1000000 * Math.round(255 * (1 - a)); // add possible transparency to number\n    }\n    return colorNumber;\n}\n/**\n * Split a combined color value to separate RGBA component values\n * the color can be either the Companion color number or a CSS compatible color string\n * return object will always include an alpha value (0.0-1.0), defaulting to 1 if input has no alpha information\n */\nfunction splitRgb(color) {\n    if (typeof color === 'number') {\n        if (color > 0xffffff) {\n            return {\n                r: (color >> 16) & 0xff,\n                g: (color >> 8) & 0xff,\n                b: color & 0xff,\n                a: (255 - ((color >> 24) & 0xff)) / 255,\n            };\n        }\n        else {\n            return {\n                r: (color >> 16) & 0xff,\n                g: (color >> 8) & 0xff,\n                b: color & 0xff,\n                a: 1,\n            };\n        }\n    }\n    else if (typeof color === 'string' && (0, colord_1.colord)(color).isValid()) {\n        const rgb = (0, colord_1.colord)(color).toRgb();\n        return {\n            r: rgb.r,\n            g: rgb.g,\n            b: rgb.b,\n            a: rgb.a,\n        };\n    }\n    else {\n        return {\n            r: 0,\n            g: 0,\n            b: 0,\n            a: 1,\n        };\n    }\n}\n/**\n * Split a combined color value to separate HSLA component values\n * the color can be either the Companion color number or a CSS compatible color string\n * return object will always include an alpha value (0.0-1.0), defaulting to 1 if input has no alpha information\n */\nfunction splitHsl(color) {\n    const rgb = splitRgb(color);\n    const hsl = (0, colord_1.colord)(`rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${rgb.a})`).toHsl();\n    return hsl;\n}\n/**\n * Split a combined color value to separate HSVA component values\n * the color can be either the Companion color number or a CSS compatible color string\n * return object will always include an alpha value (0.0-1.0), defaulting to 1 if input has no alpha information\n */\nfunction splitHsv(color) {\n    const rgb = splitRgb(color);\n    const hsv = (0, colord_1.colord)(`rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${rgb.a})`).toHsv();\n    return hsv;\n}\n/**\n * Takes a color value and returns a string with Hex notation of that color\n * the color can be either the Companion color number or a CSS compatible color string\n * if input color has no alpha or alpha of 1, return will be in format '#rrggbb', else '#rrggbbaa'\n */\nfunction splitHex(color) {\n    const rgb = splitRgb(color);\n    const hex = (0, colord_1.colord)(`rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${rgb.a})`).toHex();\n    return hex;\n}\n/**\n * Parse common escape characters in strings passed to callback from action or feedback options.\n * This is useful to ensure \\r, \\n etc are represented as such rather than as \\\\r, \\\\n\n */\nfunction parseEscapeCharacters(msg) {\n    const message = msg\n        .replaceAll('\\\\n', '\\n')\n        .replaceAll('\\\\r', '\\r')\n        .replaceAll('\\\\t', '\\t')\n        .replaceAll('\\\\f', '\\f')\n        .replaceAll('\\\\v', '\\v')\n        .replaceAll('\\\\b', '\\b')\n        .replaceAll('\\\\\\\\', '\\\\')\n        .replaceAll('\\\\x00', '\\x00')\n        .replaceAll('\\\\x01', '\\x01')\n        .replaceAll('\\\\x02', '\\x02')\n        .replaceAll('\\\\x03', '\\x03');\n    return message;\n}\n/**\n * The reverse of parseEscapeCharacters. This is useful to to ensure special charaters are displayed normally when returned to the UI.\n * Ie during a learn callback, or as a variable\n */\nfunction substituteEscapeCharacters(msg) {\n    const message = msg\n        .replaceAll('\\n', '\\\\n')\n        .replaceAll('\\r', '\\\\r')\n        .replaceAll('\\t', '\\\\t')\n        .replaceAll('\\f', '\\\\f')\n        .replaceAll('\\v', '\\\\v')\n        .replaceAll('\\b', '\\\\b')\n        .replaceAll('\\\\', '\\\\\\\\')\n        .replaceAll('\\x00', '\\\\x00')\n        .replaceAll('\\x01', '\\\\x01')\n        .replaceAll('\\x02', '\\\\x02')\n        .replaceAll('\\x03', '\\\\x03');\n    return message;\n}\n//# sourceMappingURL=util.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/dist/util.js?\n}")},"./node_modules/@companion-module/base/generated/validate_manifest.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('{module.exports = validate10;module.exports["default"] = validate10;const schema11 = {"$schema":"http://json-schema.org/draft-07/schema#","type":"object","title":"ModuleManifest","properties":{"$schema":{"type":"string"},"id":{"type":"string","description":"Unique identifier for the module"},"name":{"type":"string","description":"Name of the module"},"shortname":{"type":"string"},"description":{"type":"string","description":"Description of the module "},"version":{"type":"string","description":"Current version of the module"},"isPrerelease":{"type":"boolean","description":"Is this a pre-release version"},"license":{"type":"string","description":"SPDX identifier for license of the module"},"repository":{"type":"string","description":"URL to the source repository"},"bugs":{"type":"string","description":"URL to bug tracker"},"maintainers":{"type":"array","description":"List of active maintiners","uniqueItems":true,"items":{"type":"object","title":"ModuleManifestMaintainer","properties":{"name":{"type":"string"},"email":{"type":"string"},"github":{"type":"string"},"url":{"type":"string"}},"required":["name"],"additionalProperties":false}},"legacyIds":{"type":"array","description":"If the module had a different unique identifier previously, then specify it here","uniqueItems":true,"items":{"type":"string"}},"runtime":{"type":"object","title":"ModuleManifestRuntime","description":"Information on how to execute the module","properties":{"type":{"type":"string","description":"Type of the module. Must be: node18 or node22","enum":["node18","node22"]},"api":{"type":"string","description":"Which host-api does it use. In the future alternate options will be allowed","enum":["nodejs-ipc"]},"apiVersion":{"type":"string","description":"The version of the host-api used"},"entrypoint":{"type":"string","description":"Entrypoint to pass to the runtime. eg index.js"},"permissions":{"type":"object","description":"Permissions required by the module. This is used to inform the user of the permissions required by the module.\\nNote: this requires the node22 or newer runtime","properties":{"worker-threads":{"type":"boolean","description":"Enable if the module uses worker threads"},"child-process":{"type":"boolean","description":"Enable if the module uses child processes"},"native-addons":{"type":"boolean","description":"Enable if the module uses native addons"},"filesystem":{"type":"boolean","description":"Enable if the module requires read/write access to the filesystem"}},"additionalProperties":false}},"required":["type","api","apiVersion","entrypoint"]},"manufacturer":{"type":"string"},"products":{"type":"array","uniqueItems":true,"items":{"type":"string"},"minItems":1},"keywords":{"type":"array","uniqueItems":true,"items":{"type":"string"}},"bonjourQueries":{"type":"object","description":"If the device or software for your module supports bonjour announcements, Companion will offer an easy way to watch for these announcements.\\nEach query you define must have a matching config field of type \'bonjour-device\' with the same name","patternProperties":{"":{"oneOf":[{"$ref":"#/definitions/bonjourQuery"},{"type":"array","items":{"$ref":"#/definitions/bonjourQuery"}}]}}}},"required":["id","name","shortname","description","version","license","repository","bugs","maintainers","legacyIds","runtime","manufacturer","products","keywords"],"definitions":{"bonjourQuery":{"type":"object","title":"ModuleBonjourQuery","description":"","properties":{"type":{"type":"string"},"protocol":{"type":"string","enum":["tcp","udp"]},"port":{"type":"number"},"txt":{"type":"object","description":"Match on any txt values returned in the query. This is useful to filter out devices of the same \'type\' that are not supported","patternProperties":{"":{"type":"string"}}}},"required":["type","protocol"]}}};const schema12 = {"type":"object","title":"ModuleBonjourQuery","description":"","properties":{"type":{"type":"string"},"protocol":{"type":"string","enum":["tcp","udp"]},"port":{"type":"number"},"txt":{"type":"object","description":"Match on any txt values returned in the query. This is useful to filter out devices of the same \'type\' that are not supported","patternProperties":{"":{"type":"string"}}}},"required":["type","protocol"]};const func0 = (__webpack_require__(/*! ajv/dist/runtime/equal */ "./node_modules/ajv/dist/runtime/equal.js")["default"]);const pattern0 = new RegExp("", "u");function validate10(data, {instancePath="", parentData, parentDataProperty, rootData=data}={}){let vErrors = null;let errors = 0;if(errors === 0){if(data && typeof data == "object" && !Array.isArray(data)){let missing0;if(((((((((((((((data.id === undefined) && (missing0 = "id")) || ((data.name === undefined) && (missing0 = "name"))) || ((data.shortname === undefined) && (missing0 = "shortname"))) || ((data.description === undefined) && (missing0 = "description"))) || ((data.version === undefined) && (missing0 = "version"))) || ((data.license === undefined) && (missing0 = "license"))) || ((data.repository === undefined) && (missing0 = "repository"))) || ((data.bugs === undefined) && (missing0 = "bugs"))) || ((data.maintainers === undefined) && (missing0 = "maintainers"))) || ((data.legacyIds === undefined) && (missing0 = "legacyIds"))) || ((data.runtime === undefined) && (missing0 = "runtime"))) || ((data.manufacturer === undefined) && (missing0 = "manufacturer"))) || ((data.products === undefined) && (missing0 = "products"))) || ((data.keywords === undefined) && (missing0 = "keywords"))){validate10.errors = [{instancePath,schemaPath:"#/required",keyword:"required",params:{missingProperty: missing0},message:"must have required property \'"+missing0+"\'"}];return false;}else {if(data.$schema !== undefined){const _errs1 = errors;if(typeof data.$schema !== "string"){validate10.errors = [{instancePath:instancePath+"/$schema",schemaPath:"#/properties/%24schema/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs1 === errors;}else {var valid0 = true;}if(valid0){if(data.id !== undefined){const _errs3 = errors;if(typeof data.id !== "string"){validate10.errors = [{instancePath:instancePath+"/id",schemaPath:"#/properties/id/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs3 === errors;}else {var valid0 = true;}if(valid0){if(data.name !== undefined){const _errs5 = errors;if(typeof data.name !== "string"){validate10.errors = [{instancePath:instancePath+"/name",schemaPath:"#/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs5 === errors;}else {var valid0 = true;}if(valid0){if(data.shortname !== undefined){const _errs7 = errors;if(typeof data.shortname !== "string"){validate10.errors = [{instancePath:instancePath+"/shortname",schemaPath:"#/properties/shortname/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs7 === errors;}else {var valid0 = true;}if(valid0){if(data.description !== undefined){const _errs9 = errors;if(typeof data.description !== "string"){validate10.errors = [{instancePath:instancePath+"/description",schemaPath:"#/properties/description/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs9 === errors;}else {var valid0 = true;}if(valid0){if(data.version !== undefined){const _errs11 = errors;if(typeof data.version !== "string"){validate10.errors = [{instancePath:instancePath+"/version",schemaPath:"#/properties/version/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs11 === errors;}else {var valid0 = true;}if(valid0){if(data.isPrerelease !== undefined){const _errs13 = errors;if(typeof data.isPrerelease !== "boolean"){validate10.errors = [{instancePath:instancePath+"/isPrerelease",schemaPath:"#/properties/isPrerelease/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];return false;}var valid0 = _errs13 === errors;}else {var valid0 = true;}if(valid0){if(data.license !== undefined){const _errs15 = errors;if(typeof data.license !== "string"){validate10.errors = [{instancePath:instancePath+"/license",schemaPath:"#/properties/license/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs15 === errors;}else {var valid0 = true;}if(valid0){if(data.repository !== undefined){const _errs17 = errors;if(typeof data.repository !== "string"){validate10.errors = [{instancePath:instancePath+"/repository",schemaPath:"#/properties/repository/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs17 === errors;}else {var valid0 = true;}if(valid0){if(data.bugs !== undefined){const _errs19 = errors;if(typeof data.bugs !== "string"){validate10.errors = [{instancePath:instancePath+"/bugs",schemaPath:"#/properties/bugs/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs19 === errors;}else {var valid0 = true;}if(valid0){if(data.maintainers !== undefined){let data10 = data.maintainers;const _errs21 = errors;if(errors === _errs21){if(Array.isArray(data10)){var valid1 = true;const len0 = data10.length;for(let i0=0; i0<len0; i0++){let data11 = data10[i0];const _errs23 = errors;if(errors === _errs23){if(data11 && typeof data11 == "object" && !Array.isArray(data11)){let missing1;if((data11.name === undefined) && (missing1 = "name")){validate10.errors = [{instancePath:instancePath+"/maintainers/" + i0,schemaPath:"#/properties/maintainers/items/required",keyword:"required",params:{missingProperty: missing1},message:"must have required property \'"+missing1+"\'"}];return false;}else {const _errs25 = errors;for(const key0 in data11){if(!((((key0 === "name") || (key0 === "email")) || (key0 === "github")) || (key0 === "url"))){validate10.errors = [{instancePath:instancePath+"/maintainers/" + i0,schemaPath:"#/properties/maintainers/items/additionalProperties",keyword:"additionalProperties",params:{additionalProperty: key0},message:"must NOT have additional properties"}];return false;// removed by dead control flow\n}}if(_errs25 === errors){if(data11.name !== undefined){const _errs26 = errors;if(typeof data11.name !== "string"){validate10.errors = [{instancePath:instancePath+"/maintainers/" + i0+"/name",schemaPath:"#/properties/maintainers/items/properties/name/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid2 = _errs26 === errors;}else {var valid2 = true;}if(valid2){if(data11.email !== undefined){const _errs28 = errors;if(typeof data11.email !== "string"){validate10.errors = [{instancePath:instancePath+"/maintainers/" + i0+"/email",schemaPath:"#/properties/maintainers/items/properties/email/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid2 = _errs28 === errors;}else {var valid2 = true;}if(valid2){if(data11.github !== undefined){const _errs30 = errors;if(typeof data11.github !== "string"){validate10.errors = [{instancePath:instancePath+"/maintainers/" + i0+"/github",schemaPath:"#/properties/maintainers/items/properties/github/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid2 = _errs30 === errors;}else {var valid2 = true;}if(valid2){if(data11.url !== undefined){const _errs32 = errors;if(typeof data11.url !== "string"){validate10.errors = [{instancePath:instancePath+"/maintainers/" + i0+"/url",schemaPath:"#/properties/maintainers/items/properties/url/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid2 = _errs32 === errors;}else {var valid2 = true;}}}}}}}else {validate10.errors = [{instancePath:instancePath+"/maintainers/" + i0,schemaPath:"#/properties/maintainers/items/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}var valid1 = _errs23 === errors;if(!valid1){break;}}if(valid1){let i1 = data10.length;let j0;if(i1 > 1){outer0:for(;i1--;){for(j0 = i1; j0--;){if(func0(data10[i1], data10[j0])){validate10.errors = [{instancePath:instancePath+"/maintainers",schemaPath:"#/properties/maintainers/uniqueItems",keyword:"uniqueItems",params:{i: i1, j: j0},message:"must NOT have duplicate items (items ## "+j0+" and "+i1+" are identical)"}];return false;// removed by dead control flow\n}}}}}}else {validate10.errors = [{instancePath:instancePath+"/maintainers",schemaPath:"#/properties/maintainers/type",keyword:"type",params:{type: "array"},message:"must be array"}];return false;}}var valid0 = _errs21 === errors;}else {var valid0 = true;}if(valid0){if(data.legacyIds !== undefined){let data16 = data.legacyIds;const _errs34 = errors;if(errors === _errs34){if(Array.isArray(data16)){var valid4 = true;const len1 = data16.length;for(let i2=0; i2<len1; i2++){const _errs36 = errors;if(typeof data16[i2] !== "string"){validate10.errors = [{instancePath:instancePath+"/legacyIds/" + i2,schemaPath:"#/properties/legacyIds/items/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid4 = _errs36 === errors;if(!valid4){break;}}if(valid4){let i3 = data16.length;let j1;if(i3 > 1){const indices0 = {};for(;i3--;){let item0 = data16[i3];if(typeof item0 !== "string"){continue;}if(typeof indices0[item0] == "number"){j1 = indices0[item0];validate10.errors = [{instancePath:instancePath+"/legacyIds",schemaPath:"#/properties/legacyIds/uniqueItems",keyword:"uniqueItems",params:{i: i3, j: j1},message:"must NOT have duplicate items (items ## "+j1+" and "+i3+" are identical)"}];return false;// removed by dead control flow\n}indices0[item0] = i3;}}}}else {validate10.errors = [{instancePath:instancePath+"/legacyIds",schemaPath:"#/properties/legacyIds/type",keyword:"type",params:{type: "array"},message:"must be array"}];return false;}}var valid0 = _errs34 === errors;}else {var valid0 = true;}if(valid0){if(data.runtime !== undefined){let data18 = data.runtime;const _errs38 = errors;if(errors === _errs38){if(data18 && typeof data18 == "object" && !Array.isArray(data18)){let missing2;if(((((data18.type === undefined) && (missing2 = "type")) || ((data18.api === undefined) && (missing2 = "api"))) || ((data18.apiVersion === undefined) && (missing2 = "apiVersion"))) || ((data18.entrypoint === undefined) && (missing2 = "entrypoint"))){validate10.errors = [{instancePath:instancePath+"/runtime",schemaPath:"#/properties/runtime/required",keyword:"required",params:{missingProperty: missing2},message:"must have required property \'"+missing2+"\'"}];return false;}else {if(data18.type !== undefined){let data19 = data18.type;const _errs40 = errors;if(typeof data19 !== "string"){validate10.errors = [{instancePath:instancePath+"/runtime/type",schemaPath:"#/properties/runtime/properties/type/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}if(!((data19 === "node18") || (data19 === "node22"))){validate10.errors = [{instancePath:instancePath+"/runtime/type",schemaPath:"#/properties/runtime/properties/type/enum",keyword:"enum",params:{allowedValues: schema11.properties.runtime.properties.type.enum},message:"must be equal to one of the allowed values"}];return false;}var valid6 = _errs40 === errors;}else {var valid6 = true;}if(valid6){if(data18.api !== undefined){let data20 = data18.api;const _errs42 = errors;if(typeof data20 !== "string"){validate10.errors = [{instancePath:instancePath+"/runtime/api",schemaPath:"#/properties/runtime/properties/api/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}if(!(data20 === "nodejs-ipc")){validate10.errors = [{instancePath:instancePath+"/runtime/api",schemaPath:"#/properties/runtime/properties/api/enum",keyword:"enum",params:{allowedValues: schema11.properties.runtime.properties.api.enum},message:"must be equal to one of the allowed values"}];return false;}var valid6 = _errs42 === errors;}else {var valid6 = true;}if(valid6){if(data18.apiVersion !== undefined){const _errs44 = errors;if(typeof data18.apiVersion !== "string"){validate10.errors = [{instancePath:instancePath+"/runtime/apiVersion",schemaPath:"#/properties/runtime/properties/apiVersion/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid6 = _errs44 === errors;}else {var valid6 = true;}if(valid6){if(data18.entrypoint !== undefined){const _errs46 = errors;if(typeof data18.entrypoint !== "string"){validate10.errors = [{instancePath:instancePath+"/runtime/entrypoint",schemaPath:"#/properties/runtime/properties/entrypoint/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid6 = _errs46 === errors;}else {var valid6 = true;}if(valid6){if(data18.permissions !== undefined){let data23 = data18.permissions;const _errs48 = errors;if(errors === _errs48){if(data23 && typeof data23 == "object" && !Array.isArray(data23)){const _errs50 = errors;for(const key1 in data23){if(!((((key1 === "worker-threads") || (key1 === "child-process")) || (key1 === "native-addons")) || (key1 === "filesystem"))){validate10.errors = [{instancePath:instancePath+"/runtime/permissions",schemaPath:"#/properties/runtime/properties/permissions/additionalProperties",keyword:"additionalProperties",params:{additionalProperty: key1},message:"must NOT have additional properties"}];return false;// removed by dead control flow\n}}if(_errs50 === errors){if(data23["worker-threads"] !== undefined){const _errs51 = errors;if(typeof data23["worker-threads"] !== "boolean"){validate10.errors = [{instancePath:instancePath+"/runtime/permissions/worker-threads",schemaPath:"#/properties/runtime/properties/permissions/properties/worker-threads/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];return false;}var valid7 = _errs51 === errors;}else {var valid7 = true;}if(valid7){if(data23["child-process"] !== undefined){const _errs53 = errors;if(typeof data23["child-process"] !== "boolean"){validate10.errors = [{instancePath:instancePath+"/runtime/permissions/child-process",schemaPath:"#/properties/runtime/properties/permissions/properties/child-process/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];return false;}var valid7 = _errs53 === errors;}else {var valid7 = true;}if(valid7){if(data23["native-addons"] !== undefined){const _errs55 = errors;if(typeof data23["native-addons"] !== "boolean"){validate10.errors = [{instancePath:instancePath+"/runtime/permissions/native-addons",schemaPath:"#/properties/runtime/properties/permissions/properties/native-addons/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];return false;}var valid7 = _errs55 === errors;}else {var valid7 = true;}if(valid7){if(data23.filesystem !== undefined){const _errs57 = errors;if(typeof data23.filesystem !== "boolean"){validate10.errors = [{instancePath:instancePath+"/runtime/permissions/filesystem",schemaPath:"#/properties/runtime/properties/permissions/properties/filesystem/type",keyword:"type",params:{type: "boolean"},message:"must be boolean"}];return false;}var valid7 = _errs57 === errors;}else {var valid7 = true;}}}}}}else {validate10.errors = [{instancePath:instancePath+"/runtime/permissions",schemaPath:"#/properties/runtime/properties/permissions/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}var valid6 = _errs48 === errors;}else {var valid6 = true;}}}}}}}else {validate10.errors = [{instancePath:instancePath+"/runtime",schemaPath:"#/properties/runtime/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}var valid0 = _errs38 === errors;}else {var valid0 = true;}if(valid0){if(data.manufacturer !== undefined){const _errs59 = errors;if(typeof data.manufacturer !== "string"){validate10.errors = [{instancePath:instancePath+"/manufacturer",schemaPath:"#/properties/manufacturer/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid0 = _errs59 === errors;}else {var valid0 = true;}if(valid0){if(data.products !== undefined){let data29 = data.products;const _errs61 = errors;if(errors === _errs61){if(Array.isArray(data29)){if(data29.length < 1){validate10.errors = [{instancePath:instancePath+"/products",schemaPath:"#/properties/products/minItems",keyword:"minItems",params:{limit: 1},message:"must NOT have fewer than 1 items"}];return false;}else {var valid8 = true;const len2 = data29.length;for(let i4=0; i4<len2; i4++){const _errs63 = errors;if(typeof data29[i4] !== "string"){validate10.errors = [{instancePath:instancePath+"/products/" + i4,schemaPath:"#/properties/products/items/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid8 = _errs63 === errors;if(!valid8){break;}}if(valid8){let i5 = data29.length;let j2;if(i5 > 1){const indices1 = {};for(;i5--;){let item1 = data29[i5];if(typeof item1 !== "string"){continue;}if(typeof indices1[item1] == "number"){j2 = indices1[item1];validate10.errors = [{instancePath:instancePath+"/products",schemaPath:"#/properties/products/uniqueItems",keyword:"uniqueItems",params:{i: i5, j: j2},message:"must NOT have duplicate items (items ## "+j2+" and "+i5+" are identical)"}];return false;// removed by dead control flow\n}indices1[item1] = i5;}}}}}else {validate10.errors = [{instancePath:instancePath+"/products",schemaPath:"#/properties/products/type",keyword:"type",params:{type: "array"},message:"must be array"}];return false;}}var valid0 = _errs61 === errors;}else {var valid0 = true;}if(valid0){if(data.keywords !== undefined){let data31 = data.keywords;const _errs65 = errors;if(errors === _errs65){if(Array.isArray(data31)){var valid10 = true;const len3 = data31.length;for(let i6=0; i6<len3; i6++){const _errs67 = errors;if(typeof data31[i6] !== "string"){validate10.errors = [{instancePath:instancePath+"/keywords/" + i6,schemaPath:"#/properties/keywords/items/type",keyword:"type",params:{type: "string"},message:"must be string"}];return false;}var valid10 = _errs67 === errors;if(!valid10){break;}}if(valid10){let i7 = data31.length;let j3;if(i7 > 1){const indices2 = {};for(;i7--;){let item2 = data31[i7];if(typeof item2 !== "string"){continue;}if(typeof indices2[item2] == "number"){j3 = indices2[item2];validate10.errors = [{instancePath:instancePath+"/keywords",schemaPath:"#/properties/keywords/uniqueItems",keyword:"uniqueItems",params:{i: i7, j: j3},message:"must NOT have duplicate items (items ## "+j3+" and "+i7+" are identical)"}];return false;// removed by dead control flow\n}indices2[item2] = i7;}}}}else {validate10.errors = [{instancePath:instancePath+"/keywords",schemaPath:"#/properties/keywords/type",keyword:"type",params:{type: "array"},message:"must be array"}];return false;}}var valid0 = _errs65 === errors;}else {var valid0 = true;}if(valid0){if(data.bonjourQueries !== undefined){let data33 = data.bonjourQueries;const _errs69 = errors;if(errors === _errs69){if(data33 && typeof data33 == "object" && !Array.isArray(data33)){var valid12 = true;for(const key2 in data33){if(pattern0.test(key2)){let data34 = data33[key2];const _errs71 = errors;const _errs72 = errors;let valid13 = false;let passing0 = null;const _errs73 = errors;const _errs74 = errors;if(errors === _errs74){if(data34 && typeof data34 == "object" && !Array.isArray(data34)){let missing3;if(((data34.type === undefined) && (missing3 = "type")) || ((data34.protocol === undefined) && (missing3 = "protocol"))){const err0 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1"),schemaPath:"#/definitions/bonjourQuery/required",keyword:"required",params:{missingProperty: missing3},message:"must have required property \'"+missing3+"\'"};if(vErrors === null){vErrors = [err0];}else {vErrors.push(err0);}errors++;}else {if(data34.type !== undefined){const _errs76 = errors;if(typeof data34.type !== "string"){const err1 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1")+"/type",schemaPath:"#/definitions/bonjourQuery/properties/type/type",keyword:"type",params:{type: "string"},message:"must be string"};if(vErrors === null){vErrors = [err1];}else {vErrors.push(err1);}errors++;}var valid15 = _errs76 === errors;}else {var valid15 = true;}if(valid15){if(data34.protocol !== undefined){let data36 = data34.protocol;const _errs78 = errors;if(typeof data36 !== "string"){const err2 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1")+"/protocol",schemaPath:"#/definitions/bonjourQuery/properties/protocol/type",keyword:"type",params:{type: "string"},message:"must be string"};if(vErrors === null){vErrors = [err2];}else {vErrors.push(err2);}errors++;}if(!((data36 === "tcp") || (data36 === "udp"))){const err3 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1")+"/protocol",schemaPath:"#/definitions/bonjourQuery/properties/protocol/enum",keyword:"enum",params:{allowedValues: schema12.properties.protocol.enum},message:"must be equal to one of the allowed values"};if(vErrors === null){vErrors = [err3];}else {vErrors.push(err3);}errors++;}var valid15 = _errs78 === errors;}else {var valid15 = true;}if(valid15){if(data34.port !== undefined){let data37 = data34.port;const _errs80 = errors;if(!((typeof data37 == "number") && (isFinite(data37)))){const err4 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1")+"/port",schemaPath:"#/definitions/bonjourQuery/properties/port/type",keyword:"type",params:{type: "number"},message:"must be number"};if(vErrors === null){vErrors = [err4];}else {vErrors.push(err4);}errors++;}var valid15 = _errs80 === errors;}else {var valid15 = true;}if(valid15){if(data34.txt !== undefined){let data38 = data34.txt;const _errs82 = errors;if(errors === _errs82){if(data38 && typeof data38 == "object" && !Array.isArray(data38)){var valid16 = true;for(const key3 in data38){if(pattern0.test(key3)){const _errs84 = errors;if(typeof data38[key3] !== "string"){const err5 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1")+"/txt/" + key3.replace(/~/g, "~0").replace(/\\//g, "~1"),schemaPath:"#/definitions/bonjourQuery/properties/txt/patternProperties//type",keyword:"type",params:{type: "string"},message:"must be string"};if(vErrors === null){vErrors = [err5];}else {vErrors.push(err5);}errors++;}var valid16 = _errs84 === errors;if(!valid16){break;}}}}else {const err6 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1")+"/txt",schemaPath:"#/definitions/bonjourQuery/properties/txt/type",keyword:"type",params:{type: "object"},message:"must be object"};if(vErrors === null){vErrors = [err6];}else {vErrors.push(err6);}errors++;}}var valid15 = _errs82 === errors;}else {var valid15 = true;}}}}}}else {const err7 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1"),schemaPath:"#/definitions/bonjourQuery/type",keyword:"type",params:{type: "object"},message:"must be object"};if(vErrors === null){vErrors = [err7];}else {vErrors.push(err7);}errors++;}}var _valid0 = _errs73 === errors;if(_valid0){valid13 = true;passing0 = 0;}const _errs86 = errors;if(errors === _errs86){if(Array.isArray(data34)){var valid17 = true;const len4 = data34.length;for(let i8=0; i8<len4; i8++){let data40 = data34[i8];const _errs88 = errors;const _errs89 = errors;if(errors === _errs89){if(data40 && typeof data40 == "object" && !Array.isArray(data40)){let missing4;if(((data40.type === undefined) && (missing4 = "type")) || ((data40.protocol === undefined) && (missing4 = "protocol"))){const err8 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1")+"/" + i8,schemaPath:"#/definitions/bonjourQuery/required",keyword:"required",params:{missingProperty: missing4},message:"must have required property \'"+missing4+"\'"};if(vErrors === null){vErrors = [err8];}else {vErrors.push(err8);}errors++;}else {if(data40.type !== undefined){const _errs91 = errors;if(typeof data40.type !== "string"){const err9 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1")+"/" + i8+"/type",schemaPath:"#/definitions/bonjourQuery/properties/type/type",keyword:"type",params:{type: "string"},message:"must be string"};if(vErrors === null){vErrors = [err9];}else {vErrors.push(err9);}errors++;}var valid19 = _errs91 === errors;}else {var valid19 = true;}if(valid19){if(data40.protocol !== undefined){let data42 = data40.protocol;const _errs93 = errors;if(typeof data42 !== "string"){const err10 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1")+"/" + i8+"/protocol",schemaPath:"#/definitions/bonjourQuery/properties/protocol/type",keyword:"type",params:{type: "string"},message:"must be string"};if(vErrors === null){vErrors = [err10];}else {vErrors.push(err10);}errors++;}if(!((data42 === "tcp") || (data42 === "udp"))){const err11 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1")+"/" + i8+"/protocol",schemaPath:"#/definitions/bonjourQuery/properties/protocol/enum",keyword:"enum",params:{allowedValues: schema12.properties.protocol.enum},message:"must be equal to one of the allowed values"};if(vErrors === null){vErrors = [err11];}else {vErrors.push(err11);}errors++;}var valid19 = _errs93 === errors;}else {var valid19 = true;}if(valid19){if(data40.port !== undefined){let data43 = data40.port;const _errs95 = errors;if(!((typeof data43 == "number") && (isFinite(data43)))){const err12 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1")+"/" + i8+"/port",schemaPath:"#/definitions/bonjourQuery/properties/port/type",keyword:"type",params:{type: "number"},message:"must be number"};if(vErrors === null){vErrors = [err12];}else {vErrors.push(err12);}errors++;}var valid19 = _errs95 === errors;}else {var valid19 = true;}if(valid19){if(data40.txt !== undefined){let data44 = data40.txt;const _errs97 = errors;if(errors === _errs97){if(data44 && typeof data44 == "object" && !Array.isArray(data44)){var valid20 = true;for(const key4 in data44){if(pattern0.test(key4)){const _errs99 = errors;if(typeof data44[key4] !== "string"){const err13 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1")+"/" + i8+"/txt/" + key4.replace(/~/g, "~0").replace(/\\//g, "~1"),schemaPath:"#/definitions/bonjourQuery/properties/txt/patternProperties//type",keyword:"type",params:{type: "string"},message:"must be string"};if(vErrors === null){vErrors = [err13];}else {vErrors.push(err13);}errors++;}var valid20 = _errs99 === errors;if(!valid20){break;}}}}else {const err14 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1")+"/" + i8+"/txt",schemaPath:"#/definitions/bonjourQuery/properties/txt/type",keyword:"type",params:{type: "object"},message:"must be object"};if(vErrors === null){vErrors = [err14];}else {vErrors.push(err14);}errors++;}}var valid19 = _errs97 === errors;}else {var valid19 = true;}}}}}}else {const err15 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1")+"/" + i8,schemaPath:"#/definitions/bonjourQuery/type",keyword:"type",params:{type: "object"},message:"must be object"};if(vErrors === null){vErrors = [err15];}else {vErrors.push(err15);}errors++;}}var valid17 = _errs88 === errors;if(!valid17){break;}}}else {const err16 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1"),schemaPath:"#/properties/bonjourQueries/patternProperties//oneOf/1/type",keyword:"type",params:{type: "array"},message:"must be array"};if(vErrors === null){vErrors = [err16];}else {vErrors.push(err16);}errors++;}}var _valid0 = _errs86 === errors;if(_valid0 && valid13){valid13 = false;passing0 = [passing0, 1];}else {if(_valid0){valid13 = true;passing0 = 1;}}if(!valid13){const err17 = {instancePath:instancePath+"/bonjourQueries/" + key2.replace(/~/g, "~0").replace(/\\//g, "~1"),schemaPath:"#/properties/bonjourQueries/patternProperties//oneOf",keyword:"oneOf",params:{passingSchemas: passing0},message:"must match exactly one schema in oneOf"};if(vErrors === null){vErrors = [err17];}else {vErrors.push(err17);}errors++;validate10.errors = vErrors;return false;}else {errors = _errs72;if(vErrors !== null){if(_errs72){vErrors.length = _errs72;}else {vErrors = null;}}}var valid12 = _errs71 === errors;if(!valid12){break;}}}}else {validate10.errors = [{instancePath:instancePath+"/bonjourQueries",schemaPath:"#/properties/bonjourQueries/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}var valid0 = _errs69 === errors;}else {var valid0 = true;}}}}}}}}}}}}}}}}}}}else {validate10.errors = [{instancePath,schemaPath:"#/type",keyword:"type",params:{type: "object"},message:"must be object"}];return false;}}validate10.errors = vErrors;return errors === 0;}\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/generated/validate_manifest.js?\n}')},"./node_modules/@companion-module/base/lib/debounce-fn/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('{\n// eslint-disable-next-line @typescript-eslint/no-require-imports\nconst mimicFn = __webpack_require__(/*! mimic-fn */ "./node_modules/mimic-fn/index.js")\n\nmodule.exports = (inputFunction, options = {}) => {\n\tif (typeof inputFunction !== \'function\') {\n\t\tthrow new TypeError(`Expected the first argument to be a function, got \\`${typeof inputFunction}\\``)\n\t}\n\n\tconst { wait = 0, maxWait = 0, before = false, after = true } = options\n\n\tif (!before && !after) {\n\t\tthrow new Error("Both `before` and `after` are false, function wouldn\'t be called.")\n\t}\n\n\tlet timeout\n\tlet maxTimeout\n\tlet result\n\n\tconst debouncedFunction = function (...arguments_) {\n\t\t// eslint-disable-next-line @typescript-eslint/no-this-alias\n\t\tconst context = this\n\n\t\tconst later = () => {\n\t\t\ttimeout = undefined\n\n\t\t\tif (maxTimeout) {\n\t\t\t\tclearTimeout(maxTimeout)\n\t\t\t\tmaxTimeout = undefined\n\t\t\t}\n\n\t\t\tif (after) {\n\t\t\t\tresult = inputFunction.apply(context, arguments_)\n\t\t\t}\n\t\t}\n\n\t\tconst maxLater = () => {\n\t\t\tmaxTimeout = undefined\n\n\t\t\tif (timeout) {\n\t\t\t\tclearTimeout(timeout)\n\t\t\t\ttimeout = undefined\n\t\t\t}\n\n\t\t\tresult = inputFunction.apply(context, arguments_)\n\t\t}\n\n\t\tconst shouldCallNow = before && !timeout\n\t\tclearTimeout(timeout)\n\t\ttimeout = setTimeout(later, wait)\n\n\t\tif (maxWait > 0 && !maxTimeout && after) {\n\t\t\tmaxTimeout = setTimeout(maxLater, maxWait)\n\t\t}\n\n\t\tif (shouldCallNow) {\n\t\t\tresult = inputFunction.apply(context, arguments_)\n\t\t}\n\n\t\treturn result\n\t}\n\n\tmimicFn(debouncedFunction, inputFunction)\n\n\tdebouncedFunction.cancel = () => {\n\t\tif (timeout) {\n\t\t\tclearTimeout(timeout)\n\t\t\ttimeout = undefined\n\t\t}\n\n\t\tif (maxTimeout) {\n\t\t\tclearTimeout(maxTimeout)\n\t\t\tmaxTimeout = undefined\n\t\t}\n\t}\n\n\treturn debouncedFunction\n}\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@companion-module/base/lib/debounce-fn/index.js?\n}')},"./node_modules/@sindresorhus/is/dist/index.js":(module,exports)=>{"use strict";eval("{\n/// <reference lib=\"es2018\"/>\n/// <reference lib=\"dom\"/>\n/// <reference types=\"node\"/>\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst typedArrayTypeNames = [\n    'Int8Array',\n    'Uint8Array',\n    'Uint8ClampedArray',\n    'Int16Array',\n    'Uint16Array',\n    'Int32Array',\n    'Uint32Array',\n    'Float32Array',\n    'Float64Array',\n    'BigInt64Array',\n    'BigUint64Array'\n];\nfunction isTypedArrayName(name) {\n    return typedArrayTypeNames.includes(name);\n}\nconst objectTypeNames = [\n    'Function',\n    'Generator',\n    'AsyncGenerator',\n    'GeneratorFunction',\n    'AsyncGeneratorFunction',\n    'AsyncFunction',\n    'Observable',\n    'Array',\n    'Buffer',\n    'Blob',\n    'Object',\n    'RegExp',\n    'Date',\n    'Error',\n    'Map',\n    'Set',\n    'WeakMap',\n    'WeakSet',\n    'ArrayBuffer',\n    'SharedArrayBuffer',\n    'DataView',\n    'Promise',\n    'URL',\n    'FormData',\n    'URLSearchParams',\n    'HTMLElement',\n    ...typedArrayTypeNames\n];\nfunction isObjectTypeName(name) {\n    return objectTypeNames.includes(name);\n}\nconst primitiveTypeNames = [\n    'null',\n    'undefined',\n    'string',\n    'number',\n    'bigint',\n    'boolean',\n    'symbol'\n];\nfunction isPrimitiveTypeName(name) {\n    return primitiveTypeNames.includes(name);\n}\n// eslint-disable-next-line @typescript-eslint/ban-types\nfunction isOfType(type) {\n    return (value) => typeof value === type;\n}\nconst { toString } = Object.prototype;\nconst getObjectType = (value) => {\n    const objectTypeName = toString.call(value).slice(8, -1);\n    if (/HTML\\w+Element/.test(objectTypeName) && is.domElement(value)) {\n        return 'HTMLElement';\n    }\n    if (isObjectTypeName(objectTypeName)) {\n        return objectTypeName;\n    }\n    return undefined;\n};\nconst isObjectOfType = (type) => (value) => getObjectType(value) === type;\nfunction is(value) {\n    if (value === null) {\n        return 'null';\n    }\n    switch (typeof value) {\n        case 'undefined':\n            return 'undefined';\n        case 'string':\n            return 'string';\n        case 'number':\n            return 'number';\n        case 'boolean':\n            return 'boolean';\n        case 'function':\n            return 'Function';\n        case 'bigint':\n            return 'bigint';\n        case 'symbol':\n            return 'symbol';\n        default:\n    }\n    if (is.observable(value)) {\n        return 'Observable';\n    }\n    if (is.array(value)) {\n        return 'Array';\n    }\n    if (is.buffer(value)) {\n        return 'Buffer';\n    }\n    const tagType = getObjectType(value);\n    if (tagType) {\n        return tagType;\n    }\n    if (value instanceof String || value instanceof Boolean || value instanceof Number) {\n        throw new TypeError('Please don\\'t use object wrappers for primitive types');\n    }\n    return 'Object';\n}\nis.undefined = isOfType('undefined');\nis.string = isOfType('string');\nconst isNumberType = isOfType('number');\nis.number = (value) => isNumberType(value) && !is.nan(value);\nis.bigint = isOfType('bigint');\n// eslint-disable-next-line @typescript-eslint/ban-types\nis.function_ = isOfType('function');\nis.null_ = (value) => value === null;\nis.class_ = (value) => is.function_(value) && value.toString().startsWith('class ');\nis.boolean = (value) => value === true || value === false;\nis.symbol = isOfType('symbol');\nis.numericString = (value) => is.string(value) && !is.emptyStringOrWhitespace(value) && !Number.isNaN(Number(value));\nis.array = (value, assertion) => {\n    if (!Array.isArray(value)) {\n        return false;\n    }\n    if (!is.function_(assertion)) {\n        return true;\n    }\n    return value.every(assertion);\n};\nis.buffer = (value) => { var _a, _b, _c, _d; return (_d = (_c = (_b = (_a = value) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.isBuffer) === null || _c === void 0 ? void 0 : _c.call(_b, value)) !== null && _d !== void 0 ? _d : false; };\nis.blob = (value) => isObjectOfType('Blob')(value);\nis.nullOrUndefined = (value) => is.null_(value) || is.undefined(value);\nis.object = (value) => !is.null_(value) && (typeof value === 'object' || is.function_(value));\nis.iterable = (value) => { var _a; return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.iterator]); };\nis.asyncIterable = (value) => { var _a; return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a[Symbol.asyncIterator]); };\nis.generator = (value) => { var _a, _b; return is.iterable(value) && is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.next) && is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.throw); };\nis.asyncGenerator = (value) => is.asyncIterable(value) && is.function_(value.next) && is.function_(value.throw);\nis.nativePromise = (value) => isObjectOfType('Promise')(value);\nconst hasPromiseAPI = (value) => {\n    var _a, _b;\n    return is.function_((_a = value) === null || _a === void 0 ? void 0 : _a.then) &&\n        is.function_((_b = value) === null || _b === void 0 ? void 0 : _b.catch);\n};\nis.promise = (value) => is.nativePromise(value) || hasPromiseAPI(value);\nis.generatorFunction = isObjectOfType('GeneratorFunction');\nis.asyncGeneratorFunction = (value) => getObjectType(value) === 'AsyncGeneratorFunction';\nis.asyncFunction = (value) => getObjectType(value) === 'AsyncFunction';\n// eslint-disable-next-line no-prototype-builtins, @typescript-eslint/ban-types\nis.boundFunction = (value) => is.function_(value) && !value.hasOwnProperty('prototype');\nis.regExp = isObjectOfType('RegExp');\nis.date = isObjectOfType('Date');\nis.error = isObjectOfType('Error');\nis.map = (value) => isObjectOfType('Map')(value);\nis.set = (value) => isObjectOfType('Set')(value);\nis.weakMap = (value) => isObjectOfType('WeakMap')(value);\nis.weakSet = (value) => isObjectOfType('WeakSet')(value);\nis.int8Array = isObjectOfType('Int8Array');\nis.uint8Array = isObjectOfType('Uint8Array');\nis.uint8ClampedArray = isObjectOfType('Uint8ClampedArray');\nis.int16Array = isObjectOfType('Int16Array');\nis.uint16Array = isObjectOfType('Uint16Array');\nis.int32Array = isObjectOfType('Int32Array');\nis.uint32Array = isObjectOfType('Uint32Array');\nis.float32Array = isObjectOfType('Float32Array');\nis.float64Array = isObjectOfType('Float64Array');\nis.bigInt64Array = isObjectOfType('BigInt64Array');\nis.bigUint64Array = isObjectOfType('BigUint64Array');\nis.arrayBuffer = isObjectOfType('ArrayBuffer');\nis.sharedArrayBuffer = isObjectOfType('SharedArrayBuffer');\nis.dataView = isObjectOfType('DataView');\nis.enumCase = (value, targetEnum) => Object.values(targetEnum).includes(value);\nis.directInstanceOf = (instance, class_) => Object.getPrototypeOf(instance) === class_.prototype;\nis.urlInstance = (value) => isObjectOfType('URL')(value);\nis.urlString = (value) => {\n    if (!is.string(value)) {\n        return false;\n    }\n    try {\n        new URL(value); // eslint-disable-line no-new\n        return true;\n    }\n    catch (_a) {\n        return false;\n    }\n};\n// Example: `is.truthy = (value: unknown): value is (not false | not 0 | not '' | not undefined | not null) => Boolean(value);`\nis.truthy = (value) => Boolean(value);\n// Example: `is.falsy = (value: unknown): value is (not true | 0 | '' | undefined | null) => Boolean(value);`\nis.falsy = (value) => !value;\nis.nan = (value) => Number.isNaN(value);\nis.primitive = (value) => is.null_(value) || isPrimitiveTypeName(typeof value);\nis.integer = (value) => Number.isInteger(value);\nis.safeInteger = (value) => Number.isSafeInteger(value);\nis.plainObject = (value) => {\n    // From: https://github.com/sindresorhus/is-plain-obj/blob/main/index.js\n    if (toString.call(value) !== '[object Object]') {\n        return false;\n    }\n    const prototype = Object.getPrototypeOf(value);\n    return prototype === null || prototype === Object.getPrototypeOf({});\n};\nis.typedArray = (value) => isTypedArrayName(getObjectType(value));\nconst isValidLength = (value) => is.safeInteger(value) && value >= 0;\nis.arrayLike = (value) => !is.nullOrUndefined(value) && !is.function_(value) && isValidLength(value.length);\nis.inRange = (value, range) => {\n    if (is.number(range)) {\n        return value >= Math.min(0, range) && value <= Math.max(range, 0);\n    }\n    if (is.array(range) && range.length === 2) {\n        return value >= Math.min(...range) && value <= Math.max(...range);\n    }\n    throw new TypeError(`Invalid range: ${JSON.stringify(range)}`);\n};\nconst NODE_TYPE_ELEMENT = 1;\nconst DOM_PROPERTIES_TO_CHECK = [\n    'innerHTML',\n    'ownerDocument',\n    'style',\n    'attributes',\n    'nodeValue'\n];\nis.domElement = (value) => {\n    return is.object(value) &&\n        value.nodeType === NODE_TYPE_ELEMENT &&\n        is.string(value.nodeName) &&\n        !is.plainObject(value) &&\n        DOM_PROPERTIES_TO_CHECK.every(property => property in value);\n};\nis.observable = (value) => {\n    var _a, _b, _c, _d;\n    if (!value) {\n        return false;\n    }\n    // eslint-disable-next-line no-use-extend-native/no-use-extend-native\n    if (value === ((_b = (_a = value)[Symbol.observable]) === null || _b === void 0 ? void 0 : _b.call(_a))) {\n        return true;\n    }\n    if (value === ((_d = (_c = value)['@@observable']) === null || _d === void 0 ? void 0 : _d.call(_c))) {\n        return true;\n    }\n    return false;\n};\nis.nodeStream = (value) => is.object(value) && is.function_(value.pipe) && !is.observable(value);\nis.infinite = (value) => value === Infinity || value === -Infinity;\nconst isAbsoluteMod2 = (remainder) => (value) => is.integer(value) && Math.abs(value % 2) === remainder;\nis.evenInteger = isAbsoluteMod2(0);\nis.oddInteger = isAbsoluteMod2(1);\nis.emptyArray = (value) => is.array(value) && value.length === 0;\nis.nonEmptyArray = (value) => is.array(value) && value.length > 0;\nis.emptyString = (value) => is.string(value) && value.length === 0;\nconst isWhiteSpaceString = (value) => is.string(value) && !/\\S/.test(value);\nis.emptyStringOrWhitespace = (value) => is.emptyString(value) || isWhiteSpaceString(value);\n// TODO: Use `not ''` when the `not` operator is available.\nis.nonEmptyString = (value) => is.string(value) && value.length > 0;\n// TODO: Use `not ''` when the `not` operator is available.\nis.nonEmptyStringAndNotWhitespace = (value) => is.string(value) && !is.emptyStringOrWhitespace(value);\nis.emptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length === 0;\n// TODO: Use `not` operator here to remove `Map` and `Set` from type guard:\n// - https://github.com/Microsoft/TypeScript/pull/29317\nis.nonEmptyObject = (value) => is.object(value) && !is.map(value) && !is.set(value) && Object.keys(value).length > 0;\nis.emptySet = (value) => is.set(value) && value.size === 0;\nis.nonEmptySet = (value) => is.set(value) && value.size > 0;\nis.emptyMap = (value) => is.map(value) && value.size === 0;\nis.nonEmptyMap = (value) => is.map(value) && value.size > 0;\n// `PropertyKey` is any value that can be used as an object key (string, number, or symbol)\nis.propertyKey = (value) => is.any([is.string, is.number, is.symbol], value);\nis.formData = (value) => isObjectOfType('FormData')(value);\nis.urlSearchParams = (value) => isObjectOfType('URLSearchParams')(value);\nconst predicateOnArray = (method, predicate, values) => {\n    if (!is.function_(predicate)) {\n        throw new TypeError(`Invalid predicate: ${JSON.stringify(predicate)}`);\n    }\n    if (values.length === 0) {\n        throw new TypeError('Invalid number of values');\n    }\n    return method.call(values, predicate);\n};\nis.any = (predicate, ...values) => {\n    const predicates = is.array(predicate) ? predicate : [predicate];\n    return predicates.some(singlePredicate => predicateOnArray(Array.prototype.some, singlePredicate, values));\n};\nis.all = (predicate, ...values) => predicateOnArray(Array.prototype.every, predicate, values);\nconst assertType = (condition, description, value, options = {}) => {\n    if (!condition) {\n        const { multipleValues } = options;\n        const valuesMessage = multipleValues ?\n            `received values of types ${[\n                ...new Set(value.map(singleValue => `\\`${is(singleValue)}\\``))\n            ].join(', ')}` :\n            `received value of type \\`${is(value)}\\``;\n        throw new TypeError(`Expected value which is \\`${description}\\`, ${valuesMessage}.`);\n    }\n};\nexports.assert = {\n    // Unknowns.\n    undefined: (value) => assertType(is.undefined(value), 'undefined', value),\n    string: (value) => assertType(is.string(value), 'string', value),\n    number: (value) => assertType(is.number(value), 'number', value),\n    bigint: (value) => assertType(is.bigint(value), 'bigint', value),\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    function_: (value) => assertType(is.function_(value), 'Function', value),\n    null_: (value) => assertType(is.null_(value), 'null', value),\n    class_: (value) => assertType(is.class_(value), \"Class\" /* class_ */, value),\n    boolean: (value) => assertType(is.boolean(value), 'boolean', value),\n    symbol: (value) => assertType(is.symbol(value), 'symbol', value),\n    numericString: (value) => assertType(is.numericString(value), \"string with a number\" /* numericString */, value),\n    array: (value, assertion) => {\n        const assert = assertType;\n        assert(is.array(value), 'Array', value);\n        if (assertion) {\n            value.forEach(assertion);\n        }\n    },\n    buffer: (value) => assertType(is.buffer(value), 'Buffer', value),\n    blob: (value) => assertType(is.blob(value), 'Blob', value),\n    nullOrUndefined: (value) => assertType(is.nullOrUndefined(value), \"null or undefined\" /* nullOrUndefined */, value),\n    object: (value) => assertType(is.object(value), 'Object', value),\n    iterable: (value) => assertType(is.iterable(value), \"Iterable\" /* iterable */, value),\n    asyncIterable: (value) => assertType(is.asyncIterable(value), \"AsyncIterable\" /* asyncIterable */, value),\n    generator: (value) => assertType(is.generator(value), 'Generator', value),\n    asyncGenerator: (value) => assertType(is.asyncGenerator(value), 'AsyncGenerator', value),\n    nativePromise: (value) => assertType(is.nativePromise(value), \"native Promise\" /* nativePromise */, value),\n    promise: (value) => assertType(is.promise(value), 'Promise', value),\n    generatorFunction: (value) => assertType(is.generatorFunction(value), 'GeneratorFunction', value),\n    asyncGeneratorFunction: (value) => assertType(is.asyncGeneratorFunction(value), 'AsyncGeneratorFunction', value),\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    asyncFunction: (value) => assertType(is.asyncFunction(value), 'AsyncFunction', value),\n    // eslint-disable-next-line @typescript-eslint/ban-types\n    boundFunction: (value) => assertType(is.boundFunction(value), 'Function', value),\n    regExp: (value) => assertType(is.regExp(value), 'RegExp', value),\n    date: (value) => assertType(is.date(value), 'Date', value),\n    error: (value) => assertType(is.error(value), 'Error', value),\n    map: (value) => assertType(is.map(value), 'Map', value),\n    set: (value) => assertType(is.set(value), 'Set', value),\n    weakMap: (value) => assertType(is.weakMap(value), 'WeakMap', value),\n    weakSet: (value) => assertType(is.weakSet(value), 'WeakSet', value),\n    int8Array: (value) => assertType(is.int8Array(value), 'Int8Array', value),\n    uint8Array: (value) => assertType(is.uint8Array(value), 'Uint8Array', value),\n    uint8ClampedArray: (value) => assertType(is.uint8ClampedArray(value), 'Uint8ClampedArray', value),\n    int16Array: (value) => assertType(is.int16Array(value), 'Int16Array', value),\n    uint16Array: (value) => assertType(is.uint16Array(value), 'Uint16Array', value),\n    int32Array: (value) => assertType(is.int32Array(value), 'Int32Array', value),\n    uint32Array: (value) => assertType(is.uint32Array(value), 'Uint32Array', value),\n    float32Array: (value) => assertType(is.float32Array(value), 'Float32Array', value),\n    float64Array: (value) => assertType(is.float64Array(value), 'Float64Array', value),\n    bigInt64Array: (value) => assertType(is.bigInt64Array(value), 'BigInt64Array', value),\n    bigUint64Array: (value) => assertType(is.bigUint64Array(value), 'BigUint64Array', value),\n    arrayBuffer: (value) => assertType(is.arrayBuffer(value), 'ArrayBuffer', value),\n    sharedArrayBuffer: (value) => assertType(is.sharedArrayBuffer(value), 'SharedArrayBuffer', value),\n    dataView: (value) => assertType(is.dataView(value), 'DataView', value),\n    enumCase: (value, targetEnum) => assertType(is.enumCase(value, targetEnum), 'EnumCase', value),\n    urlInstance: (value) => assertType(is.urlInstance(value), 'URL', value),\n    urlString: (value) => assertType(is.urlString(value), \"string with a URL\" /* urlString */, value),\n    truthy: (value) => assertType(is.truthy(value), \"truthy\" /* truthy */, value),\n    falsy: (value) => assertType(is.falsy(value), \"falsy\" /* falsy */, value),\n    nan: (value) => assertType(is.nan(value), \"NaN\" /* nan */, value),\n    primitive: (value) => assertType(is.primitive(value), \"primitive\" /* primitive */, value),\n    integer: (value) => assertType(is.integer(value), \"integer\" /* integer */, value),\n    safeInteger: (value) => assertType(is.safeInteger(value), \"integer\" /* safeInteger */, value),\n    plainObject: (value) => assertType(is.plainObject(value), \"plain object\" /* plainObject */, value),\n    typedArray: (value) => assertType(is.typedArray(value), \"TypedArray\" /* typedArray */, value),\n    arrayLike: (value) => assertType(is.arrayLike(value), \"array-like\" /* arrayLike */, value),\n    domElement: (value) => assertType(is.domElement(value), \"HTMLElement\" /* domElement */, value),\n    observable: (value) => assertType(is.observable(value), 'Observable', value),\n    nodeStream: (value) => assertType(is.nodeStream(value), \"Node.js Stream\" /* nodeStream */, value),\n    infinite: (value) => assertType(is.infinite(value), \"infinite number\" /* infinite */, value),\n    emptyArray: (value) => assertType(is.emptyArray(value), \"empty array\" /* emptyArray */, value),\n    nonEmptyArray: (value) => assertType(is.nonEmptyArray(value), \"non-empty array\" /* nonEmptyArray */, value),\n    emptyString: (value) => assertType(is.emptyString(value), \"empty string\" /* emptyString */, value),\n    emptyStringOrWhitespace: (value) => assertType(is.emptyStringOrWhitespace(value), \"empty string or whitespace\" /* emptyStringOrWhitespace */, value),\n    nonEmptyString: (value) => assertType(is.nonEmptyString(value), \"non-empty string\" /* nonEmptyString */, value),\n    nonEmptyStringAndNotWhitespace: (value) => assertType(is.nonEmptyStringAndNotWhitespace(value), \"non-empty string and not whitespace\" /* nonEmptyStringAndNotWhitespace */, value),\n    emptyObject: (value) => assertType(is.emptyObject(value), \"empty object\" /* emptyObject */, value),\n    nonEmptyObject: (value) => assertType(is.nonEmptyObject(value), \"non-empty object\" /* nonEmptyObject */, value),\n    emptySet: (value) => assertType(is.emptySet(value), \"empty set\" /* emptySet */, value),\n    nonEmptySet: (value) => assertType(is.nonEmptySet(value), \"non-empty set\" /* nonEmptySet */, value),\n    emptyMap: (value) => assertType(is.emptyMap(value), \"empty map\" /* emptyMap */, value),\n    nonEmptyMap: (value) => assertType(is.nonEmptyMap(value), \"non-empty map\" /* nonEmptyMap */, value),\n    propertyKey: (value) => assertType(is.propertyKey(value), 'PropertyKey', value),\n    formData: (value) => assertType(is.formData(value), 'FormData', value),\n    urlSearchParams: (value) => assertType(is.urlSearchParams(value), 'URLSearchParams', value),\n    // Numbers.\n    evenInteger: (value) => assertType(is.evenInteger(value), \"even integer\" /* evenInteger */, value),\n    oddInteger: (value) => assertType(is.oddInteger(value), \"odd integer\" /* oddInteger */, value),\n    // Two arguments.\n    directInstanceOf: (instance, class_) => assertType(is.directInstanceOf(instance, class_), \"T\" /* directInstanceOf */, instance),\n    inRange: (value, range) => assertType(is.inRange(value, range), \"in range\" /* inRange */, value),\n    // Variadic functions.\n    any: (predicate, ...values) => {\n        return assertType(is.any(predicate, ...values), \"predicate returns truthy for any value\" /* any */, values, { multipleValues: true });\n    },\n    all: (predicate, ...values) => assertType(is.all(predicate, ...values), \"predicate returns truthy for all values\" /* all */, values, { multipleValues: true })\n};\n// Some few keywords are reserved, but we'll populate them for Node.js users\n// See https://github.com/Microsoft/TypeScript/issues/2536\nObject.defineProperties(is, {\n    class: {\n        value: is.class_\n    },\n    function: {\n        value: is.function_\n    },\n    null: {\n        value: is.null_\n    }\n});\nObject.defineProperties(exports.assert, {\n    class: {\n        value: exports.assert.class_\n    },\n    function: {\n        value: exports.assert.function_\n    },\n    null: {\n        value: exports.assert.null_\n    }\n});\nexports[\"default\"] = is;\n// For CommonJS default export support\nmodule.exports = is;\nmodule.exports[\"default\"] = is;\nmodule.exports.assert = exports.assert;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@sindresorhus/is/dist/index.js?\n}")},"./node_modules/@szmarczak/http-timer/dist/source/index.js":(module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst defer_to_connect_1 = __webpack_require__(/*! defer-to-connect */ \"./node_modules/defer-to-connect/dist/source/index.js\");\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst nodejsMajorVersion = Number(process.versions.node.split('.')[0]);\nconst timer = (request) => {\n    if (request.timings) {\n        return request.timings;\n    }\n    const timings = {\n        start: Date.now(),\n        socket: undefined,\n        lookup: undefined,\n        connect: undefined,\n        secureConnect: undefined,\n        upload: undefined,\n        response: undefined,\n        end: undefined,\n        error: undefined,\n        abort: undefined,\n        phases: {\n            wait: undefined,\n            dns: undefined,\n            tcp: undefined,\n            tls: undefined,\n            request: undefined,\n            firstByte: undefined,\n            download: undefined,\n            total: undefined\n        }\n    };\n    request.timings = timings;\n    const handleError = (origin) => {\n        const emit = origin.emit.bind(origin);\n        origin.emit = (event, ...args) => {\n            // Catches the `error` event\n            if (event === 'error') {\n                timings.error = Date.now();\n                timings.phases.total = timings.error - timings.start;\n                origin.emit = emit;\n            }\n            // Saves the original behavior\n            return emit(event, ...args);\n        };\n    };\n    handleError(request);\n    const onAbort = () => {\n        timings.abort = Date.now();\n        // Let the `end` response event be responsible for setting the total phase,\n        // unless the Node.js major version is >= 13.\n        if (!timings.response || nodejsMajorVersion >= 13) {\n            timings.phases.total = Date.now() - timings.start;\n        }\n    };\n    request.prependOnceListener('abort', onAbort);\n    const onSocket = (socket) => {\n        timings.socket = Date.now();\n        timings.phases.wait = timings.socket - timings.start;\n        if (util_1.types.isProxy(socket)) {\n            return;\n        }\n        const lookupListener = () => {\n            timings.lookup = Date.now();\n            timings.phases.dns = timings.lookup - timings.socket;\n        };\n        socket.prependOnceListener('lookup', lookupListener);\n        defer_to_connect_1.default(socket, {\n            connect: () => {\n                timings.connect = Date.now();\n                if (timings.lookup === undefined) {\n                    socket.removeListener('lookup', lookupListener);\n                    timings.lookup = timings.connect;\n                    timings.phases.dns = timings.lookup - timings.socket;\n                }\n                timings.phases.tcp = timings.connect - timings.lookup;\n                // This callback is called before flushing any data,\n                // so we don't need to set `timings.phases.request` here.\n            },\n            secureConnect: () => {\n                timings.secureConnect = Date.now();\n                timings.phases.tls = timings.secureConnect - timings.connect;\n            }\n        });\n    };\n    if (request.socket) {\n        onSocket(request.socket);\n    }\n    else {\n        request.prependOnceListener('socket', onSocket);\n    }\n    const onUpload = () => {\n        var _a;\n        timings.upload = Date.now();\n        timings.phases.request = timings.upload - ((_a = timings.secureConnect) !== null && _a !== void 0 ? _a : timings.connect);\n    };\n    const writableFinished = () => {\n        if (typeof request.writableFinished === 'boolean') {\n            return request.writableFinished;\n        }\n        // Node.js doesn't have `request.writableFinished` property\n        return request.finished && request.outputSize === 0 && (!request.socket || request.socket.writableLength === 0);\n    };\n    if (writableFinished()) {\n        onUpload();\n    }\n    else {\n        request.prependOnceListener('finish', onUpload);\n    }\n    request.prependOnceListener('response', (response) => {\n        timings.response = Date.now();\n        timings.phases.firstByte = timings.response - timings.upload;\n        response.timings = timings;\n        handleError(response);\n        response.prependOnceListener('end', () => {\n            timings.end = Date.now();\n            timings.phases.download = timings.end - timings.response;\n            timings.phases.total = timings.end - timings.start;\n        });\n        response.prependOnceListener('aborted', onAbort);\n    });\n    return timings;\n};\nexports[\"default\"] = timer;\n// For CommonJS default export support\nmodule.exports = timer;\nmodule.exports[\"default\"] = timer;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/@szmarczak/http-timer/dist/source/index.js?\n}")},"./node_modules/ajv/dist/runtime/equal.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n// https://github.com/ajv-validator/ajv/issues/889\nconst equal = __webpack_require__(/*! fast-deep-equal */ "./node_modules/fast-deep-equal/index.js");\nequal.code = \'require("ajv/dist/runtime/equal").default\';\nexports["default"] = equal;\n//# sourceMappingURL=equal.js.map\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/ajv/dist/runtime/equal.js?\n}')},"./node_modules/cacheable-lookup/source/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{\nconst {\n\tV4MAPPED,\n\tADDRCONFIG,\n\tALL,\n\tpromises: {\n\t\tResolver: AsyncResolver\n\t},\n\tlookup: dnsLookup\n} = __webpack_require__(/*! dns */ \"dns\");\nconst {promisify} = __webpack_require__(/*! util */ \"util\");\nconst os = __webpack_require__(/*! os */ \"os\");\n\nconst kCacheableLookupCreateConnection = Symbol('cacheableLookupCreateConnection');\nconst kCacheableLookupInstance = Symbol('cacheableLookupInstance');\nconst kExpires = Symbol('expires');\n\nconst supportsALL = typeof ALL === 'number';\n\nconst verifyAgent = agent => {\n\tif (!(agent && typeof agent.createConnection === 'function')) {\n\t\tthrow new Error('Expected an Agent instance as the first argument');\n\t}\n};\n\nconst map4to6 = entries => {\n\tfor (const entry of entries) {\n\t\tif (entry.family === 6) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tentry.address = `::ffff:${entry.address}`;\n\t\tentry.family = 6;\n\t}\n};\n\nconst getIfaceInfo = () => {\n\tlet has4 = false;\n\tlet has6 = false;\n\n\tfor (const device of Object.values(os.networkInterfaces())) {\n\t\tfor (const iface of device) {\n\t\t\tif (iface.internal) {\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tif (iface.family === 'IPv6') {\n\t\t\t\thas6 = true;\n\t\t\t} else {\n\t\t\t\thas4 = true;\n\t\t\t}\n\n\t\t\tif (has4 && has6) {\n\t\t\t\treturn {has4, has6};\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {has4, has6};\n};\n\nconst isIterable = map => {\n\treturn Symbol.iterator in map;\n};\n\nconst ttl = {ttl: true};\nconst all = {all: true};\n\nclass CacheableLookup {\n\tconstructor({\n\t\tcache = new Map(),\n\t\tmaxTtl = Infinity,\n\t\tfallbackDuration = 3600,\n\t\terrorTtl = 0.15,\n\t\tresolver = new AsyncResolver(),\n\t\tlookup = dnsLookup\n\t} = {}) {\n\t\tthis.maxTtl = maxTtl;\n\t\tthis.errorTtl = errorTtl;\n\n\t\tthis._cache = cache;\n\t\tthis._resolver = resolver;\n\t\tthis._dnsLookup = promisify(lookup);\n\n\t\tif (this._resolver instanceof AsyncResolver) {\n\t\t\tthis._resolve4 = this._resolver.resolve4.bind(this._resolver);\n\t\t\tthis._resolve6 = this._resolver.resolve6.bind(this._resolver);\n\t\t} else {\n\t\t\tthis._resolve4 = promisify(this._resolver.resolve4.bind(this._resolver));\n\t\t\tthis._resolve6 = promisify(this._resolver.resolve6.bind(this._resolver));\n\t\t}\n\n\t\tthis._iface = getIfaceInfo();\n\n\t\tthis._pending = {};\n\t\tthis._nextRemovalTime = false;\n\t\tthis._hostnamesToFallback = new Set();\n\n\t\tif (fallbackDuration < 1) {\n\t\t\tthis._fallback = false;\n\t\t} else {\n\t\t\tthis._fallback = true;\n\n\t\t\tconst interval = setInterval(() => {\n\t\t\t\tthis._hostnamesToFallback.clear();\n\t\t\t}, fallbackDuration * 1000);\n\n\t\t\t/* istanbul ignore next: There is no `interval.unref()` when running inside an Electron renderer */\n\t\t\tif (interval.unref) {\n\t\t\t\tinterval.unref();\n\t\t\t}\n\t\t}\n\n\t\tthis.lookup = this.lookup.bind(this);\n\t\tthis.lookupAsync = this.lookupAsync.bind(this);\n\t}\n\n\tset servers(servers) {\n\t\tthis.clear();\n\n\t\tthis._resolver.setServers(servers);\n\t}\n\n\tget servers() {\n\t\treturn this._resolver.getServers();\n\t}\n\n\tlookup(hostname, options, callback) {\n\t\tif (typeof options === 'function') {\n\t\t\tcallback = options;\n\t\t\toptions = {};\n\t\t} else if (typeof options === 'number') {\n\t\t\toptions = {\n\t\t\t\tfamily: options\n\t\t\t};\n\t\t}\n\n\t\tif (!callback) {\n\t\t\tthrow new Error('Callback must be a function.');\n\t\t}\n\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\tthis.lookupAsync(hostname, options).then(result => {\n\t\t\tif (options.all) {\n\t\t\t\tcallback(null, result);\n\t\t\t} else {\n\t\t\t\tcallback(null, result.address, result.family, result.expires, result.ttl);\n\t\t\t}\n\t\t}, callback);\n\t}\n\n\tasync lookupAsync(hostname, options = {}) {\n\t\tif (typeof options === 'number') {\n\t\t\toptions = {\n\t\t\t\tfamily: options\n\t\t\t};\n\t\t}\n\n\t\tlet cached = await this.query(hostname);\n\n\t\tif (options.family === 6) {\n\t\t\tconst filtered = cached.filter(entry => entry.family === 6);\n\n\t\t\tif (options.hints & V4MAPPED) {\n\t\t\t\tif ((supportsALL && options.hints & ALL) || filtered.length === 0) {\n\t\t\t\t\tmap4to6(cached);\n\t\t\t\t} else {\n\t\t\t\t\tcached = filtered;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tcached = filtered;\n\t\t\t}\n\t\t} else if (options.family === 4) {\n\t\t\tcached = cached.filter(entry => entry.family === 4);\n\t\t}\n\n\t\tif (options.hints & ADDRCONFIG) {\n\t\t\tconst {_iface} = this;\n\t\t\tcached = cached.filter(entry => entry.family === 6 ? _iface.has6 : _iface.has4);\n\t\t}\n\n\t\tif (cached.length === 0) {\n\t\t\tconst error = new Error(`cacheableLookup ENOTFOUND ${hostname}`);\n\t\t\terror.code = 'ENOTFOUND';\n\t\t\terror.hostname = hostname;\n\n\t\t\tthrow error;\n\t\t}\n\n\t\tif (options.all) {\n\t\t\treturn cached;\n\t\t}\n\n\t\treturn cached[0];\n\t}\n\n\tasync query(hostname) {\n\t\tlet cached = await this._cache.get(hostname);\n\n\t\tif (!cached) {\n\t\t\tconst pending = this._pending[hostname];\n\n\t\t\tif (pending) {\n\t\t\t\tcached = await pending;\n\t\t\t} else {\n\t\t\t\tconst newPromise = this.queryAndCache(hostname);\n\t\t\t\tthis._pending[hostname] = newPromise;\n\n\t\t\t\ttry {\n\t\t\t\t\tcached = await newPromise;\n\t\t\t\t} finally {\n\t\t\t\t\tdelete this._pending[hostname];\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tcached = cached.map(entry => {\n\t\t\treturn {...entry};\n\t\t});\n\n\t\treturn cached;\n\t}\n\n\tasync _resolve(hostname) {\n\t\tconst wrap = async promise => {\n\t\t\ttry {\n\t\t\t\treturn await promise;\n\t\t\t} catch (error) {\n\t\t\t\tif (error.code === 'ENODATA' || error.code === 'ENOTFOUND') {\n\t\t\t\t\treturn [];\n\t\t\t\t}\n\n\t\t\t\tthrow error;\n\t\t\t}\n\t\t};\n\n\t\t// ANY is unsafe as it doesn't trigger new queries in the underlying server.\n\t\tconst [A, AAAA] = await Promise.all([\n\t\t\tthis._resolve4(hostname, ttl),\n\t\t\tthis._resolve6(hostname, ttl)\n\t\t].map(promise => wrap(promise)));\n\n\t\tlet aTtl = 0;\n\t\tlet aaaaTtl = 0;\n\t\tlet cacheTtl = 0;\n\n\t\tconst now = Date.now();\n\n\t\tfor (const entry of A) {\n\t\t\tentry.family = 4;\n\t\t\tentry.expires = now + (entry.ttl * 1000);\n\n\t\t\taTtl = Math.max(aTtl, entry.ttl);\n\t\t}\n\n\t\tfor (const entry of AAAA) {\n\t\t\tentry.family = 6;\n\t\t\tentry.expires = now + (entry.ttl * 1000);\n\n\t\t\taaaaTtl = Math.max(aaaaTtl, entry.ttl);\n\t\t}\n\n\t\tif (A.length > 0) {\n\t\t\tif (AAAA.length > 0) {\n\t\t\t\tcacheTtl = Math.min(aTtl, aaaaTtl);\n\t\t\t} else {\n\t\t\t\tcacheTtl = aTtl;\n\t\t\t}\n\t\t} else {\n\t\t\tcacheTtl = aaaaTtl;\n\t\t}\n\n\t\treturn {\n\t\t\tentries: [\n\t\t\t\t...A,\n\t\t\t\t...AAAA\n\t\t\t],\n\t\t\tcacheTtl\n\t\t};\n\t}\n\n\tasync _lookup(hostname) {\n\t\ttry {\n\t\t\tconst entries = await this._dnsLookup(hostname, {\n\t\t\t\tall: true\n\t\t\t});\n\n\t\t\treturn {\n\t\t\t\tentries,\n\t\t\t\tcacheTtl: 0\n\t\t\t};\n\t\t} catch (_) {\n\t\t\treturn {\n\t\t\t\tentries: [],\n\t\t\t\tcacheTtl: 0\n\t\t\t};\n\t\t}\n\t}\n\n\tasync _set(hostname, data, cacheTtl) {\n\t\tif (this.maxTtl > 0 && cacheTtl > 0) {\n\t\t\tcacheTtl = Math.min(cacheTtl, this.maxTtl) * 1000;\n\t\t\tdata[kExpires] = Date.now() + cacheTtl;\n\n\t\t\ttry {\n\t\t\t\tawait this._cache.set(hostname, data, cacheTtl);\n\t\t\t} catch (error) {\n\t\t\t\tthis.lookupAsync = async () => {\n\t\t\t\t\tconst cacheError = new Error('Cache Error. Please recreate the CacheableLookup instance.');\n\t\t\t\t\tcacheError.cause = error;\n\n\t\t\t\t\tthrow cacheError;\n\t\t\t\t};\n\t\t\t}\n\n\t\t\tif (isIterable(this._cache)) {\n\t\t\t\tthis._tick(cacheTtl);\n\t\t\t}\n\t\t}\n\t}\n\n\tasync queryAndCache(hostname) {\n\t\tif (this._hostnamesToFallback.has(hostname)) {\n\t\t\treturn this._dnsLookup(hostname, all);\n\t\t}\n\n\t\tlet query = await this._resolve(hostname);\n\n\t\tif (query.entries.length === 0 && this._fallback) {\n\t\t\tquery = await this._lookup(hostname);\n\n\t\t\tif (query.entries.length !== 0) {\n\t\t\t\t// Use `dns.lookup(...)` for that particular hostname\n\t\t\t\tthis._hostnamesToFallback.add(hostname);\n\t\t\t}\n\t\t}\n\n\t\tconst cacheTtl = query.entries.length === 0 ? this.errorTtl : query.cacheTtl;\n\t\tawait this._set(hostname, query.entries, cacheTtl);\n\n\t\treturn query.entries;\n\t}\n\n\t_tick(ms) {\n\t\tconst nextRemovalTime = this._nextRemovalTime;\n\n\t\tif (!nextRemovalTime || ms < nextRemovalTime) {\n\t\t\tclearTimeout(this._removalTimeout);\n\n\t\t\tthis._nextRemovalTime = ms;\n\n\t\t\tthis._removalTimeout = setTimeout(() => {\n\t\t\t\tthis._nextRemovalTime = false;\n\n\t\t\t\tlet nextExpiry = Infinity;\n\n\t\t\t\tconst now = Date.now();\n\n\t\t\t\tfor (const [hostname, entries] of this._cache) {\n\t\t\t\t\tconst expires = entries[kExpires];\n\n\t\t\t\t\tif (now >= expires) {\n\t\t\t\t\t\tthis._cache.delete(hostname);\n\t\t\t\t\t} else if (expires < nextExpiry) {\n\t\t\t\t\t\tnextExpiry = expires;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (nextExpiry !== Infinity) {\n\t\t\t\t\tthis._tick(nextExpiry - now);\n\t\t\t\t}\n\t\t\t}, ms);\n\n\t\t\t/* istanbul ignore next: There is no `timeout.unref()` when running inside an Electron renderer */\n\t\t\tif (this._removalTimeout.unref) {\n\t\t\t\tthis._removalTimeout.unref();\n\t\t\t}\n\t\t}\n\t}\n\n\tinstall(agent) {\n\t\tverifyAgent(agent);\n\n\t\tif (kCacheableLookupCreateConnection in agent) {\n\t\t\tthrow new Error('CacheableLookup has been already installed');\n\t\t}\n\n\t\tagent[kCacheableLookupCreateConnection] = agent.createConnection;\n\t\tagent[kCacheableLookupInstance] = this;\n\n\t\tagent.createConnection = (options, callback) => {\n\t\t\tif (!('lookup' in options)) {\n\t\t\t\toptions.lookup = this.lookup;\n\t\t\t}\n\n\t\t\treturn agent[kCacheableLookupCreateConnection](options, callback);\n\t\t};\n\t}\n\n\tuninstall(agent) {\n\t\tverifyAgent(agent);\n\n\t\tif (agent[kCacheableLookupCreateConnection]) {\n\t\t\tif (agent[kCacheableLookupInstance] !== this) {\n\t\t\t\tthrow new Error('The agent is not owned by this CacheableLookup instance');\n\t\t\t}\n\n\t\t\tagent.createConnection = agent[kCacheableLookupCreateConnection];\n\n\t\t\tdelete agent[kCacheableLookupCreateConnection];\n\t\t\tdelete agent[kCacheableLookupInstance];\n\t\t}\n\t}\n\n\tupdateInterfaceInfo() {\n\t\tconst {_iface} = this;\n\n\t\tthis._iface = getIfaceInfo();\n\n\t\tif ((_iface.has4 && !this._iface.has4) || (_iface.has6 && !this._iface.has6)) {\n\t\t\tthis._cache.clear();\n\t\t}\n\t}\n\n\tclear(hostname) {\n\t\tif (hostname) {\n\t\t\tthis._cache.delete(hostname);\n\t\t\treturn;\n\t\t}\n\n\t\tthis._cache.clear();\n\t}\n}\n\nmodule.exports = CacheableLookup;\nmodule.exports[\"default\"] = CacheableLookup;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/cacheable-lookup/source/index.js?\n}")},"./node_modules/cacheable-request/src/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst urlLib = __webpack_require__(/*! url */ \"url\");\nconst normalizeUrl = __webpack_require__(/*! normalize-url */ \"./node_modules/normalize-url/index.js\");\nconst getStream = __webpack_require__(/*! get-stream */ \"./node_modules/get-stream/index.js\");\nconst CachePolicy = __webpack_require__(/*! http-cache-semantics */ \"./node_modules/http-cache-semantics/index.js\");\nconst Response = __webpack_require__(/*! responselike */ \"./node_modules/responselike/src/index.js\");\nconst lowercaseKeys = __webpack_require__(/*! lowercase-keys */ \"./node_modules/lowercase-keys/index.js\");\nconst cloneResponse = __webpack_require__(/*! clone-response */ \"./node_modules/clone-response/src/index.js\");\nconst Keyv = __webpack_require__(/*! keyv */ \"./node_modules/keyv/src/index.js\");\n\nclass CacheableRequest {\n\tconstructor(request, cacheAdapter) {\n\t\tif (typeof request !== 'function') {\n\t\t\tthrow new TypeError('Parameter `request` must be a function');\n\t\t}\n\n\t\tthis.cache = new Keyv({\n\t\t\turi: typeof cacheAdapter === 'string' && cacheAdapter,\n\t\t\tstore: typeof cacheAdapter !== 'string' && cacheAdapter,\n\t\t\tnamespace: 'cacheable-request'\n\t\t});\n\n\t\treturn this.createCacheableRequest(request);\n\t}\n\n\tcreateCacheableRequest(request) {\n\t\treturn (opts, cb) => {\n\t\t\tlet url;\n\t\t\tif (typeof opts === 'string') {\n\t\t\t\turl = normalizeUrlObject(urlLib.parse(opts));\n\t\t\t\topts = {};\n\t\t\t} else if (opts instanceof urlLib.URL) {\n\t\t\t\turl = normalizeUrlObject(urlLib.parse(opts.toString()));\n\t\t\t\topts = {};\n\t\t\t} else {\n\t\t\t\tconst [pathname, ...searchParts] = (opts.path || '').split('?');\n\t\t\t\tconst search = searchParts.length > 0 ?\n\t\t\t\t\t`?${searchParts.join('?')}` :\n\t\t\t\t\t'';\n\t\t\t\turl = normalizeUrlObject({ ...opts, pathname, search });\n\t\t\t}\n\n\t\t\topts = {\n\t\t\t\theaders: {},\n\t\t\t\tmethod: 'GET',\n\t\t\t\tcache: true,\n\t\t\t\tstrictTtl: false,\n\t\t\t\tautomaticFailover: false,\n\t\t\t\t...opts,\n\t\t\t\t...urlObjectToRequestOptions(url)\n\t\t\t};\n\t\t\topts.headers = lowercaseKeys(opts.headers);\n\n\t\t\tconst ee = new EventEmitter();\n\t\t\tconst normalizedUrlString = normalizeUrl(\n\t\t\t\turlLib.format(url),\n\t\t\t\t{\n\t\t\t\t\tstripWWW: false,\n\t\t\t\t\tremoveTrailingSlash: false,\n\t\t\t\t\tstripAuthentication: false\n\t\t\t\t}\n\t\t\t);\n\t\t\tconst key = `${opts.method}:${normalizedUrlString}`;\n\t\t\tlet revalidate = false;\n\t\t\tlet madeRequest = false;\n\n\t\t\tconst makeRequest = opts => {\n\t\t\t\tmadeRequest = true;\n\t\t\t\tlet requestErrored = false;\n\t\t\t\tlet requestErrorCallback;\n\n\t\t\t\tconst requestErrorPromise = new Promise(resolve => {\n\t\t\t\t\trequestErrorCallback = () => {\n\t\t\t\t\t\tif (!requestErrored) {\n\t\t\t\t\t\t\trequestErrored = true;\n\t\t\t\t\t\t\tresolve();\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\t\t\t\t});\n\n\t\t\t\tconst handler = response => {\n\t\t\t\t\tif (revalidate && !opts.forceRefresh) {\n\t\t\t\t\t\tresponse.status = response.statusCode;\n\t\t\t\t\t\tconst revalidatedPolicy = CachePolicy.fromObject(revalidate.cachePolicy).revalidatedPolicy(opts, response);\n\t\t\t\t\t\tif (!revalidatedPolicy.modified) {\n\t\t\t\t\t\t\tconst headers = revalidatedPolicy.policy.responseHeaders();\n\t\t\t\t\t\t\tresponse = new Response(revalidate.statusCode, headers, revalidate.body, revalidate.url);\n\t\t\t\t\t\t\tresponse.cachePolicy = revalidatedPolicy.policy;\n\t\t\t\t\t\t\tresponse.fromCache = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\tif (!response.fromCache) {\n\t\t\t\t\t\tresponse.cachePolicy = new CachePolicy(opts, response, opts);\n\t\t\t\t\t\tresponse.fromCache = false;\n\t\t\t\t\t}\n\n\t\t\t\t\tlet clonedResponse;\n\t\t\t\t\tif (opts.cache && response.cachePolicy.storable()) {\n\t\t\t\t\t\tclonedResponse = cloneResponse(response);\n\n\t\t\t\t\t\t(async () => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tconst bodyPromise = getStream.buffer(response);\n\n\t\t\t\t\t\t\t\tawait Promise.race([\n\t\t\t\t\t\t\t\t\trequestErrorPromise,\n\t\t\t\t\t\t\t\t\tnew Promise(resolve => response.once('end', resolve))\n\t\t\t\t\t\t\t\t]);\n\n\t\t\t\t\t\t\t\tif (requestErrored) {\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst body = await bodyPromise;\n\n\t\t\t\t\t\t\t\tconst value = {\n\t\t\t\t\t\t\t\t\tcachePolicy: response.cachePolicy.toObject(),\n\t\t\t\t\t\t\t\t\turl: response.url,\n\t\t\t\t\t\t\t\t\tstatusCode: response.fromCache ? revalidate.statusCode : response.statusCode,\n\t\t\t\t\t\t\t\t\tbody\n\t\t\t\t\t\t\t\t};\n\n\t\t\t\t\t\t\t\tlet ttl = opts.strictTtl ? response.cachePolicy.timeToLive() : undefined;\n\t\t\t\t\t\t\t\tif (opts.maxTtl) {\n\t\t\t\t\t\t\t\t\tttl = ttl ? Math.min(ttl, opts.maxTtl) : opts.maxTtl;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tawait this.cache.set(key, value, ttl);\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\tee.emit('error', new CacheableRequest.CacheError(error));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})();\n\t\t\t\t\t} else if (opts.cache && revalidate) {\n\t\t\t\t\t\t(async () => {\n\t\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\t\tawait this.cache.delete(key);\n\t\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\t\tee.emit('error', new CacheableRequest.CacheError(error));\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t})();\n\t\t\t\t\t}\n\n\t\t\t\t\tee.emit('response', clonedResponse || response);\n\t\t\t\t\tif (typeof cb === 'function') {\n\t\t\t\t\t\tcb(clonedResponse || response);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\ttry {\n\t\t\t\t\tconst req = request(opts, handler);\n\t\t\t\t\treq.once('error', requestErrorCallback);\n\t\t\t\t\treq.once('abort', requestErrorCallback);\n\t\t\t\t\tee.emit('request', req);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tee.emit('error', new CacheableRequest.RequestError(error));\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t(async () => {\n\t\t\t\tconst get = async opts => {\n\t\t\t\t\tawait Promise.resolve();\n\n\t\t\t\t\tconst cacheEntry = opts.cache ? await this.cache.get(key) : undefined;\n\t\t\t\t\tif (typeof cacheEntry === 'undefined') {\n\t\t\t\t\t\treturn makeRequest(opts);\n\t\t\t\t\t}\n\n\t\t\t\t\tconst policy = CachePolicy.fromObject(cacheEntry.cachePolicy);\n\t\t\t\t\tif (policy.satisfiesWithoutRevalidation(opts) && !opts.forceRefresh) {\n\t\t\t\t\t\tconst headers = policy.responseHeaders();\n\t\t\t\t\t\tconst response = new Response(cacheEntry.statusCode, headers, cacheEntry.body, cacheEntry.url);\n\t\t\t\t\t\tresponse.cachePolicy = policy;\n\t\t\t\t\t\tresponse.fromCache = true;\n\n\t\t\t\t\t\tee.emit('response', response);\n\t\t\t\t\t\tif (typeof cb === 'function') {\n\t\t\t\t\t\t\tcb(response);\n\t\t\t\t\t\t}\n\t\t\t\t\t} else {\n\t\t\t\t\t\trevalidate = cacheEntry;\n\t\t\t\t\t\topts.headers = policy.revalidationHeaders(opts);\n\t\t\t\t\t\tmakeRequest(opts);\n\t\t\t\t\t}\n\t\t\t\t};\n\n\t\t\t\tconst errorHandler = error => ee.emit('error', new CacheableRequest.CacheError(error));\n\t\t\t\tthis.cache.once('error', errorHandler);\n\t\t\t\tee.on('response', () => this.cache.removeListener('error', errorHandler));\n\n\t\t\t\ttry {\n\t\t\t\t\tawait get(opts);\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (opts.automaticFailover && !madeRequest) {\n\t\t\t\t\t\tmakeRequest(opts);\n\t\t\t\t\t}\n\n\t\t\t\t\tee.emit('error', new CacheableRequest.CacheError(error));\n\t\t\t\t}\n\t\t\t})();\n\n\t\t\treturn ee;\n\t\t};\n\t}\n}\n\nfunction urlObjectToRequestOptions(url) {\n\tconst options = { ...url };\n\toptions.path = `${url.pathname || '/'}${url.search || ''}`;\n\tdelete options.pathname;\n\tdelete options.search;\n\treturn options;\n}\n\nfunction normalizeUrlObject(url) {\n\t// If url was parsed by url.parse or new URL:\n\t// - hostname will be set\n\t// - host will be hostname[:port]\n\t// - port will be set if it was explicit in the parsed string\n\t// Otherwise, url was from request options:\n\t// - hostname or host may be set\n\t// - host shall not have port encoded\n\treturn {\n\t\tprotocol: url.protocol,\n\t\tauth: url.auth,\n\t\thostname: url.hostname || url.host || 'localhost',\n\t\tport: url.port,\n\t\tpathname: url.pathname,\n\t\tsearch: url.search\n\t};\n}\n\nCacheableRequest.RequestError = class extends Error {\n\tconstructor(error) {\n\t\tsuper(error.message);\n\t\tthis.name = 'RequestError';\n\t\tObject.assign(this, error);\n\t}\n};\n\nCacheableRequest.CacheError = class extends Error {\n\tconstructor(error) {\n\t\tsuper(error.message);\n\t\tthis.name = 'CacheError';\n\t\tObject.assign(this, error);\n\t}\n};\n\nmodule.exports = CacheableRequest;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/cacheable-request/src/index.js?\n}")},"./node_modules/clone-response/node_modules/mimic-response/index.js":module=>{"use strict";eval("{\n\n// We define these manually to ensure they're always copied\n// even if they would move up the prototype chain\n// https://nodejs.org/api/http.html#http_class_http_incomingmessage\nconst knownProps = [\n\t'destroy',\n\t'setTimeout',\n\t'socket',\n\t'headers',\n\t'trailers',\n\t'rawHeaders',\n\t'statusCode',\n\t'httpVersion',\n\t'httpVersionMinor',\n\t'httpVersionMajor',\n\t'rawTrailers',\n\t'statusMessage'\n];\n\nmodule.exports = (fromStream, toStream) => {\n\tconst fromProps = new Set(Object.keys(fromStream).concat(knownProps));\n\n\tfor (const prop of fromProps) {\n\t\t// Don't overwrite existing properties\n\t\tif (prop in toStream) {\n\t\t\tcontinue;\n\t\t}\n\n\t\ttoStream[prop] = typeof fromStream[prop] === 'function' ? fromStream[prop].bind(fromStream) : fromStream[prop];\n\t}\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/clone-response/node_modules/mimic-response/index.js?\n}")},"./node_modules/clone-response/src/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('{\n\nconst PassThrough = (__webpack_require__(/*! stream */ "stream").PassThrough);\nconst mimicResponse = __webpack_require__(/*! mimic-response */ "./node_modules/clone-response/node_modules/mimic-response/index.js");\n\nconst cloneResponse = response => {\n\tif (!(response && response.pipe)) {\n\t\tthrow new TypeError(\'Parameter `response` must be a response stream.\');\n\t}\n\n\tconst clone = new PassThrough();\n\tmimicResponse(response, clone);\n\n\treturn response.pipe(clone);\n};\n\nmodule.exports = cloneResponse;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/clone-response/src/index.js?\n}')},"./node_modules/colord/index.js":(__unused_webpack_module,exports)=>{eval('{Object.defineProperty(exports, "__esModule", ({value:!0}));var r={grad:.9,turn:360,rad:360/(2*Math.PI)},t=function(r){return"string"==typeof r?r.length>0:"number"==typeof r},n=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=Math.pow(10,t)),Math.round(n*r)/n+0},e=function(r,t,n){return void 0===t&&(t=0),void 0===n&&(n=1),r>n?n:r>t?r:t},u=function(r){return(r=isFinite(r)?r%360:0)>0?r:r+360},o=function(r){return{r:e(r.r,0,255),g:e(r.g,0,255),b:e(r.b,0,255),a:e(r.a)}},a=function(r){return{r:n(r.r),g:n(r.g),b:n(r.b),a:n(r.a,3)}},s=/^#([0-9a-f]{3,8})$/i,i=function(r){var t=r.toString(16);return t.length<2?"0"+t:t},h=function(r){var t=r.r,n=r.g,e=r.b,u=r.a,o=Math.max(t,n,e),a=o-Math.min(t,n,e),s=a?o===t?(n-e)/a:o===n?2+(e-t)/a:4+(t-n)/a:0;return{h:60*(s<0?s+6:s),s:o?a/o*100:0,v:o/255*100,a:u}},b=function(r){var t=r.h,n=r.s,e=r.v,u=r.a;t=t/360*6,n/=100,e/=100;var o=Math.floor(t),a=e*(1-n),s=e*(1-(t-o)*n),i=e*(1-(1-t+o)*n),h=o%6;return{r:255*[e,s,a,a,i,e][h],g:255*[i,e,e,s,a,a][h],b:255*[a,a,i,e,e,s][h],a:u}},d=function(r){return{h:u(r.h),s:e(r.s,0,100),l:e(r.l,0,100),a:e(r.a)}},g=function(r){return{h:n(r.h),s:n(r.s),l:n(r.l),a:n(r.a,3)}},f=function(r){return b((n=(t=r).s,{h:t.h,s:(n*=((e=t.l)<50?e:100-e)/100)>0?2*n/(e+n)*100:0,v:e+n,a:t.a}));// removed by dead control flow\n var t, n, e; },p=function(r){return{h:(t=h(r)).h,s:(u=(200-(n=t.s))*(e=t.v)/100)>0&&u<200?n*e/100/(u<=100?u:200-u)*100:0,l:u/2,a:t.a};// removed by dead control flow\n var t, n, e, u; },l=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*,\\s*([+-]?\\d*\\.?\\d+)%\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,c=/^hsla?\\(\\s*([+-]?\\d*\\.?\\d+)(deg|rad|grad|turn)?\\s+([+-]?\\d*\\.?\\d+)%\\s+([+-]?\\d*\\.?\\d+)%\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,v=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*(?:,\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,m=/^rgba?\\(\\s*([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s+([+-]?\\d*\\.?\\d+)(%)?\\s*(?:\\/\\s*([+-]?\\d*\\.?\\d+)(%)?\\s*)?\\)$/i,y={string:[[function(r){var t=s.exec(r);return t?(r=t[1]).length<=4?{r:parseInt(r[0]+r[0],16),g:parseInt(r[1]+r[1],16),b:parseInt(r[2]+r[2],16),a:4===r.length?n(parseInt(r[3]+r[3],16)/255,2):1}:6===r.length||8===r.length?{r:parseInt(r.substr(0,2),16),g:parseInt(r.substr(2,2),16),b:parseInt(r.substr(4,2),16),a:8===r.length?n(parseInt(r.substr(6,2),16)/255,2):1}:null:null},"hex"],[function(r){var t=v.exec(r)||m.exec(r);return t?t[2]!==t[4]||t[4]!==t[6]?null:o({r:Number(t[1])/(t[2]?100/255:1),g:Number(t[3])/(t[4]?100/255:1),b:Number(t[5])/(t[6]?100/255:1),a:void 0===t[7]?1:Number(t[7])/(t[8]?100:1)}):null},"rgb"],[function(t){var n=l.exec(t)||c.exec(t);if(!n)return null;var e,u,o=d({h:(e=n[1],u=n[2],void 0===u&&(u="deg"),Number(e)*(r[u]||1)),s:Number(n[3]),l:Number(n[4]),a:void 0===n[5]?1:Number(n[5])/(n[6]?100:1)});return f(o)},"hsl"]],object:[[function(r){var n=r.r,e=r.g,u=r.b,a=r.a,s=void 0===a?1:a;return t(n)&&t(e)&&t(u)?o({r:Number(n),g:Number(e),b:Number(u),a:Number(s)}):null},"rgb"],[function(r){var n=r.h,e=r.s,u=r.l,o=r.a,a=void 0===o?1:o;if(!t(n)||!t(e)||!t(u))return null;var s=d({h:Number(n),s:Number(e),l:Number(u),a:Number(a)});return f(s)},"hsl"],[function(r){var n=r.h,o=r.s,a=r.v,s=r.a,i=void 0===s?1:s;if(!t(n)||!t(o)||!t(a))return null;var h=function(r){return{h:u(r.h),s:e(r.s,0,100),v:e(r.v,0,100),a:e(r.a)}}({h:Number(n),s:Number(o),v:Number(a),a:Number(i)});return b(h)},"hsv"]]},N=function(r,t){for(var n=0;n<t.length;n++){var e=t[n][0](r);if(e)return[e,t[n][1]]}return[null,void 0]},x=function(r){return"string"==typeof r?N(r.trim(),y.string):"object"==typeof r&&null!==r?N(r,y.object):[null,void 0]},M=function(r,t){var n=p(r);return{h:n.h,s:e(n.s+100*t,0,100),l:n.l,a:n.a}},I=function(r){return(299*r.r+587*r.g+114*r.b)/1e3/255},H=function(r,t){var n=p(r);return{h:n.h,s:n.s,l:e(n.l+100*t,0,100),a:n.a}},$=function(){function r(r){this.parsed=x(r)[0],this.rgba=this.parsed||{r:0,g:0,b:0,a:1}}return r.prototype.isValid=function(){return null!==this.parsed},r.prototype.brightness=function(){return n(I(this.rgba),2)},r.prototype.isDark=function(){return I(this.rgba)<.5},r.prototype.isLight=function(){return I(this.rgba)>=.5},r.prototype.toHex=function(){return r=a(this.rgba),t=r.r,e=r.g,u=r.b,s=(o=r.a)<1?i(n(255*o)):"","#"+i(t)+i(e)+i(u)+s;// removed by dead control flow\n var r, t, e, u, o, s; },r.prototype.toRgb=function(){return a(this.rgba)},r.prototype.toRgbString=function(){return r=a(this.rgba),t=r.r,n=r.g,e=r.b,(u=r.a)<1?"rgba("+t+", "+n+", "+e+", "+u+")":"rgb("+t+", "+n+", "+e+")";// removed by dead control flow\n var r, t, n, e, u; },r.prototype.toHsl=function(){return g(p(this.rgba))},r.prototype.toHslString=function(){return r=g(p(this.rgba)),t=r.h,n=r.s,e=r.l,(u=r.a)<1?"hsla("+t+", "+n+"%, "+e+"%, "+u+")":"hsl("+t+", "+n+"%, "+e+"%)";// removed by dead control flow\n var r, t, n, e, u; },r.prototype.toHsv=function(){return r=h(this.rgba),{h:n(r.h),s:n(r.s),v:n(r.v),a:n(r.a,3)};// removed by dead control flow\n var r; },r.prototype.invert=function(){return j({r:255-(r=this.rgba).r,g:255-r.g,b:255-r.b,a:r.a});// removed by dead control flow\n var r; },r.prototype.saturate=function(r){return void 0===r&&(r=.1),j(M(this.rgba,r))},r.prototype.desaturate=function(r){return void 0===r&&(r=.1),j(M(this.rgba,-r))},r.prototype.grayscale=function(){return j(M(this.rgba,-1))},r.prototype.lighten=function(r){return void 0===r&&(r=.1),j(H(this.rgba,r))},r.prototype.darken=function(r){return void 0===r&&(r=.1),j(H(this.rgba,-r))},r.prototype.rotate=function(r){return void 0===r&&(r=15),this.hue(this.hue()+r)},r.prototype.alpha=function(r){return"number"==typeof r?j({r:(t=this.rgba).r,g:t.g,b:t.b,a:r}):n(this.rgba.a,3);// removed by dead control flow\n var t; },r.prototype.hue=function(r){var t=p(this.rgba);return"number"==typeof r?j({h:r,s:t.s,l:t.l,a:t.a}):n(t.h)},r.prototype.isEqual=function(r){return this.toHex()===j(r).toHex()},r}(),j=function(r){return r instanceof $?r:new $(r)},w=[];exports.Colord=$,exports.colord=j,exports.extend=function(r){r.forEach(function(r){w.indexOf(r)<0&&(r($,y),w.push(r))})},exports.getFormat=function(r){return x(r)[1]},exports.random=function(){return new $({r:255*Math.random(),g:255*Math.random(),b:255*Math.random()})};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/colord/index.js?\n}')},"./node_modules/decompress-response/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{\nconst {Transform, PassThrough} = __webpack_require__(/*! stream */ \"stream\");\nconst zlib = __webpack_require__(/*! zlib */ \"zlib\");\nconst mimicResponse = __webpack_require__(/*! mimic-response */ \"./node_modules/mimic-response/index.js\");\n\nmodule.exports = response => {\n\tconst contentEncoding = (response.headers['content-encoding'] || '').toLowerCase();\n\n\tif (!['gzip', 'deflate', 'br'].includes(contentEncoding)) {\n\t\treturn response;\n\t}\n\n\t// TODO: Remove this when targeting Node.js 12.\n\tconst isBrotli = contentEncoding === 'br';\n\tif (isBrotli && typeof zlib.createBrotliDecompress !== 'function') {\n\t\tresponse.destroy(new Error('Brotli is not supported on Node.js < 12'));\n\t\treturn response;\n\t}\n\n\tlet isEmpty = true;\n\n\tconst checker = new Transform({\n\t\ttransform(data, _encoding, callback) {\n\t\t\tisEmpty = false;\n\n\t\t\tcallback(null, data);\n\t\t},\n\n\t\tflush(callback) {\n\t\t\tcallback();\n\t\t}\n\t});\n\n\tconst finalStream = new PassThrough({\n\t\tautoDestroy: false,\n\t\tdestroy(error, callback) {\n\t\t\tresponse.destroy();\n\n\t\t\tcallback(error);\n\t\t}\n\t});\n\n\tconst decompressStream = isBrotli ? zlib.createBrotliDecompress() : zlib.createUnzip();\n\n\tdecompressStream.once('error', error => {\n\t\tif (isEmpty && !response.readable) {\n\t\t\tfinalStream.end();\n\t\t\treturn;\n\t\t}\n\n\t\tfinalStream.destroy(error);\n\t});\n\n\tmimicResponse(response, finalStream);\n\tresponse.pipe(checker).pipe(decompressStream).pipe(finalStream);\n\n\treturn finalStream;\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/decompress-response/index.js?\n}")},"./node_modules/defer-to-connect/dist/source/index.js":(module,exports)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nfunction isTLSSocket(socket) {\n    return socket.encrypted;\n}\nconst deferToConnect = (socket, fn) => {\n    let listeners;\n    if (typeof fn === 'function') {\n        const connect = fn;\n        listeners = { connect };\n    }\n    else {\n        listeners = fn;\n    }\n    const hasConnectListener = typeof listeners.connect === 'function';\n    const hasSecureConnectListener = typeof listeners.secureConnect === 'function';\n    const hasCloseListener = typeof listeners.close === 'function';\n    const onConnect = () => {\n        if (hasConnectListener) {\n            listeners.connect();\n        }\n        if (isTLSSocket(socket) && hasSecureConnectListener) {\n            if (socket.authorized) {\n                listeners.secureConnect();\n            }\n            else if (!socket.authorizationError) {\n                socket.once('secureConnect', listeners.secureConnect);\n            }\n        }\n        if (hasCloseListener) {\n            socket.once('close', listeners.close);\n        }\n    };\n    if (socket.writable && !socket.connecting) {\n        onConnect();\n    }\n    else if (socket.connecting) {\n        socket.once('connect', onConnect);\n    }\n    else if (socket.destroyed && hasCloseListener) {\n        listeners.close(socket._hadError);\n    }\n};\nexports[\"default\"] = deferToConnect;\n// For CommonJS default export support\nmodule.exports = deferToConnect;\nmodule.exports[\"default\"] = deferToConnect;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/defer-to-connect/dist/source/index.js?\n}")},"./node_modules/ejson/index.js":module=>{eval("{/******/ (function() { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ (function(__unused_webpack_module, exports) {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.lengthOf = exports.keysOf = exports.isObject = exports.isInfOrNaN = exports.isFunction = exports.isArguments = exports.hasOwn = exports.handleError = exports.convertMapToObject = exports.checkError = void 0;\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== \"undefined\" && arr[Symbol.iterator] || arr[\"@@iterator\"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\nvar isFunction = function isFunction(fn) {\n  return typeof fn === 'function';\n};\n\nexports.isFunction = isFunction;\n\nvar isObject = function isObject(fn) {\n  return _typeof(fn) === 'object';\n};\n\nexports.isObject = isObject;\n\nvar keysOf = function keysOf(obj) {\n  return Object.keys(obj);\n};\n\nexports.keysOf = keysOf;\n\nvar lengthOf = function lengthOf(obj) {\n  return Object.keys(obj).length;\n};\n\nexports.lengthOf = lengthOf;\n\nvar hasOwn = function hasOwn(obj, prop) {\n  return Object.prototype.hasOwnProperty.call(obj, prop);\n};\n\nexports.hasOwn = hasOwn;\n\nvar convertMapToObject = function convertMapToObject(map) {\n  return Array.from(map).reduce(function (acc, _ref) {\n    var _ref2 = _slicedToArray(_ref, 2),\n        key = _ref2[0],\n        value = _ref2[1];\n\n    // reassign to not create new object\n    acc[key] = value;\n    return acc;\n  }, {});\n};\n\nexports.convertMapToObject = convertMapToObject;\n\nvar isArguments = function isArguments(obj) {\n  return obj != null && hasOwn(obj, 'callee');\n};\n\nexports.isArguments = isArguments;\n\nvar isInfOrNaN = function isInfOrNaN(obj) {\n  return Number.isNaN(obj) || obj === Infinity || obj === -Infinity;\n};\n\nexports.isInfOrNaN = isInfOrNaN;\nvar checkError = {\n  maxStack: function maxStack(msgError) {\n    return new RegExp('Maximum call stack size exceeded', 'g').test(msgError);\n  }\n};\nexports.checkError = checkError;\n\nvar handleError = function handleError(fn) {\n  return function () {\n    try {\n      return fn.apply(this, arguments);\n    } catch (error) {\n      var isMaxStack = checkError.maxStack(error.message);\n\n      if (isMaxStack) {\n        throw new Error('Converting circular structure to JSON');\n      }\n\n      throw error;\n    }\n  };\n};\n\nexports.handleError = handleError;\n\n/***/ }),\n/* 2 */\n/***/ (function(__unused_webpack_module, exports) {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Base64 = void 0;\n// Base 64 encoding\nvar BASE_64_CHARS = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\nvar BASE_64_VALS = Object.create(null);\n\nvar getChar = function getChar(val) {\n  return BASE_64_CHARS.charAt(val);\n};\n\nvar getVal = function getVal(ch) {\n  return ch === '=' ? -1 : BASE_64_VALS[ch];\n};\n\nfor (var i = 0; i < BASE_64_CHARS.length; i++) {\n  BASE_64_VALS[getChar(i)] = i;\n}\n\n;\n\nvar encode = function encode(array) {\n  if (typeof array === \"string\") {\n    var str = array;\n    array = newBinary(str.length);\n\n    for (var _i = 0; _i < str.length; _i++) {\n      var ch = str.charCodeAt(_i);\n\n      if (ch > 0xFF) {\n        throw new Error(\"Not ascii. Base64.encode can only take ascii strings.\");\n      }\n\n      array[_i] = ch;\n    }\n  }\n\n  var answer = [];\n  var a = null;\n  var b = null;\n  var c = null;\n  var d = null;\n\n  for (var _i2 = 0; _i2 < array.length; _i2++) {\n    switch (_i2 % 3) {\n      case 0:\n        a = array[_i2] >> 2 & 0x3F;\n        b = (array[_i2] & 0x03) << 4;\n        break;\n\n      case 1:\n        b = b | array[_i2] >> 4 & 0xF;\n        c = (array[_i2] & 0xF) << 2;\n        break;\n\n      case 2:\n        c = c | array[_i2] >> 6 & 0x03;\n        d = array[_i2] & 0x3F;\n        answer.push(getChar(a));\n        answer.push(getChar(b));\n        answer.push(getChar(c));\n        answer.push(getChar(d));\n        a = null;\n        b = null;\n        c = null;\n        d = null;\n        break;\n    }\n  }\n\n  if (a != null) {\n    answer.push(getChar(a));\n    answer.push(getChar(b));\n\n    if (c == null) {\n      answer.push('=');\n    } else {\n      answer.push(getChar(c));\n    }\n\n    if (d == null) {\n      answer.push('=');\n    }\n  }\n\n  return answer.join(\"\");\n}; // XXX This is a weird place for this to live, but it's used both by\n// this package and 'ejson', and we can't put it in 'ejson' without\n// introducing a circular dependency. It should probably be in its own\n// package or as a helper in a package that both 'base64' and 'ejson'\n// use.\n\n\nvar newBinary = function newBinary(len) {\n  if (typeof Uint8Array === 'undefined' || typeof ArrayBuffer === 'undefined') {\n    var ret = [];\n\n    for (var _i3 = 0; _i3 < len; _i3++) {\n      ret.push(0);\n    }\n\n    ret.$Uint8ArrayPolyfill = true;\n    return ret;\n  }\n\n  return new Uint8Array(new ArrayBuffer(len));\n};\n\nvar decode = function decode(str) {\n  var len = Math.floor(str.length * 3 / 4);\n\n  if (str.charAt(str.length - 1) == '=') {\n    len--;\n\n    if (str.charAt(str.length - 2) == '=') {\n      len--;\n    }\n  }\n\n  var arr = newBinary(len);\n  var one = null;\n  var two = null;\n  var three = null;\n  var j = 0;\n\n  for (var _i4 = 0; _i4 < str.length; _i4++) {\n    var c = str.charAt(_i4);\n    var v = getVal(c);\n\n    switch (_i4 % 4) {\n      case 0:\n        if (v < 0) {\n          throw new Error('invalid base64 string');\n        }\n\n        one = v << 2;\n        break;\n\n      case 1:\n        if (v < 0) {\n          throw new Error('invalid base64 string');\n        }\n\n        one = one | v >> 4;\n        arr[j++] = one;\n        two = (v & 0x0F) << 4;\n        break;\n\n      case 2:\n        if (v >= 0) {\n          two = two | v >> 2;\n          arr[j++] = two;\n          three = (v & 0x03) << 6;\n        }\n\n        break;\n\n      case 3:\n        if (v >= 0) {\n          arr[j++] = three | v;\n        }\n\n        break;\n    }\n  }\n\n  return arr;\n};\n\nvar Base64 = {\n  encode: encode,\n  decode: decode,\n  newBinary: newBinary\n};\nexports.Base64 = Base64;\n\n/***/ }),\n/* 3 */\n/***/ (function(module) {\n\n\n\nmodule.exports = {\n  //\n  // When fibers are not supported on you system Meteor automatically sets this\n  // function to a nope function. We're going to do the same here as there are\n  // small parts of the code that call this function.\n  //\n  _noYieldsAllowed: function _noYieldsAllowed(f) {\n    return f();\n  }\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports) {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports[\"default\"] = void 0;\n\nfunction _typeof(obj) { \"@babel/helpers - typeof\"; return _typeof = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && \"function\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }, _typeof(obj); }\n\n// Based on json2.js from https://github.com/douglascrockford/JSON-js\n//\n//    json2.js\n//    2012-10-08\n//\n//    Public Domain.\n//\n//    NO WARRANTY EXPRESSED OR IMPLIED. USE AT YOUR OWN RISK.\nfunction quote(string) {\n  return JSON.stringify(string);\n}\n\nvar str = function str(key, holder, singleIndent, outerIndent, canonical) {\n  var value = holder[key]; // What happens next depends on the value's type.\n\n  switch (_typeof(value)) {\n    case 'string':\n      return quote(value);\n\n    case 'number':\n      // JSON numbers must be finite. Encode non-finite numbers as null.\n      return isFinite(value) ? String(value) : 'null';\n\n    case 'boolean':\n      return String(value);\n    // If the type is 'object', we might be dealing with an object or an array or\n    // null.\n\n    case 'object':\n      {\n        // Due to a specification blunder in ECMAScript, typeof null is 'object',\n        // so watch out for that case.\n        if (!value) {\n          return 'null';\n        } // Make an array to hold the partial results of stringifying this object\n        // value.\n\n\n        var innerIndent = outerIndent + singleIndent;\n        var partial = [];\n        var v; // Is the value an array?\n\n        if (Array.isArray(value) || {}.hasOwnProperty.call(value, 'callee')) {\n          // The value is an array. Stringify every element. Use null as a\n          // placeholder for non-JSON values.\n          var length = value.length;\n\n          for (var i = 0; i < length; i += 1) {\n            partial[i] = str(i, value, singleIndent, innerIndent, canonical) || 'null';\n          } // Join all of the elements together, separated with commas, and wrap\n          // them in brackets.\n\n\n          if (partial.length === 0) {\n            v = '[]';\n          } else if (innerIndent) {\n            v = '[\\n' + innerIndent + partial.join(',\\n' + innerIndent) + '\\n' + outerIndent + ']';\n          } else {\n            v = '[' + partial.join(',') + ']';\n          }\n\n          return v;\n        } // Iterate through all of the keys in the object.\n\n\n        var keys = Object.keys(value);\n\n        if (canonical) {\n          keys = keys.sort();\n        }\n\n        keys.forEach(function (k) {\n          v = str(k, value, singleIndent, innerIndent, canonical);\n\n          if (v) {\n            partial.push(quote(k) + (innerIndent ? ': ' : ':') + v);\n          }\n        }); // Join all of the member texts together, separated with commas,\n        // and wrap them in braces.\n\n        if (partial.length === 0) {\n          v = '{}';\n        } else if (innerIndent) {\n          v = '{\\n' + innerIndent + partial.join(',\\n' + innerIndent) + '\\n' + outerIndent + '}';\n        } else {\n          v = '{' + partial.join(',') + '}';\n        }\n\n        return v;\n      }\n\n    default: // Do nothing\n\n  }\n}; // If the JSON object does not yet have a stringify method, give it one.\n\n\nvar canonicalStringify = function canonicalStringify(value, options) {\n  // Make a fake root object containing our value under the key of ''.\n  // Return the result of stringifying the value.\n  var allOptions = Object.assign({\n    indent: '',\n    canonical: false\n  }, options);\n\n  if (allOptions.indent === true) {\n    allOptions.indent = '  ';\n  } else if (typeof allOptions.indent === 'number') {\n    var newIndent = '';\n\n    for (var i = 0; i < allOptions.indent; i++) {\n      newIndent += ' ';\n    }\n\n    allOptions.indent = newIndent;\n  }\n\n  return str('', {\n    '': value\n  }, allOptions.indent, '', allOptions.canonical);\n};\n\nvar _default = canonicalStringify;\nexports[\"default\"] = _default;\nmodule.exports = exports.default;\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_12371__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId](module, module.exports, __nested_webpack_require_12371__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\nvar __nested_webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n!function() {\nvar exports = __nested_webpack_exports__;\n/* provided dependency */ var Base64 = __nested_webpack_require_12371__(2)[\"Base64\"];\n/* provided dependency */ var Meteor = __nested_webpack_require_12371__(3);\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.EJSON = void 0;\n\nvar _utils = __nested_webpack_require_12371__(1);\n\n/**\n * @namespace\n * @summary Namespace for EJSON functions\n */\nvar EJSON = {}; // Custom type interface definition\n\n/**\n * @class CustomType\n * @instanceName customType\n * @memberOf EJSON\n * @summary The interface that a class must satisfy to be able to become an\n * EJSON custom type via EJSON.addType.\n */\n\n/**\n * @function typeName\n * @memberOf EJSON.CustomType\n * @summary Return the tag used to identify this type.  This must match the\n *          tag used to register this type with\n *          [`EJSON.addType`](#ejson_add_type).\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function toJSONValue\n * @memberOf EJSON.CustomType\n * @summary Serialize this instance into a JSON-compatible value.\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function clone\n * @memberOf EJSON.CustomType\n * @summary Return a value `r` such that `this.equals(r)` is true, and\n *          modifications to `r` do not affect `this` and vice versa.\n * @locus Anywhere\n * @instance\n */\n\n/**\n * @function equals\n * @memberOf EJSON.CustomType\n * @summary Return `true` if `other` has a value equal to `this`; `false`\n *          otherwise.\n * @locus Anywhere\n * @param {Object} other Another object to compare this to.\n * @instance\n */\n\nexports.EJSON = EJSON;\nvar customTypes = new Map(); // Add a custom type, using a method of your choice to get to and\n// from a basic JSON-able representation.  The factory argument\n// is a function of JSON-able --\x3e your object\n// The type you add must have:\n// - A toJSONValue() method, so that Meteor can serialize it\n// - a typeName() method, to show how to look it up in our type table.\n// It is okay if these methods are monkey-patched on.\n// EJSON.clone will use toJSONValue and the given factory to produce\n// a clone, but you may specify a method clone() that will be\n// used instead.\n// Similarly, EJSON.equals will use toJSONValue to make comparisons,\n// but you may provide a method equals() instead.\n\n/**\n * @summary Add a custom datatype to EJSON.\n * @locus Anywhere\n * @param {String} name A tag for your custom type; must be unique among\n *                      custom data types defined in your project, and must\n *                      match the result of your type's `typeName` method.\n * @param {Function} factory A function that deserializes a JSON-compatible\n *                           value into an instance of your type.  This should\n *                           match the serialization performed by your\n *                           type's `toJSONValue` method.\n */\n\nEJSON.addType = function (name, factory) {\n  if (customTypes.has(name)) {\n    throw new Error(\"Type \".concat(name, \" already present\"));\n  }\n\n  customTypes.set(name, factory);\n};\n\nvar builtinConverters = [{\n  // Date\n  matchJSONValue: function matchJSONValue(obj) {\n    return (0, _utils.hasOwn)(obj, '$date') && (0, _utils.lengthOf)(obj) === 1;\n  },\n  matchObject: function matchObject(obj) {\n    return obj instanceof Date;\n  },\n  toJSONValue: function toJSONValue(obj) {\n    return {\n      $date: obj.getTime()\n    };\n  },\n  fromJSONValue: function fromJSONValue(obj) {\n    return new Date(obj.$date);\n  }\n}, {\n  // RegExp\n  matchJSONValue: function matchJSONValue(obj) {\n    return (0, _utils.hasOwn)(obj, '$regexp') && (0, _utils.hasOwn)(obj, '$flags') && (0, _utils.lengthOf)(obj) === 2;\n  },\n  matchObject: function matchObject(obj) {\n    return obj instanceof RegExp;\n  },\n  toJSONValue: function toJSONValue(regexp) {\n    return {\n      $regexp: regexp.source,\n      $flags: regexp.flags\n    };\n  },\n  fromJSONValue: function fromJSONValue(obj) {\n    // Replaces duplicate / invalid flags.\n    return new RegExp(obj.$regexp, obj.$flags // Cut off flags at 50 chars to avoid abusing RegExp for DOS.\n    .slice(0, 50).replace(/[^gimuy]/g, '').replace(/(.)(?=.*\\1)/g, ''));\n  }\n}, {\n  // NaN, Inf, -Inf. (These are the only objects with typeof !== 'object'\n  // which we match.)\n  matchJSONValue: function matchJSONValue(obj) {\n    return (0, _utils.hasOwn)(obj, '$InfNaN') && (0, _utils.lengthOf)(obj) === 1;\n  },\n  matchObject: _utils.isInfOrNaN,\n  toJSONValue: function toJSONValue(obj) {\n    var sign;\n\n    if (Number.isNaN(obj)) {\n      sign = 0;\n    } else if (obj === Infinity) {\n      sign = 1;\n    } else {\n      sign = -1;\n    }\n\n    return {\n      $InfNaN: sign\n    };\n  },\n  fromJSONValue: function fromJSONValue(obj) {\n    return obj.$InfNaN / 0;\n  }\n}, {\n  // Binary\n  matchJSONValue: function matchJSONValue(obj) {\n    return (0, _utils.hasOwn)(obj, '$binary') && (0, _utils.lengthOf)(obj) === 1;\n  },\n  matchObject: function matchObject(obj) {\n    return typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array || obj && (0, _utils.hasOwn)(obj, '$Uint8ArrayPolyfill');\n  },\n  toJSONValue: function toJSONValue(obj) {\n    return {\n      $binary: Base64.encode(obj)\n    };\n  },\n  fromJSONValue: function fromJSONValue(obj) {\n    return Base64.decode(obj.$binary);\n  }\n}, {\n  // Escaping one level\n  matchJSONValue: function matchJSONValue(obj) {\n    return (0, _utils.hasOwn)(obj, '$escape') && (0, _utils.lengthOf)(obj) === 1;\n  },\n  matchObject: function matchObject(obj) {\n    var match = false;\n\n    if (obj) {\n      var keyCount = (0, _utils.lengthOf)(obj);\n\n      if (keyCount === 1 || keyCount === 2) {\n        match = builtinConverters.some(function (converter) {\n          return converter.matchJSONValue(obj);\n        });\n      }\n    }\n\n    return match;\n  },\n  toJSONValue: function toJSONValue(obj) {\n    var newObj = {};\n    (0, _utils.keysOf)(obj).forEach(function (key) {\n      newObj[key] = EJSON.toJSONValue(obj[key]);\n    });\n    return {\n      $escape: newObj\n    };\n  },\n  fromJSONValue: function fromJSONValue(obj) {\n    var newObj = {};\n    (0, _utils.keysOf)(obj.$escape).forEach(function (key) {\n      newObj[key] = EJSON.fromJSONValue(obj.$escape[key]);\n    });\n    return newObj;\n  }\n}, {\n  // Custom\n  matchJSONValue: function matchJSONValue(obj) {\n    return (0, _utils.hasOwn)(obj, '$type') && (0, _utils.hasOwn)(obj, '$value') && (0, _utils.lengthOf)(obj) === 2;\n  },\n  matchObject: function matchObject(obj) {\n    return EJSON._isCustomType(obj);\n  },\n  toJSONValue: function toJSONValue(obj) {\n    var jsonValue = Meteor._noYieldsAllowed(function () {\n      return obj.toJSONValue();\n    });\n\n    return {\n      $type: obj.typeName(),\n      $value: jsonValue\n    };\n  },\n  fromJSONValue: function fromJSONValue(obj) {\n    var typeName = obj.$type;\n\n    if (!customTypes.has(typeName)) {\n      throw new Error(\"Custom EJSON type \".concat(typeName, \" is not defined\"));\n    }\n\n    var converter = customTypes.get(typeName);\n    return Meteor._noYieldsAllowed(function () {\n      return converter(obj.$value);\n    });\n  }\n}];\n\nEJSON._isCustomType = function (obj) {\n  return obj && (0, _utils.isFunction)(obj.toJSONValue) && (0, _utils.isFunction)(obj.typeName) && customTypes.has(obj.typeName());\n};\n\nEJSON._getTypes = function () {\n  var isOriginal = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  return isOriginal ? customTypes : (0, _utils.convertMapToObject)(customTypes);\n};\n\nEJSON._getConverters = function () {\n  return builtinConverters;\n}; // Either return the JSON-compatible version of the argument, or undefined (if\n// the item isn't itself replaceable, but maybe some fields in it are)\n\n\nvar toJSONValueHelper = function toJSONValueHelper(item) {\n  for (var i = 0; i < builtinConverters.length; i++) {\n    var converter = builtinConverters[i];\n\n    if (converter.matchObject(item)) {\n      return converter.toJSONValue(item);\n    }\n  }\n\n  return undefined;\n}; // for both arrays and objects, in-place modification.\n\n\nvar adjustTypesToJSONValue = function adjustTypesToJSONValue(obj) {\n  // Is it an atom that we need to adjust?\n  if (obj === null) {\n    return null;\n  }\n\n  var maybeChanged = toJSONValueHelper(obj);\n\n  if (maybeChanged !== undefined) {\n    return maybeChanged;\n  } // Other atoms are unchanged.\n\n\n  if (!(0, _utils.isObject)(obj)) {\n    return obj;\n  } // Iterate over array or object structure.\n\n\n  (0, _utils.keysOf)(obj).forEach(function (key) {\n    var value = obj[key];\n\n    if (!(0, _utils.isObject)(value) && value !== undefined && !(0, _utils.isInfOrNaN)(value)) {\n      return; // continue\n    }\n\n    var changed = toJSONValueHelper(value);\n\n    if (changed) {\n      obj[key] = changed;\n      return; // on to the next key\n    } // if we get here, value is an object but not adjustable\n    // at this level.  recurse.\n\n\n    adjustTypesToJSONValue(value);\n  });\n  return obj;\n};\n\nEJSON._adjustTypesToJSONValue = adjustTypesToJSONValue;\n/**\n * @summary Serialize an EJSON-compatible value into its plain JSON\n *          representation.\n * @locus Anywhere\n * @param {EJSON} val A value to serialize to plain JSON.\n */\n\nEJSON.toJSONValue = function (item) {\n  var changed = toJSONValueHelper(item);\n\n  if (changed !== undefined) {\n    return changed;\n  }\n\n  var newItem = item;\n\n  if ((0, _utils.isObject)(item)) {\n    newItem = EJSON.clone(item);\n    adjustTypesToJSONValue(newItem);\n  }\n\n  return newItem;\n}; // Either return the argument changed to have the non-json\n// rep of itself (the Object version) or the argument itself.\n// DOES NOT RECURSE.  For actually getting the fully-changed value, use\n// EJSON.fromJSONValue\n\n\nvar fromJSONValueHelper = function fromJSONValueHelper(value) {\n  if ((0, _utils.isObject)(value) && value !== null) {\n    var keys = (0, _utils.keysOf)(value);\n\n    if (keys.length <= 2 && keys.every(function (k) {\n      return typeof k === 'string' && k.substr(0, 1) === '$';\n    })) {\n      for (var i = 0; i < builtinConverters.length; i++) {\n        var converter = builtinConverters[i];\n\n        if (converter.matchJSONValue(value)) {\n          return converter.fromJSONValue(value);\n        }\n      }\n    }\n  }\n\n  return value;\n}; // for both arrays and objects. Tries its best to just\n// use the object you hand it, but may return something\n// different if the object you hand it itself needs changing.\n\n\nvar adjustTypesFromJSONValue = function adjustTypesFromJSONValue(obj) {\n  if (obj === null) {\n    return null;\n  }\n\n  var maybeChanged = fromJSONValueHelper(obj);\n\n  if (maybeChanged !== obj) {\n    return maybeChanged;\n  } // Other atoms are unchanged.\n\n\n  if (!(0, _utils.isObject)(obj)) {\n    return obj;\n  }\n\n  (0, _utils.keysOf)(obj).forEach(function (key) {\n    var value = obj[key];\n\n    if ((0, _utils.isObject)(value)) {\n      var changed = fromJSONValueHelper(value);\n\n      if (value !== changed) {\n        obj[key] = changed;\n        return;\n      } // if we get here, value is an object but not adjustable\n      // at this level.  recurse.\n\n\n      adjustTypesFromJSONValue(value);\n    }\n  });\n  return obj;\n};\n\nEJSON._adjustTypesFromJSONValue = adjustTypesFromJSONValue;\n/**\n * @summary Deserialize an EJSON value from its plain JSON representation.\n * @locus Anywhere\n * @param {JSONCompatible} val A value to deserialize into EJSON.\n */\n\nEJSON.fromJSONValue = function (item) {\n  var changed = fromJSONValueHelper(item);\n\n  if (changed === item && (0, _utils.isObject)(item)) {\n    changed = EJSON.clone(item);\n    adjustTypesFromJSONValue(changed);\n  }\n\n  return changed;\n};\n/**\n * @summary Serialize a value to a string. For EJSON values, the serialization\n *          fully represents the value. For non-EJSON values, serializes the\n *          same way as `JSON.stringify`.\n * @locus Anywhere\n * @param {EJSON} val A value to stringify.\n * @param {Object} [options]\n * @param {Boolean | Integer | String} options.indent Indents objects and\n * arrays for easy readability.  When `true`, indents by 2 spaces; when an\n * integer, indents by that number of spaces; and when a string, uses the\n * string as the indentation pattern.\n * @param {Boolean} options.canonical When `true`, stringifies keys in an\n *                                    object in sorted order.\n */\n\n\nEJSON.stringify = (0, _utils.handleError)(function (item, options) {\n  var serialized;\n  var json = EJSON.toJSONValue(item);\n\n  if (options && (options.canonical || options.indent)) {\n    var canonicalStringify = __nested_webpack_require_12371__(4);\n\n    serialized = canonicalStringify(json, options);\n  } else {\n    serialized = JSON.stringify(json);\n  }\n\n  return serialized;\n});\n/**\n * @summary Parse a string into an EJSON value. Throws an error if the string\n *          is not valid EJSON.\n * @locus Anywhere\n * @param {String} str A string to parse into an EJSON value.\n */\n\nEJSON.parse = function (item) {\n  if (typeof item !== 'string') {\n    throw new Error('EJSON.parse argument should be a string');\n  }\n\n  return EJSON.fromJSONValue(JSON.parse(item));\n};\n/**\n * @summary Returns true if `x` is a buffer of binary data, as returned from\n *          [`EJSON.newBinary`](#ejson_new_binary).\n * @param {Object} x The variable to check.\n * @locus Anywhere\n */\n\n\nEJSON.isBinary = function (obj) {\n  return !!(typeof Uint8Array !== 'undefined' && obj instanceof Uint8Array || obj && obj.$Uint8ArrayPolyfill);\n};\n/**\n * @summary Return true if `a` and `b` are equal to each other.  Return false\n *          otherwise.  Uses the `equals` method on `a` if present, otherwise\n *          performs a deep comparison.\n * @locus Anywhere\n * @param {EJSON} a\n * @param {EJSON} b\n * @param {Object} [options]\n * @param {Boolean} options.keyOrderSensitive Compare in key sensitive order,\n * if supported by the JavaScript implementation.  For example, `{a: 1, b: 2}`\n * is equal to `{b: 2, a: 1}` only when `keyOrderSensitive` is `false`.  The\n * default is `false`.\n */\n\n\nEJSON.equals = function (a, b, options) {\n  var i;\n  var keyOrderSensitive = !!(options && options.keyOrderSensitive);\n\n  if (a === b) {\n    return true;\n  } // This differs from the IEEE spec for NaN equality, b/c we don't want\n  // anything ever with a NaN to be poisoned from becoming equal to anything.\n\n\n  if (Number.isNaN(a) && Number.isNaN(b)) {\n    return true;\n  } // if either one is falsy, they'd have to be === to be equal\n\n\n  if (!a || !b) {\n    return false;\n  }\n\n  if (!((0, _utils.isObject)(a) && (0, _utils.isObject)(b))) {\n    return false;\n  }\n\n  if (a instanceof Date && b instanceof Date) {\n    return a.valueOf() === b.valueOf();\n  }\n\n  if (EJSON.isBinary(a) && EJSON.isBinary(b)) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (i = 0; i < a.length; i++) {\n      if (a[i] !== b[i]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  if ((0, _utils.isFunction)(a.equals)) {\n    return a.equals(b, options);\n  }\n\n  if ((0, _utils.isFunction)(b.equals)) {\n    return b.equals(a, options);\n  } // Array.isArray works across iframes while instanceof won't\n\n\n  var aIsArray = Array.isArray(a);\n  var bIsArray = Array.isArray(b); // if not both or none are array they are not equal\n\n  if (aIsArray !== bIsArray) {\n    return false;\n  }\n\n  if (aIsArray && bIsArray) {\n    if (a.length !== b.length) {\n      return false;\n    }\n\n    for (i = 0; i < a.length; i++) {\n      if (!EJSON.equals(a[i], b[i], options)) {\n        return false;\n      }\n    }\n\n    return true;\n  } // fallback for custom types that don't implement their own equals\n\n\n  switch (EJSON._isCustomType(a) + EJSON._isCustomType(b)) {\n    case 1:\n      return false;\n\n    case 2:\n      return EJSON.equals(EJSON.toJSONValue(a), EJSON.toJSONValue(b));\n\n    default: // Do nothing\n\n  } // fall back to structural equality of objects\n\n\n  var ret;\n  var aKeys = (0, _utils.keysOf)(a);\n  var bKeys = (0, _utils.keysOf)(b);\n\n  if (keyOrderSensitive) {\n    i = 0;\n    ret = aKeys.every(function (key) {\n      if (i >= bKeys.length) {\n        return false;\n      }\n\n      if (key !== bKeys[i]) {\n        return false;\n      }\n\n      if (!EJSON.equals(a[key], b[bKeys[i]], options)) {\n        return false;\n      }\n\n      i++;\n      return true;\n    });\n  } else {\n    i = 0;\n    ret = aKeys.every(function (key) {\n      if (!(0, _utils.hasOwn)(b, key)) {\n        return false;\n      }\n\n      if (!EJSON.equals(a[key], b[key], options)) {\n        return false;\n      }\n\n      i++;\n      return true;\n    });\n  }\n\n  return ret && i === bKeys.length;\n};\n/**\n * @summary Return a deep copy of `val`.\n * @locus Anywhere\n * @param {EJSON} val A value to copy.\n */\n\n\nEJSON.clone = function (v) {\n  var ret;\n\n  if (!(0, _utils.isObject)(v)) {\n    return v;\n  }\n\n  if (v === null) {\n    return null; // null has typeof \"object\"\n  }\n\n  if (v instanceof Date) {\n    return new Date(v.getTime());\n  } // RegExps are not really EJSON elements (eg we don't define a serialization\n  // for them), but they're immutable anyway, so we can support them in clone.\n\n\n  if (v instanceof RegExp) {\n    return v;\n  }\n\n  if (EJSON.isBinary(v)) {\n    ret = EJSON.newBinary(v.length);\n\n    for (var i = 0; i < v.length; i++) {\n      ret[i] = v[i];\n    }\n\n    return ret;\n  }\n\n  if (Array.isArray(v)) {\n    return v.map(EJSON.clone);\n  }\n\n  if ((0, _utils.isArguments)(v)) {\n    return Array.from(v).map(EJSON.clone);\n  } // handle general user-defined typed Objects if they have a clone method\n\n\n  if ((0, _utils.isFunction)(v.clone)) {\n    return v.clone();\n  } // handle other custom types\n\n\n  if (EJSON._isCustomType(v)) {\n    return EJSON.fromJSONValue(EJSON.clone(EJSON.toJSONValue(v)), true);\n  } // handle other objects\n\n\n  ret = {};\n  (0, _utils.keysOf)(v).forEach(function (key) {\n    ret[key] = EJSON.clone(v[key]);\n  });\n  return ret;\n};\n/**\n * @summary Allocate a new buffer of binary data that EJSON can serialize.\n * @locus Anywhere\n * @param {Number} size The number of bytes of binary data to allocate.\n */\n// EJSON.newBinary is the public documented API for this functionality,\n// but the implementation is in the 'base64' package to avoid\n// introducing a circular dependency. (If the implementation were here,\n// then 'base64' would have to use EJSON.newBinary, and 'ejson' would\n// also have to use 'base64'.)\n\n\nEJSON.newBinary = Base64.newBinary;\n}();\nmodule.exports = __nested_webpack_exports__.EJSON;\n/******/ })()\n;\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/ejson/index.js?\n}")},"./node_modules/end-of-stream/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("{var once = __webpack_require__(/*! once */ \"./node_modules/once/once.js\");\n\nvar noop = function() {};\n\nvar qnt = global.Bare ? queueMicrotask : process.nextTick.bind(process);\n\nvar isRequest = function(stream) {\n\treturn stream.setHeader && typeof stream.abort === 'function';\n};\n\nvar isChildProcess = function(stream) {\n\treturn stream.stdio && Array.isArray(stream.stdio) && stream.stdio.length === 3\n};\n\nvar eos = function(stream, opts, callback) {\n\tif (typeof opts === 'function') return eos(stream, null, opts);\n\tif (!opts) opts = {};\n\n\tcallback = once(callback || noop);\n\n\tvar ws = stream._writableState;\n\tvar rs = stream._readableState;\n\tvar readable = opts.readable || (opts.readable !== false && stream.readable);\n\tvar writable = opts.writable || (opts.writable !== false && stream.writable);\n\tvar cancelled = false;\n\n\tvar onlegacyfinish = function() {\n\t\tif (!stream.writable) onfinish();\n\t};\n\n\tvar onfinish = function() {\n\t\twritable = false;\n\t\tif (!readable) callback.call(stream);\n\t};\n\n\tvar onend = function() {\n\t\treadable = false;\n\t\tif (!writable) callback.call(stream);\n\t};\n\n\tvar onexit = function(exitCode) {\n\t\tcallback.call(stream, exitCode ? new Error('exited with error code: ' + exitCode) : null);\n\t};\n\n\tvar onerror = function(err) {\n\t\tcallback.call(stream, err);\n\t};\n\n\tvar onclose = function() {\n\t\tqnt(onclosenexttick);\n\t};\n\n\tvar onclosenexttick = function() {\n\t\tif (cancelled) return;\n\t\tif (readable && !(rs && (rs.ended && !rs.destroyed))) return callback.call(stream, new Error('premature close'));\n\t\tif (writable && !(ws && (ws.ended && !ws.destroyed))) return callback.call(stream, new Error('premature close'));\n\t};\n\n\tvar onrequest = function() {\n\t\tstream.req.on('finish', onfinish);\n\t};\n\n\tif (isRequest(stream)) {\n\t\tstream.on('complete', onfinish);\n\t\tstream.on('abort', onclose);\n\t\tif (stream.req) onrequest();\n\t\telse stream.on('request', onrequest);\n\t} else if (writable && !ws) { // legacy streams\n\t\tstream.on('end', onlegacyfinish);\n\t\tstream.on('close', onlegacyfinish);\n\t}\n\n\tif (isChildProcess(stream)) stream.on('exit', onexit);\n\n\tstream.on('end', onend);\n\tstream.on('finish', onfinish);\n\tif (opts.error !== false) stream.on('error', onerror);\n\tstream.on('close', onclose);\n\n\treturn function() {\n\t\tcancelled = true;\n\t\tstream.removeListener('complete', onfinish);\n\t\tstream.removeListener('abort', onclose);\n\t\tstream.removeListener('request', onrequest);\n\t\tif (stream.req) stream.req.removeListener('finish', onfinish);\n\t\tstream.removeListener('end', onlegacyfinish);\n\t\tstream.removeListener('close', onlegacyfinish);\n\t\tstream.removeListener('finish', onfinish);\n\t\tstream.removeListener('exit', onexit);\n\t\tstream.removeListener('end', onend);\n\t\tstream.removeListener('error', onerror);\n\t\tstream.removeListener('close', onclose);\n\t};\n};\n\nmodule.exports = eos;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/end-of-stream/index.js?\n}")},"./node_modules/eventemitter3/index.js":module=>{"use strict";eval("{\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/eventemitter3/index.js?\n}")},"./node_modules/fast-deep-equal/index.js":module=>{"use strict";eval("{\n\n// do not edit .js files directly - edit src/index.jst\n\n\n\nmodule.exports = function equal(a, b) {\n  if (a === b) return true;\n\n  if (a && b && typeof a == 'object' && typeof b == 'object') {\n    if (a.constructor !== b.constructor) return false;\n\n    var length, i, keys;\n    if (Array.isArray(a)) {\n      length = a.length;\n      if (length != b.length) return false;\n      for (i = length; i-- !== 0;)\n        if (!equal(a[i], b[i])) return false;\n      return true;\n    }\n\n\n\n    if (a.constructor === RegExp) return a.source === b.source && a.flags === b.flags;\n    if (a.valueOf !== Object.prototype.valueOf) return a.valueOf() === b.valueOf();\n    if (a.toString !== Object.prototype.toString) return a.toString() === b.toString();\n\n    keys = Object.keys(a);\n    length = keys.length;\n    if (length !== Object.keys(b).length) return false;\n\n    for (i = length; i-- !== 0;)\n      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;\n\n    for (i = length; i-- !== 0;) {\n      var key = keys[i];\n\n      if (!equal(a[key], b[key])) return false;\n    }\n\n    return true;\n  }\n\n  // true if both NaN, false otherwise\n  return a!==a && b!==b;\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/fast-deep-equal/index.js?\n}")},"./node_modules/get-stream/buffer-stream.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{\nconst {PassThrough: PassThroughStream} = __webpack_require__(/*! stream */ \"stream\");\n\nmodule.exports = options => {\n\toptions = {...options};\n\n\tconst {array} = options;\n\tlet {encoding} = options;\n\tconst isBuffer = encoding === 'buffer';\n\tlet objectMode = false;\n\n\tif (array) {\n\t\tobjectMode = !(encoding || isBuffer);\n\t} else {\n\t\tencoding = encoding || 'utf8';\n\t}\n\n\tif (isBuffer) {\n\t\tencoding = null;\n\t}\n\n\tconst stream = new PassThroughStream({objectMode});\n\n\tif (encoding) {\n\t\tstream.setEncoding(encoding);\n\t}\n\n\tlet length = 0;\n\tconst chunks = [];\n\n\tstream.on('data', chunk => {\n\t\tchunks.push(chunk);\n\n\t\tif (objectMode) {\n\t\t\tlength = chunks.length;\n\t\t} else {\n\t\t\tlength += chunk.length;\n\t\t}\n\t});\n\n\tstream.getBufferedValue = () => {\n\t\tif (array) {\n\t\t\treturn chunks;\n\t\t}\n\n\t\treturn isBuffer ? Buffer.concat(chunks, length) : chunks.join('');\n\t};\n\n\tstream.getBufferedLength = () => length;\n\n\treturn stream;\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/get-stream/buffer-stream.js?\n}")},"./node_modules/get-stream/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{\nconst {constants: BufferConstants} = __webpack_require__(/*! buffer */ \"buffer\");\nconst pump = __webpack_require__(/*! pump */ \"./node_modules/pump/index.js\");\nconst bufferStream = __webpack_require__(/*! ./buffer-stream */ \"./node_modules/get-stream/buffer-stream.js\");\n\nclass MaxBufferError extends Error {\n\tconstructor() {\n\t\tsuper('maxBuffer exceeded');\n\t\tthis.name = 'MaxBufferError';\n\t}\n}\n\nasync function getStream(inputStream, options) {\n\tif (!inputStream) {\n\t\treturn Promise.reject(new Error('Expected a stream'));\n\t}\n\n\toptions = {\n\t\tmaxBuffer: Infinity,\n\t\t...options\n\t};\n\n\tconst {maxBuffer} = options;\n\n\tlet stream;\n\tawait new Promise((resolve, reject) => {\n\t\tconst rejectPromise = error => {\n\t\t\t// Don't retrieve an oversized buffer.\n\t\t\tif (error && stream.getBufferedLength() <= BufferConstants.MAX_LENGTH) {\n\t\t\t\terror.bufferedData = stream.getBufferedValue();\n\t\t\t}\n\n\t\t\treject(error);\n\t\t};\n\n\t\tstream = pump(inputStream, bufferStream(options), error => {\n\t\t\tif (error) {\n\t\t\t\trejectPromise(error);\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolve();\n\t\t});\n\n\t\tstream.on('data', () => {\n\t\t\tif (stream.getBufferedLength() > maxBuffer) {\n\t\t\t\trejectPromise(new MaxBufferError());\n\t\t\t}\n\t\t});\n\t});\n\n\treturn stream.getBufferedValue();\n}\n\nmodule.exports = getStream;\n// TODO: Remove this for the next major release\nmodule.exports[\"default\"] = getStream;\nmodule.exports.buffer = (stream, options) => getStream(stream, {...options, encoding: 'buffer'});\nmodule.exports.array = (stream, options) => getStream(stream, {...options, array: true});\nmodule.exports.MaxBufferError = MaxBufferError;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/get-stream/index.js?\n}")},"./node_modules/got/dist/source/as-promise/create-rejection.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst types_1 = __webpack_require__(/*! ./types */ "./node_modules/got/dist/source/as-promise/types.js");\nfunction createRejection(error, ...beforeErrorGroups) {\n    const promise = (async () => {\n        if (error instanceof types_1.RequestError) {\n            try {\n                for (const hooks of beforeErrorGroups) {\n                    if (hooks) {\n                        for (const hook of hooks) {\n                            // eslint-disable-next-line no-await-in-loop\n                            error = await hook(error);\n                        }\n                    }\n                }\n            }\n            catch (error_) {\n                error = error_;\n            }\n        }\n        throw error;\n    })();\n    const returnPromise = () => promise;\n    promise.json = returnPromise;\n    promise.text = returnPromise;\n    promise.buffer = returnPromise;\n    promise.on = returnPromise;\n    return promise;\n}\nexports["default"] = createRejection;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/as-promise/create-rejection.js?\n}')},"./node_modules/got/dist/source/as-promise/index.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst events_1 = __webpack_require__(/*! events */ \"events\");\nconst is_1 = __webpack_require__(/*! @sindresorhus/is */ \"./node_modules/@sindresorhus/is/dist/index.js\");\nconst PCancelable = __webpack_require__(/*! p-cancelable */ \"./node_modules/p-cancelable/index.js\");\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/got/dist/source/as-promise/types.js\");\nconst parse_body_1 = __webpack_require__(/*! ./parse-body */ \"./node_modules/got/dist/source/as-promise/parse-body.js\");\nconst core_1 = __webpack_require__(/*! ../core */ \"./node_modules/got/dist/source/core/index.js\");\nconst proxy_events_1 = __webpack_require__(/*! ../core/utils/proxy-events */ \"./node_modules/got/dist/source/core/utils/proxy-events.js\");\nconst get_buffer_1 = __webpack_require__(/*! ../core/utils/get-buffer */ \"./node_modules/got/dist/source/core/utils/get-buffer.js\");\nconst is_response_ok_1 = __webpack_require__(/*! ../core/utils/is-response-ok */ \"./node_modules/got/dist/source/core/utils/is-response-ok.js\");\nconst proxiedRequestEvents = [\n    'request',\n    'response',\n    'redirect',\n    'uploadProgress',\n    'downloadProgress'\n];\nfunction asPromise(normalizedOptions) {\n    let globalRequest;\n    let globalResponse;\n    const emitter = new events_1.EventEmitter();\n    const promise = new PCancelable((resolve, reject, onCancel) => {\n        const makeRequest = (retryCount) => {\n            const request = new core_1.default(undefined, normalizedOptions);\n            request.retryCount = retryCount;\n            request._noPipe = true;\n            onCancel(() => request.destroy());\n            onCancel.shouldReject = false;\n            onCancel(() => reject(new types_1.CancelError(request)));\n            globalRequest = request;\n            request.once('response', async (response) => {\n                var _a;\n                response.retryCount = retryCount;\n                if (response.request.aborted) {\n                    // Canceled while downloading - will throw a `CancelError` or `TimeoutError` error\n                    return;\n                }\n                // Download body\n                let rawBody;\n                try {\n                    rawBody = await get_buffer_1.default(request);\n                    response.rawBody = rawBody;\n                }\n                catch (_b) {\n                    // The same error is caught below.\n                    // See request.once('error')\n                    return;\n                }\n                if (request._isAboutToError) {\n                    return;\n                }\n                // Parse body\n                const contentEncoding = ((_a = response.headers['content-encoding']) !== null && _a !== void 0 ? _a : '').toLowerCase();\n                const isCompressed = ['gzip', 'deflate', 'br'].includes(contentEncoding);\n                const { options } = request;\n                if (isCompressed && !options.decompress) {\n                    response.body = rawBody;\n                }\n                else {\n                    try {\n                        response.body = parse_body_1.default(response, options.responseType, options.parseJson, options.encoding);\n                    }\n                    catch (error) {\n                        // Fallback to `utf8`\n                        response.body = rawBody.toString();\n                        if (is_response_ok_1.isResponseOk(response)) {\n                            request._beforeError(error);\n                            return;\n                        }\n                    }\n                }\n                try {\n                    for (const [index, hook] of options.hooks.afterResponse.entries()) {\n                        // @ts-expect-error TS doesn't notice that CancelableRequest is a Promise\n                        // eslint-disable-next-line no-await-in-loop\n                        response = await hook(response, async (updatedOptions) => {\n                            const typedOptions = core_1.default.normalizeArguments(undefined, {\n                                ...updatedOptions,\n                                retry: {\n                                    calculateDelay: () => 0\n                                },\n                                throwHttpErrors: false,\n                                resolveBodyOnly: false\n                            }, options);\n                            // Remove any further hooks for that request, because we'll call them anyway.\n                            // The loop continues. We don't want duplicates (asPromise recursion).\n                            typedOptions.hooks.afterResponse = typedOptions.hooks.afterResponse.slice(0, index);\n                            for (const hook of typedOptions.hooks.beforeRetry) {\n                                // eslint-disable-next-line no-await-in-loop\n                                await hook(typedOptions);\n                            }\n                            const promise = asPromise(typedOptions);\n                            onCancel(() => {\n                                promise.catch(() => { });\n                                promise.cancel();\n                            });\n                            return promise;\n                        });\n                    }\n                }\n                catch (error) {\n                    request._beforeError(new types_1.RequestError(error.message, error, request));\n                    return;\n                }\n                globalResponse = response;\n                if (!is_response_ok_1.isResponseOk(response)) {\n                    request._beforeError(new types_1.HTTPError(response));\n                    return;\n                }\n                request.destroy();\n                resolve(request.options.resolveBodyOnly ? response.body : response);\n            });\n            const onError = (error) => {\n                if (promise.isCanceled) {\n                    return;\n                }\n                const { options } = request;\n                if (error instanceof types_1.HTTPError && !options.throwHttpErrors) {\n                    const { response } = error;\n                    resolve(request.options.resolveBodyOnly ? response.body : response);\n                    return;\n                }\n                reject(error);\n            };\n            request.once('error', onError);\n            const previousBody = request.options.body;\n            request.once('retry', (newRetryCount, error) => {\n                var _a, _b;\n                if (previousBody === ((_a = error.request) === null || _a === void 0 ? void 0 : _a.options.body) && is_1.default.nodeStream((_b = error.request) === null || _b === void 0 ? void 0 : _b.options.body)) {\n                    onError(error);\n                    return;\n                }\n                makeRequest(newRetryCount);\n            });\n            proxy_events_1.default(request, emitter, proxiedRequestEvents);\n        };\n        makeRequest(0);\n    });\n    promise.on = (event, fn) => {\n        emitter.on(event, fn);\n        return promise;\n    };\n    const shortcut = (responseType) => {\n        const newPromise = (async () => {\n            // Wait until downloading has ended\n            await promise;\n            const { options } = globalResponse.request;\n            return parse_body_1.default(globalResponse, responseType, options.parseJson, options.encoding);\n        })();\n        Object.defineProperties(newPromise, Object.getOwnPropertyDescriptors(promise));\n        return newPromise;\n    };\n    promise.json = () => {\n        const { headers } = globalRequest.options;\n        if (!globalRequest.writableFinished && headers.accept === undefined) {\n            headers.accept = 'application/json';\n        }\n        return shortcut('json');\n    };\n    promise.buffer = () => shortcut('buffer');\n    promise.text = () => shortcut('text');\n    return promise;\n}\nexports[\"default\"] = asPromise;\n__exportStar(__webpack_require__(/*! ./types */ \"./node_modules/got/dist/source/as-promise/types.js\"), exports);\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/as-promise/index.js?\n}")},"./node_modules/got/dist/source/as-promise/normalize-arguments.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst is_1 = __webpack_require__(/*! @sindresorhus/is */ \"./node_modules/@sindresorhus/is/dist/index.js\");\nconst normalizeArguments = (options, defaults) => {\n    if (is_1.default.null_(options.encoding)) {\n        throw new TypeError('To get a Buffer, set `options.responseType` to `buffer` instead');\n    }\n    is_1.assert.any([is_1.default.string, is_1.default.undefined], options.encoding);\n    is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.resolveBodyOnly);\n    is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.methodRewriting);\n    is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.isStream);\n    is_1.assert.any([is_1.default.string, is_1.default.undefined], options.responseType);\n    // `options.responseType`\n    if (options.responseType === undefined) {\n        options.responseType = 'text';\n    }\n    // `options.retry`\n    const { retry } = options;\n    if (defaults) {\n        options.retry = { ...defaults.retry };\n    }\n    else {\n        options.retry = {\n            calculateDelay: retryObject => retryObject.computedValue,\n            limit: 0,\n            methods: [],\n            statusCodes: [],\n            errorCodes: [],\n            maxRetryAfter: undefined\n        };\n    }\n    if (is_1.default.object(retry)) {\n        options.retry = {\n            ...options.retry,\n            ...retry\n        };\n        options.retry.methods = [...new Set(options.retry.methods.map(method => method.toUpperCase()))];\n        options.retry.statusCodes = [...new Set(options.retry.statusCodes)];\n        options.retry.errorCodes = [...new Set(options.retry.errorCodes)];\n    }\n    else if (is_1.default.number(retry)) {\n        options.retry.limit = retry;\n    }\n    if (is_1.default.undefined(options.retry.maxRetryAfter)) {\n        options.retry.maxRetryAfter = Math.min(\n        // TypeScript is not smart enough to handle `.filter(x => is.number(x))`.\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        ...[options.timeout.request, options.timeout.connect].filter(is_1.default.number));\n    }\n    // `options.pagination`\n    if (is_1.default.object(options.pagination)) {\n        if (defaults) {\n            options.pagination = {\n                ...defaults.pagination,\n                ...options.pagination\n            };\n        }\n        const { pagination } = options;\n        if (!is_1.default.function_(pagination.transform)) {\n            throw new Error('`options.pagination.transform` must be implemented');\n        }\n        if (!is_1.default.function_(pagination.shouldContinue)) {\n            throw new Error('`options.pagination.shouldContinue` must be implemented');\n        }\n        if (!is_1.default.function_(pagination.filter)) {\n            throw new TypeError('`options.pagination.filter` must be implemented');\n        }\n        if (!is_1.default.function_(pagination.paginate)) {\n            throw new Error('`options.pagination.paginate` must be implemented');\n        }\n    }\n    // JSON mode\n    if (options.responseType === 'json' && options.headers.accept === undefined) {\n        options.headers.accept = 'application/json';\n    }\n    return options;\n};\nexports[\"default\"] = normalizeArguments;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/as-promise/normalize-arguments.js?\n}")},"./node_modules/got/dist/source/as-promise/parse-body.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst types_1 = __webpack_require__(/*! ./types */ \"./node_modules/got/dist/source/as-promise/types.js\");\nconst parseBody = (response, responseType, parseJson, encoding) => {\n    const { rawBody } = response;\n    try {\n        if (responseType === 'text') {\n            return rawBody.toString(encoding);\n        }\n        if (responseType === 'json') {\n            return rawBody.length === 0 ? '' : parseJson(rawBody.toString());\n        }\n        if (responseType === 'buffer') {\n            return rawBody;\n        }\n        throw new types_1.ParseError({\n            message: `Unknown body type '${responseType}'`,\n            name: 'Error'\n        }, response);\n    }\n    catch (error) {\n        throw new types_1.ParseError(error, response);\n    }\n};\nexports[\"default\"] = parseBody;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/as-promise/parse-body.js?\n}")},"./node_modules/got/dist/source/as-promise/types.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.CancelError = exports.ParseError = void 0;\nconst core_1 = __webpack_require__(/*! ../core */ \"./node_modules/got/dist/source/core/index.js\");\n/**\nAn error to be thrown when server response code is 2xx, and parsing body fails.\nIncludes a `response` property.\n*/\nclass ParseError extends core_1.RequestError {\n    constructor(error, response) {\n        const { options } = response.request;\n        super(`${error.message} in \"${options.url.toString()}\"`, error, response.request);\n        this.name = 'ParseError';\n        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_BODY_PARSE_FAILURE' : this.code;\n    }\n}\nexports.ParseError = ParseError;\n/**\nAn error to be thrown when the request is aborted with `.cancel()`.\n*/\nclass CancelError extends core_1.RequestError {\n    constructor(request) {\n        super('Promise was canceled', {}, request);\n        this.name = 'CancelError';\n        this.code = 'ERR_CANCELED';\n    }\n    get isCanceled() {\n        return true;\n    }\n}\nexports.CancelError = CancelError;\n__exportStar(__webpack_require__(/*! ../core */ \"./node_modules/got/dist/source/core/index.js\"), exports);\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/as-promise/types.js?\n}")},"./node_modules/got/dist/source/core/calculate-retry-delay.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.retryAfterStatusCodes = void 0;\nexports.retryAfterStatusCodes = new Set([413, 429, 503]);\nconst calculateRetryDelay = ({ attemptCount, retryOptions, error, retryAfter }) => {\n    if (attemptCount > retryOptions.limit) {\n        return 0;\n    }\n    const hasMethod = retryOptions.methods.includes(error.options.method);\n    const hasErrorCode = retryOptions.errorCodes.includes(error.code);\n    const hasStatusCode = error.response && retryOptions.statusCodes.includes(error.response.statusCode);\n    if (!hasMethod || (!hasErrorCode && !hasStatusCode)) {\n        return 0;\n    }\n    if (error.response) {\n        if (retryAfter) {\n            if (retryOptions.maxRetryAfter === undefined || retryAfter > retryOptions.maxRetryAfter) {\n                return 0;\n            }\n            return retryAfter;\n        }\n        if (error.response.statusCode === 413) {\n            return 0;\n        }\n    }\n    const noise = Math.random() * 100;\n    return ((2 ** (attemptCount - 1)) * 1000) + noise;\n};\nexports["default"] = calculateRetryDelay;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/core/calculate-retry-delay.js?\n}')},"./node_modules/got/dist/source/core/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.UnsupportedProtocolError = exports.ReadError = exports.TimeoutError = exports.UploadError = exports.CacheError = exports.HTTPError = exports.MaxRedirectsError = exports.RequestError = exports.setNonEnumerableProperties = exports.knownHookEvents = exports.withoutBody = exports.kIsNormalizedAlready = void 0;\nconst util_1 = __webpack_require__(/*! util */ \"util\");\nconst stream_1 = __webpack_require__(/*! stream */ \"stream\");\nconst fs_1 = __webpack_require__(/*! fs */ \"fs\");\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst http = __webpack_require__(/*! http */ \"http\");\nconst http_1 = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst http_timer_1 = __webpack_require__(/*! @szmarczak/http-timer */ \"./node_modules/@szmarczak/http-timer/dist/source/index.js\");\nconst cacheable_lookup_1 = __webpack_require__(/*! cacheable-lookup */ \"./node_modules/cacheable-lookup/source/index.js\");\nconst CacheableRequest = __webpack_require__(/*! cacheable-request */ \"./node_modules/cacheable-request/src/index.js\");\nconst decompressResponse = __webpack_require__(/*! decompress-response */ \"./node_modules/decompress-response/index.js\");\n// @ts-expect-error Missing types\nconst http2wrapper = __webpack_require__(/*! http2-wrapper */ \"./node_modules/http2-wrapper/source/index.js\");\nconst lowercaseKeys = __webpack_require__(/*! lowercase-keys */ \"./node_modules/lowercase-keys/index.js\");\nconst is_1 = __webpack_require__(/*! @sindresorhus/is */ \"./node_modules/@sindresorhus/is/dist/index.js\");\nconst get_body_size_1 = __webpack_require__(/*! ./utils/get-body-size */ \"./node_modules/got/dist/source/core/utils/get-body-size.js\");\nconst is_form_data_1 = __webpack_require__(/*! ./utils/is-form-data */ \"./node_modules/got/dist/source/core/utils/is-form-data.js\");\nconst proxy_events_1 = __webpack_require__(/*! ./utils/proxy-events */ \"./node_modules/got/dist/source/core/utils/proxy-events.js\");\nconst timed_out_1 = __webpack_require__(/*! ./utils/timed-out */ \"./node_modules/got/dist/source/core/utils/timed-out.js\");\nconst url_to_options_1 = __webpack_require__(/*! ./utils/url-to-options */ \"./node_modules/got/dist/source/core/utils/url-to-options.js\");\nconst options_to_url_1 = __webpack_require__(/*! ./utils/options-to-url */ \"./node_modules/got/dist/source/core/utils/options-to-url.js\");\nconst weakable_map_1 = __webpack_require__(/*! ./utils/weakable-map */ \"./node_modules/got/dist/source/core/utils/weakable-map.js\");\nconst get_buffer_1 = __webpack_require__(/*! ./utils/get-buffer */ \"./node_modules/got/dist/source/core/utils/get-buffer.js\");\nconst dns_ip_version_1 = __webpack_require__(/*! ./utils/dns-ip-version */ \"./node_modules/got/dist/source/core/utils/dns-ip-version.js\");\nconst is_response_ok_1 = __webpack_require__(/*! ./utils/is-response-ok */ \"./node_modules/got/dist/source/core/utils/is-response-ok.js\");\nconst deprecation_warning_1 = __webpack_require__(/*! ../utils/deprecation-warning */ \"./node_modules/got/dist/source/utils/deprecation-warning.js\");\nconst normalize_arguments_1 = __webpack_require__(/*! ../as-promise/normalize-arguments */ \"./node_modules/got/dist/source/as-promise/normalize-arguments.js\");\nconst calculate_retry_delay_1 = __webpack_require__(/*! ./calculate-retry-delay */ \"./node_modules/got/dist/source/core/calculate-retry-delay.js\");\nlet globalDnsCache;\nconst kRequest = Symbol('request');\nconst kResponse = Symbol('response');\nconst kResponseSize = Symbol('responseSize');\nconst kDownloadedSize = Symbol('downloadedSize');\nconst kBodySize = Symbol('bodySize');\nconst kUploadedSize = Symbol('uploadedSize');\nconst kServerResponsesPiped = Symbol('serverResponsesPiped');\nconst kUnproxyEvents = Symbol('unproxyEvents');\nconst kIsFromCache = Symbol('isFromCache');\nconst kCancelTimeouts = Symbol('cancelTimeouts');\nconst kStartedReading = Symbol('startedReading');\nconst kStopReading = Symbol('stopReading');\nconst kTriggerRead = Symbol('triggerRead');\nconst kBody = Symbol('body');\nconst kJobs = Symbol('jobs');\nconst kOriginalResponse = Symbol('originalResponse');\nconst kRetryTimeout = Symbol('retryTimeout');\nexports.kIsNormalizedAlready = Symbol('isNormalizedAlready');\nconst supportsBrotli = is_1.default.string(process.versions.brotli);\nexports.withoutBody = new Set(['GET', 'HEAD']);\nexports.knownHookEvents = [\n    'init',\n    'beforeRequest',\n    'beforeRedirect',\n    'beforeError',\n    'beforeRetry',\n    // Promise-Only\n    'afterResponse'\n];\nfunction validateSearchParameters(searchParameters) {\n    // eslint-disable-next-line guard-for-in\n    for (const key in searchParameters) {\n        const value = searchParameters[key];\n        if (!is_1.default.string(value) && !is_1.default.number(value) && !is_1.default.boolean(value) && !is_1.default.null_(value) && !is_1.default.undefined(value)) {\n            throw new TypeError(`The \\`searchParams\\` value '${String(value)}' must be a string, number, boolean or null`);\n        }\n    }\n}\nfunction isClientRequest(clientRequest) {\n    return is_1.default.object(clientRequest) && !('statusCode' in clientRequest);\n}\nconst cacheableStore = new weakable_map_1.default();\nconst waitForOpenFile = async (file) => new Promise((resolve, reject) => {\n    const onError = (error) => {\n        reject(error);\n    };\n    // Node.js 12 has incomplete types\n    if (!file.pending) {\n        resolve();\n    }\n    file.once('error', onError);\n    file.once('ready', () => {\n        file.off('error', onError);\n        resolve();\n    });\n});\nconst redirectCodes = new Set([300, 301, 302, 303, 304, 307, 308]);\nconst nonEnumerableProperties = [\n    'context',\n    'body',\n    'json',\n    'form'\n];\nexports.setNonEnumerableProperties = (sources, to) => {\n    // Non enumerable properties shall not be merged\n    const properties = {};\n    for (const source of sources) {\n        if (!source) {\n            continue;\n        }\n        for (const name of nonEnumerableProperties) {\n            if (!(name in source)) {\n                continue;\n            }\n            properties[name] = {\n                writable: true,\n                configurable: true,\n                enumerable: false,\n                // @ts-expect-error TS doesn't see the check above\n                value: source[name]\n            };\n        }\n    }\n    Object.defineProperties(to, properties);\n};\n/**\nAn error to be thrown when a request fails.\nContains a `code` property with error class code, like `ECONNREFUSED`.\n*/\nclass RequestError extends Error {\n    constructor(message, error, self) {\n        var _a, _b;\n        super(message);\n        Error.captureStackTrace(this, this.constructor);\n        this.name = 'RequestError';\n        this.code = (_a = error.code) !== null && _a !== void 0 ? _a : 'ERR_GOT_REQUEST_ERROR';\n        if (self instanceof Request) {\n            Object.defineProperty(this, 'request', {\n                enumerable: false,\n                value: self\n            });\n            Object.defineProperty(this, 'response', {\n                enumerable: false,\n                value: self[kResponse]\n            });\n            Object.defineProperty(this, 'options', {\n                // This fails because of TS 3.7.2 useDefineForClassFields\n                // Ref: https://github.com/microsoft/TypeScript/issues/34972\n                enumerable: false,\n                value: self.options\n            });\n        }\n        else {\n            Object.defineProperty(this, 'options', {\n                // This fails because of TS 3.7.2 useDefineForClassFields\n                // Ref: https://github.com/microsoft/TypeScript/issues/34972\n                enumerable: false,\n                value: self\n            });\n        }\n        this.timings = (_b = this.request) === null || _b === void 0 ? void 0 : _b.timings;\n        // Recover the original stacktrace\n        if (is_1.default.string(error.stack) && is_1.default.string(this.stack)) {\n            const indexOfMessage = this.stack.indexOf(this.message) + this.message.length;\n            const thisStackTrace = this.stack.slice(indexOfMessage).split('\\n').reverse();\n            const errorStackTrace = error.stack.slice(error.stack.indexOf(error.message) + error.message.length).split('\\n').reverse();\n            // Remove duplicated traces\n            while (errorStackTrace.length !== 0 && errorStackTrace[0] === thisStackTrace[0]) {\n                thisStackTrace.shift();\n            }\n            this.stack = `${this.stack.slice(0, indexOfMessage)}${thisStackTrace.reverse().join('\\n')}${errorStackTrace.reverse().join('\\n')}`;\n        }\n    }\n}\nexports.RequestError = RequestError;\n/**\nAn error to be thrown when the server redirects you more than ten times.\nIncludes a `response` property.\n*/\nclass MaxRedirectsError extends RequestError {\n    constructor(request) {\n        super(`Redirected ${request.options.maxRedirects} times. Aborting.`, {}, request);\n        this.name = 'MaxRedirectsError';\n        this.code = 'ERR_TOO_MANY_REDIRECTS';\n    }\n}\nexports.MaxRedirectsError = MaxRedirectsError;\n/**\nAn error to be thrown when the server response code is not 2xx nor 3xx if `options.followRedirect` is `true`, but always except for 304.\nIncludes a `response` property.\n*/\nclass HTTPError extends RequestError {\n    constructor(response) {\n        super(`Response code ${response.statusCode} (${response.statusMessage})`, {}, response.request);\n        this.name = 'HTTPError';\n        this.code = 'ERR_NON_2XX_3XX_RESPONSE';\n    }\n}\nexports.HTTPError = HTTPError;\n/**\nAn error to be thrown when a cache method fails.\nFor example, if the database goes down or there's a filesystem error.\n*/\nclass CacheError extends RequestError {\n    constructor(error, request) {\n        super(error.message, error, request);\n        this.name = 'CacheError';\n        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_CACHE_ACCESS' : this.code;\n    }\n}\nexports.CacheError = CacheError;\n/**\nAn error to be thrown when the request body is a stream and an error occurs while reading from that stream.\n*/\nclass UploadError extends RequestError {\n    constructor(error, request) {\n        super(error.message, error, request);\n        this.name = 'UploadError';\n        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_UPLOAD' : this.code;\n    }\n}\nexports.UploadError = UploadError;\n/**\nAn error to be thrown when the request is aborted due to a timeout.\nIncludes an `event` and `timings` property.\n*/\nclass TimeoutError extends RequestError {\n    constructor(error, timings, request) {\n        super(error.message, error, request);\n        this.name = 'TimeoutError';\n        this.event = error.event;\n        this.timings = timings;\n    }\n}\nexports.TimeoutError = TimeoutError;\n/**\nAn error to be thrown when reading from response stream fails.\n*/\nclass ReadError extends RequestError {\n    constructor(error, request) {\n        super(error.message, error, request);\n        this.name = 'ReadError';\n        this.code = this.code === 'ERR_GOT_REQUEST_ERROR' ? 'ERR_READING_RESPONSE_STREAM' : this.code;\n    }\n}\nexports.ReadError = ReadError;\n/**\nAn error to be thrown when given an unsupported protocol.\n*/\nclass UnsupportedProtocolError extends RequestError {\n    constructor(options) {\n        super(`Unsupported protocol \"${options.url.protocol}\"`, {}, options);\n        this.name = 'UnsupportedProtocolError';\n        this.code = 'ERR_UNSUPPORTED_PROTOCOL';\n    }\n}\nexports.UnsupportedProtocolError = UnsupportedProtocolError;\nconst proxiedRequestEvents = [\n    'socket',\n    'connect',\n    'continue',\n    'information',\n    'upgrade',\n    'timeout'\n];\nclass Request extends stream_1.Duplex {\n    constructor(url, options = {}, defaults) {\n        super({\n            // This must be false, to enable throwing after destroy\n            // It is used for retry logic in Promise API\n            autoDestroy: false,\n            // It needs to be zero because we're just proxying the data to another stream\n            highWaterMark: 0\n        });\n        this[kDownloadedSize] = 0;\n        this[kUploadedSize] = 0;\n        this.requestInitialized = false;\n        this[kServerResponsesPiped] = new Set();\n        this.redirects = [];\n        this[kStopReading] = false;\n        this[kTriggerRead] = false;\n        this[kJobs] = [];\n        this.retryCount = 0;\n        // TODO: Remove this when targeting Node.js >= 12\n        this._progressCallbacks = [];\n        const unlockWrite = () => this._unlockWrite();\n        const lockWrite = () => this._lockWrite();\n        this.on('pipe', (source) => {\n            source.prependListener('data', unlockWrite);\n            source.on('data', lockWrite);\n            source.prependListener('end', unlockWrite);\n            source.on('end', lockWrite);\n        });\n        this.on('unpipe', (source) => {\n            source.off('data', unlockWrite);\n            source.off('data', lockWrite);\n            source.off('end', unlockWrite);\n            source.off('end', lockWrite);\n        });\n        this.on('pipe', source => {\n            if (source instanceof http_1.IncomingMessage) {\n                this.options.headers = {\n                    ...source.headers,\n                    ...this.options.headers\n                };\n            }\n        });\n        const { json, body, form } = options;\n        if (json || body || form) {\n            this._lockWrite();\n        }\n        if (exports.kIsNormalizedAlready in options) {\n            this.options = options;\n        }\n        else {\n            try {\n                // @ts-expect-error Common TypeScript bug saying that `this.constructor` is not accessible\n                this.options = this.constructor.normalizeArguments(url, options, defaults);\n            }\n            catch (error) {\n                // TODO: Move this to `_destroy()`\n                if (is_1.default.nodeStream(options.body)) {\n                    options.body.destroy();\n                }\n                this.destroy(error);\n                return;\n            }\n        }\n        (async () => {\n            var _a;\n            try {\n                if (this.options.body instanceof fs_1.ReadStream) {\n                    await waitForOpenFile(this.options.body);\n                }\n                const { url: normalizedURL } = this.options;\n                if (!normalizedURL) {\n                    throw new TypeError('Missing `url` property');\n                }\n                this.requestUrl = normalizedURL.toString();\n                decodeURI(this.requestUrl);\n                await this._finalizeBody();\n                await this._makeRequest();\n                if (this.destroyed) {\n                    (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.destroy();\n                    return;\n                }\n                // Queued writes etc.\n                for (const job of this[kJobs]) {\n                    job();\n                }\n                // Prevent memory leak\n                this[kJobs].length = 0;\n                this.requestInitialized = true;\n            }\n            catch (error) {\n                if (error instanceof RequestError) {\n                    this._beforeError(error);\n                    return;\n                }\n                // This is a workaround for https://github.com/nodejs/node/issues/33335\n                if (!this.destroyed) {\n                    this.destroy(error);\n                }\n            }\n        })();\n    }\n    static normalizeArguments(url, options, defaults) {\n        var _a, _b, _c, _d, _e;\n        const rawOptions = options;\n        if (is_1.default.object(url) && !is_1.default.urlInstance(url)) {\n            options = { ...defaults, ...url, ...options };\n        }\n        else {\n            if (url && options && options.url !== undefined) {\n                throw new TypeError('The `url` option is mutually exclusive with the `input` argument');\n            }\n            options = { ...defaults, ...options };\n            if (url !== undefined) {\n                options.url = url;\n            }\n            if (is_1.default.urlInstance(options.url)) {\n                options.url = new url_1.URL(options.url.toString());\n            }\n        }\n        // TODO: Deprecate URL options in Got 12.\n        // Support extend-specific options\n        if (options.cache === false) {\n            options.cache = undefined;\n        }\n        if (options.dnsCache === false) {\n            options.dnsCache = undefined;\n        }\n        // Nice type assertions\n        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.method);\n        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.headers);\n        is_1.assert.any([is_1.default.string, is_1.default.urlInstance, is_1.default.undefined], options.prefixUrl);\n        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cookieJar);\n        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.searchParams);\n        is_1.assert.any([is_1.default.object, is_1.default.string, is_1.default.undefined], options.cache);\n        is_1.assert.any([is_1.default.object, is_1.default.number, is_1.default.undefined], options.timeout);\n        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.context);\n        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.hooks);\n        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.decompress);\n        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.ignoreInvalidCookies);\n        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.followRedirect);\n        is_1.assert.any([is_1.default.number, is_1.default.undefined], options.maxRedirects);\n        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.throwHttpErrors);\n        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.http2);\n        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.allowGetBody);\n        is_1.assert.any([is_1.default.string, is_1.default.undefined], options.localAddress);\n        is_1.assert.any([dns_ip_version_1.isDnsLookupIpVersion, is_1.default.undefined], options.dnsLookupIpVersion);\n        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.https);\n        is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.rejectUnauthorized);\n        if (options.https) {\n            is_1.assert.any([is_1.default.boolean, is_1.default.undefined], options.https.rejectUnauthorized);\n            is_1.assert.any([is_1.default.function_, is_1.default.undefined], options.https.checkServerIdentity);\n            is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificateAuthority);\n            is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.key);\n            is_1.assert.any([is_1.default.string, is_1.default.object, is_1.default.array, is_1.default.undefined], options.https.certificate);\n            is_1.assert.any([is_1.default.string, is_1.default.undefined], options.https.passphrase);\n            is_1.assert.any([is_1.default.string, is_1.default.buffer, is_1.default.array, is_1.default.undefined], options.https.pfx);\n        }\n        is_1.assert.any([is_1.default.object, is_1.default.undefined], options.cacheOptions);\n        // `options.method`\n        if (is_1.default.string(options.method)) {\n            options.method = options.method.toUpperCase();\n        }\n        else {\n            options.method = 'GET';\n        }\n        // `options.headers`\n        if (options.headers === (defaults === null || defaults === void 0 ? void 0 : defaults.headers)) {\n            options.headers = { ...options.headers };\n        }\n        else {\n            options.headers = lowercaseKeys({ ...(defaults === null || defaults === void 0 ? void 0 : defaults.headers), ...options.headers });\n        }\n        // Disallow legacy `url.Url`\n        if ('slashes' in options) {\n            throw new TypeError('The legacy `url.Url` has been deprecated. Use `URL` instead.');\n        }\n        // `options.auth`\n        if ('auth' in options) {\n            throw new TypeError('Parameter `auth` is deprecated. Use `username` / `password` instead.');\n        }\n        // `options.searchParams`\n        if ('searchParams' in options) {\n            if (options.searchParams && options.searchParams !== (defaults === null || defaults === void 0 ? void 0 : defaults.searchParams)) {\n                let searchParameters;\n                if (is_1.default.string(options.searchParams) || (options.searchParams instanceof url_1.URLSearchParams)) {\n                    searchParameters = new url_1.URLSearchParams(options.searchParams);\n                }\n                else {\n                    validateSearchParameters(options.searchParams);\n                    searchParameters = new url_1.URLSearchParams();\n                    // eslint-disable-next-line guard-for-in\n                    for (const key in options.searchParams) {\n                        const value = options.searchParams[key];\n                        if (value === null) {\n                            searchParameters.append(key, '');\n                        }\n                        else if (value !== undefined) {\n                            searchParameters.append(key, value);\n                        }\n                    }\n                }\n                // `normalizeArguments()` is also used to merge options\n                (_a = defaults === null || defaults === void 0 ? void 0 : defaults.searchParams) === null || _a === void 0 ? void 0 : _a.forEach((value, key) => {\n                    // Only use default if one isn't already defined\n                    if (!searchParameters.has(key)) {\n                        searchParameters.append(key, value);\n                    }\n                });\n                options.searchParams = searchParameters;\n            }\n        }\n        // `options.username` & `options.password`\n        options.username = (_b = options.username) !== null && _b !== void 0 ? _b : '';\n        options.password = (_c = options.password) !== null && _c !== void 0 ? _c : '';\n        // `options.prefixUrl` & `options.url`\n        if (is_1.default.undefined(options.prefixUrl)) {\n            options.prefixUrl = (_d = defaults === null || defaults === void 0 ? void 0 : defaults.prefixUrl) !== null && _d !== void 0 ? _d : '';\n        }\n        else {\n            options.prefixUrl = options.prefixUrl.toString();\n            if (options.prefixUrl !== '' && !options.prefixUrl.endsWith('/')) {\n                options.prefixUrl += '/';\n            }\n        }\n        if (is_1.default.string(options.url)) {\n            if (options.url.startsWith('/')) {\n                throw new Error('`input` must not start with a slash when using `prefixUrl`');\n            }\n            options.url = options_to_url_1.default(options.prefixUrl + options.url, options);\n        }\n        else if ((is_1.default.undefined(options.url) && options.prefixUrl !== '') || options.protocol) {\n            options.url = options_to_url_1.default(options.prefixUrl, options);\n        }\n        if (options.url) {\n            if ('port' in options) {\n                delete options.port;\n            }\n            // Make it possible to change `options.prefixUrl`\n            let { prefixUrl } = options;\n            Object.defineProperty(options, 'prefixUrl', {\n                set: (value) => {\n                    const url = options.url;\n                    if (!url.href.startsWith(value)) {\n                        throw new Error(`Cannot change \\`prefixUrl\\` from ${prefixUrl} to ${value}: ${url.href}`);\n                    }\n                    options.url = new url_1.URL(value + url.href.slice(prefixUrl.length));\n                    prefixUrl = value;\n                },\n                get: () => prefixUrl\n            });\n            // Support UNIX sockets\n            let { protocol } = options.url;\n            if (protocol === 'unix:') {\n                protocol = 'http:';\n                options.url = new url_1.URL(`http://unix${options.url.pathname}${options.url.search}`);\n            }\n            // Set search params\n            if (options.searchParams) {\n                // eslint-disable-next-line @typescript-eslint/no-base-to-string\n                options.url.search = options.searchParams.toString();\n            }\n            // Protocol check\n            if (protocol !== 'http:' && protocol !== 'https:') {\n                throw new UnsupportedProtocolError(options);\n            }\n            // Update `username`\n            if (options.username === '') {\n                options.username = options.url.username;\n            }\n            else {\n                options.url.username = options.username;\n            }\n            // Update `password`\n            if (options.password === '') {\n                options.password = options.url.password;\n            }\n            else {\n                options.url.password = options.password;\n            }\n        }\n        // `options.cookieJar`\n        const { cookieJar } = options;\n        if (cookieJar) {\n            let { setCookie, getCookieString } = cookieJar;\n            is_1.assert.function_(setCookie);\n            is_1.assert.function_(getCookieString);\n            /* istanbul ignore next: Horrible `tough-cookie` v3 check */\n            if (setCookie.length === 4 && getCookieString.length === 0) {\n                setCookie = util_1.promisify(setCookie.bind(options.cookieJar));\n                getCookieString = util_1.promisify(getCookieString.bind(options.cookieJar));\n                options.cookieJar = {\n                    setCookie,\n                    getCookieString: getCookieString\n                };\n            }\n        }\n        // `options.cache`\n        const { cache } = options;\n        if (cache) {\n            if (!cacheableStore.has(cache)) {\n                cacheableStore.set(cache, new CacheableRequest(((requestOptions, handler) => {\n                    const result = requestOptions[kRequest](requestOptions, handler);\n                    // TODO: remove this when `cacheable-request` supports async request functions.\n                    if (is_1.default.promise(result)) {\n                        // @ts-expect-error\n                        // We only need to implement the error handler in order to support HTTP2 caching.\n                        // The result will be a promise anyway.\n                        result.once = (event, handler) => {\n                            if (event === 'error') {\n                                result.catch(handler);\n                            }\n                            else if (event === 'abort') {\n                                // The empty catch is needed here in case when\n                                // it rejects before it's `await`ed in `_makeRequest`.\n                                (async () => {\n                                    try {\n                                        const request = (await result);\n                                        request.once('abort', handler);\n                                    }\n                                    catch (_a) { }\n                                })();\n                            }\n                            else {\n                                /* istanbul ignore next: safety check */\n                                throw new Error(`Unknown HTTP2 promise event: ${event}`);\n                            }\n                            return result;\n                        };\n                    }\n                    return result;\n                }), cache));\n            }\n        }\n        // `options.cacheOptions`\n        options.cacheOptions = { ...options.cacheOptions };\n        // `options.dnsCache`\n        if (options.dnsCache === true) {\n            if (!globalDnsCache) {\n                globalDnsCache = new cacheable_lookup_1.default();\n            }\n            options.dnsCache = globalDnsCache;\n        }\n        else if (!is_1.default.undefined(options.dnsCache) && !options.dnsCache.lookup) {\n            throw new TypeError(`Parameter \\`dnsCache\\` must be a CacheableLookup instance or a boolean, got ${is_1.default(options.dnsCache)}`);\n        }\n        // `options.timeout`\n        if (is_1.default.number(options.timeout)) {\n            options.timeout = { request: options.timeout };\n        }\n        else if (defaults && options.timeout !== defaults.timeout) {\n            options.timeout = {\n                ...defaults.timeout,\n                ...options.timeout\n            };\n        }\n        else {\n            options.timeout = { ...options.timeout };\n        }\n        // `options.context`\n        if (!options.context) {\n            options.context = {};\n        }\n        // `options.hooks`\n        const areHooksDefault = options.hooks === (defaults === null || defaults === void 0 ? void 0 : defaults.hooks);\n        options.hooks = { ...options.hooks };\n        for (const event of exports.knownHookEvents) {\n            if (event in options.hooks) {\n                if (is_1.default.array(options.hooks[event])) {\n                    // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044\n                    options.hooks[event] = [...options.hooks[event]];\n                }\n                else {\n                    throw new TypeError(`Parameter \\`${event}\\` must be an Array, got ${is_1.default(options.hooks[event])}`);\n                }\n            }\n            else {\n                options.hooks[event] = [];\n            }\n        }\n        if (defaults && !areHooksDefault) {\n            for (const event of exports.knownHookEvents) {\n                const defaultHooks = defaults.hooks[event];\n                if (defaultHooks.length > 0) {\n                    // See https://github.com/microsoft/TypeScript/issues/31445#issuecomment-576929044\n                    options.hooks[event] = [\n                        ...defaults.hooks[event],\n                        ...options.hooks[event]\n                    ];\n                }\n            }\n        }\n        // DNS options\n        if ('family' in options) {\n            deprecation_warning_1.default('\"options.family\" was never documented, please use \"options.dnsLookupIpVersion\"');\n        }\n        // HTTPS options\n        if (defaults === null || defaults === void 0 ? void 0 : defaults.https) {\n            options.https = { ...defaults.https, ...options.https };\n        }\n        if ('rejectUnauthorized' in options) {\n            deprecation_warning_1.default('\"options.rejectUnauthorized\" is now deprecated, please use \"options.https.rejectUnauthorized\"');\n        }\n        if ('checkServerIdentity' in options) {\n            deprecation_warning_1.default('\"options.checkServerIdentity\" was never documented, please use \"options.https.checkServerIdentity\"');\n        }\n        if ('ca' in options) {\n            deprecation_warning_1.default('\"options.ca\" was never documented, please use \"options.https.certificateAuthority\"');\n        }\n        if ('key' in options) {\n            deprecation_warning_1.default('\"options.key\" was never documented, please use \"options.https.key\"');\n        }\n        if ('cert' in options) {\n            deprecation_warning_1.default('\"options.cert\" was never documented, please use \"options.https.certificate\"');\n        }\n        if ('passphrase' in options) {\n            deprecation_warning_1.default('\"options.passphrase\" was never documented, please use \"options.https.passphrase\"');\n        }\n        if ('pfx' in options) {\n            deprecation_warning_1.default('\"options.pfx\" was never documented, please use \"options.https.pfx\"');\n        }\n        // Other options\n        if ('followRedirects' in options) {\n            throw new TypeError('The `followRedirects` option does not exist. Use `followRedirect` instead.');\n        }\n        if (options.agent) {\n            for (const key in options.agent) {\n                if (key !== 'http' && key !== 'https' && key !== 'http2') {\n                    throw new TypeError(`Expected the \\`options.agent\\` properties to be \\`http\\`, \\`https\\` or \\`http2\\`, got \\`${key}\\``);\n                }\n            }\n        }\n        options.maxRedirects = (_e = options.maxRedirects) !== null && _e !== void 0 ? _e : 0;\n        // Set non-enumerable properties\n        exports.setNonEnumerableProperties([defaults, rawOptions], options);\n        return normalize_arguments_1.default(options, defaults);\n    }\n    _lockWrite() {\n        const onLockedWrite = () => {\n            throw new TypeError('The payload has been already provided');\n        };\n        this.write = onLockedWrite;\n        this.end = onLockedWrite;\n    }\n    _unlockWrite() {\n        this.write = super.write;\n        this.end = super.end;\n    }\n    async _finalizeBody() {\n        const { options } = this;\n        const { headers } = options;\n        const isForm = !is_1.default.undefined(options.form);\n        const isJSON = !is_1.default.undefined(options.json);\n        const isBody = !is_1.default.undefined(options.body);\n        const hasPayload = isForm || isJSON || isBody;\n        const cannotHaveBody = exports.withoutBody.has(options.method) && !(options.method === 'GET' && options.allowGetBody);\n        this._cannotHaveBody = cannotHaveBody;\n        if (hasPayload) {\n            if (cannotHaveBody) {\n                throw new TypeError(`The \\`${options.method}\\` method cannot be used with a body`);\n            }\n            if ([isBody, isForm, isJSON].filter(isTrue => isTrue).length > 1) {\n                throw new TypeError('The `body`, `json` and `form` options are mutually exclusive');\n            }\n            if (isBody &&\n                !(options.body instanceof stream_1.Readable) &&\n                !is_1.default.string(options.body) &&\n                !is_1.default.buffer(options.body) &&\n                !is_form_data_1.default(options.body)) {\n                throw new TypeError('The `body` option must be a stream.Readable, string or Buffer');\n            }\n            if (isForm && !is_1.default.object(options.form)) {\n                throw new TypeError('The `form` option must be an Object');\n            }\n            {\n                // Serialize body\n                const noContentType = !is_1.default.string(headers['content-type']);\n                if (isBody) {\n                    // Special case for https://github.com/form-data/form-data\n                    if (is_form_data_1.default(options.body) && noContentType) {\n                        headers['content-type'] = `multipart/form-data; boundary=${options.body.getBoundary()}`;\n                    }\n                    this[kBody] = options.body;\n                }\n                else if (isForm) {\n                    if (noContentType) {\n                        headers['content-type'] = 'application/x-www-form-urlencoded';\n                    }\n                    this[kBody] = (new url_1.URLSearchParams(options.form)).toString();\n                }\n                else {\n                    if (noContentType) {\n                        headers['content-type'] = 'application/json';\n                    }\n                    this[kBody] = options.stringifyJson(options.json);\n                }\n                const uploadBodySize = await get_body_size_1.default(this[kBody], options.headers);\n                // See https://tools.ietf.org/html/rfc7230#section-3.3.2\n                // A user agent SHOULD send a Content-Length in a request message when\n                // no Transfer-Encoding is sent and the request method defines a meaning\n                // for an enclosed payload body.  For example, a Content-Length header\n                // field is normally sent in a POST request even when the value is 0\n                // (indicating an empty payload body).  A user agent SHOULD NOT send a\n                // Content-Length header field when the request message does not contain\n                // a payload body and the method semantics do not anticipate such a\n                // body.\n                if (is_1.default.undefined(headers['content-length']) && is_1.default.undefined(headers['transfer-encoding'])) {\n                    if (!cannotHaveBody && !is_1.default.undefined(uploadBodySize)) {\n                        headers['content-length'] = String(uploadBodySize);\n                    }\n                }\n            }\n        }\n        else if (cannotHaveBody) {\n            this._lockWrite();\n        }\n        else {\n            this._unlockWrite();\n        }\n        this[kBodySize] = Number(headers['content-length']) || undefined;\n    }\n    async _onResponseBase(response) {\n        const { options } = this;\n        const { url } = options;\n        this[kOriginalResponse] = response;\n        if (options.decompress) {\n            response = decompressResponse(response);\n        }\n        const statusCode = response.statusCode;\n        const typedResponse = response;\n        typedResponse.statusMessage = typedResponse.statusMessage ? typedResponse.statusMessage : http.STATUS_CODES[statusCode];\n        typedResponse.url = options.url.toString();\n        typedResponse.requestUrl = this.requestUrl;\n        typedResponse.redirectUrls = this.redirects;\n        typedResponse.request = this;\n        typedResponse.isFromCache = response.fromCache || false;\n        typedResponse.ip = this.ip;\n        typedResponse.retryCount = this.retryCount;\n        this[kIsFromCache] = typedResponse.isFromCache;\n        this[kResponseSize] = Number(response.headers['content-length']) || undefined;\n        this[kResponse] = response;\n        response.once('end', () => {\n            this[kResponseSize] = this[kDownloadedSize];\n            this.emit('downloadProgress', this.downloadProgress);\n        });\n        response.once('error', (error) => {\n            // Force clean-up, because some packages don't do this.\n            // TODO: Fix decompress-response\n            response.destroy();\n            this._beforeError(new ReadError(error, this));\n        });\n        response.once('aborted', () => {\n            this._beforeError(new ReadError({\n                name: 'Error',\n                message: 'The server aborted pending request',\n                code: 'ECONNRESET'\n            }, this));\n        });\n        this.emit('downloadProgress', this.downloadProgress);\n        const rawCookies = response.headers['set-cookie'];\n        if (is_1.default.object(options.cookieJar) && rawCookies) {\n            let promises = rawCookies.map(async (rawCookie) => options.cookieJar.setCookie(rawCookie, url.toString()));\n            if (options.ignoreInvalidCookies) {\n                promises = promises.map(async (p) => p.catch(() => { }));\n            }\n            try {\n                await Promise.all(promises);\n            }\n            catch (error) {\n                this._beforeError(error);\n                return;\n            }\n        }\n        if (options.followRedirect && response.headers.location && redirectCodes.has(statusCode)) {\n            // We're being redirected, we don't care about the response.\n            // It'd be best to abort the request, but we can't because\n            // we would have to sacrifice the TCP connection. We don't want that.\n            response.resume();\n            if (this[kRequest]) {\n                this[kCancelTimeouts]();\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete this[kRequest];\n                this[kUnproxyEvents]();\n            }\n            const shouldBeGet = statusCode === 303 && options.method !== 'GET' && options.method !== 'HEAD';\n            if (shouldBeGet || !options.methodRewriting) {\n                // Server responded with \"see other\", indicating that the resource exists at another location,\n                // and the client should request it from that location via GET or HEAD.\n                options.method = 'GET';\n                if ('body' in options) {\n                    delete options.body;\n                }\n                if ('json' in options) {\n                    delete options.json;\n                }\n                if ('form' in options) {\n                    delete options.form;\n                }\n                this[kBody] = undefined;\n                delete options.headers['content-length'];\n            }\n            if (this.redirects.length >= options.maxRedirects) {\n                this._beforeError(new MaxRedirectsError(this));\n                return;\n            }\n            try {\n                // Do not remove. See https://github.com/sindresorhus/got/pull/214\n                const redirectBuffer = Buffer.from(response.headers.location, 'binary').toString();\n                // Handles invalid URLs. See https://github.com/sindresorhus/got/issues/604\n                const redirectUrl = new url_1.URL(redirectBuffer, url);\n                const redirectString = redirectUrl.toString();\n                decodeURI(redirectString);\n                // eslint-disable-next-line no-inner-declarations\n                function isUnixSocketURL(url) {\n                    return url.protocol === 'unix:' || url.hostname === 'unix';\n                }\n                if (!isUnixSocketURL(url) && isUnixSocketURL(redirectUrl)) {\n                    this._beforeError(new RequestError('Cannot redirect to UNIX socket', {}, this));\n                    return;\n                }\n                // Redirecting to a different site, clear sensitive data.\n                if (redirectUrl.hostname !== url.hostname || redirectUrl.port !== url.port) {\n                    if ('host' in options.headers) {\n                        delete options.headers.host;\n                    }\n                    if ('cookie' in options.headers) {\n                        delete options.headers.cookie;\n                    }\n                    if ('authorization' in options.headers) {\n                        delete options.headers.authorization;\n                    }\n                    if (options.username || options.password) {\n                        options.username = '';\n                        options.password = '';\n                    }\n                }\n                else {\n                    redirectUrl.username = options.username;\n                    redirectUrl.password = options.password;\n                }\n                this.redirects.push(redirectString);\n                options.url = redirectUrl;\n                for (const hook of options.hooks.beforeRedirect) {\n                    // eslint-disable-next-line no-await-in-loop\n                    await hook(options, typedResponse);\n                }\n                this.emit('redirect', typedResponse, options);\n                await this._makeRequest();\n            }\n            catch (error) {\n                this._beforeError(error);\n                return;\n            }\n            return;\n        }\n        if (options.isStream && options.throwHttpErrors && !is_response_ok_1.isResponseOk(typedResponse)) {\n            this._beforeError(new HTTPError(typedResponse));\n            return;\n        }\n        response.on('readable', () => {\n            if (this[kTriggerRead]) {\n                this._read();\n            }\n        });\n        this.on('resume', () => {\n            response.resume();\n        });\n        this.on('pause', () => {\n            response.pause();\n        });\n        response.once('end', () => {\n            this.push(null);\n        });\n        this.emit('response', response);\n        for (const destination of this[kServerResponsesPiped]) {\n            if (destination.headersSent) {\n                continue;\n            }\n            // eslint-disable-next-line guard-for-in\n            for (const key in response.headers) {\n                const isAllowed = options.decompress ? key !== 'content-encoding' : true;\n                const value = response.headers[key];\n                if (isAllowed) {\n                    destination.setHeader(key, value);\n                }\n            }\n            destination.statusCode = statusCode;\n        }\n    }\n    async _onResponse(response) {\n        try {\n            await this._onResponseBase(response);\n        }\n        catch (error) {\n            /* istanbul ignore next: better safe than sorry */\n            this._beforeError(error);\n        }\n    }\n    _onRequest(request) {\n        const { options } = this;\n        const { timeout, url } = options;\n        http_timer_1.default(request);\n        this[kCancelTimeouts] = timed_out_1.default(request, timeout, url);\n        const responseEventName = options.cache ? 'cacheableResponse' : 'response';\n        request.once(responseEventName, (response) => {\n            void this._onResponse(response);\n        });\n        request.once('error', (error) => {\n            var _a;\n            // Force clean-up, because some packages (e.g. nock) don't do this.\n            request.destroy();\n            // Node.js <= 12.18.2 mistakenly emits the response `end` first.\n            (_a = request.res) === null || _a === void 0 ? void 0 : _a.removeAllListeners('end');\n            error = error instanceof timed_out_1.TimeoutError ? new TimeoutError(error, this.timings, this) : new RequestError(error.message, error, this);\n            this._beforeError(error);\n        });\n        this[kUnproxyEvents] = proxy_events_1.default(request, this, proxiedRequestEvents);\n        this[kRequest] = request;\n        this.emit('uploadProgress', this.uploadProgress);\n        // Send body\n        const body = this[kBody];\n        const currentRequest = this.redirects.length === 0 ? this : request;\n        if (is_1.default.nodeStream(body)) {\n            body.pipe(currentRequest);\n            body.once('error', (error) => {\n                this._beforeError(new UploadError(error, this));\n            });\n        }\n        else {\n            this._unlockWrite();\n            if (!is_1.default.undefined(body)) {\n                this._writeRequest(body, undefined, () => { });\n                currentRequest.end();\n                this._lockWrite();\n            }\n            else if (this._cannotHaveBody || this._noPipe) {\n                currentRequest.end();\n                this._lockWrite();\n            }\n        }\n        this.emit('request', request);\n    }\n    async _createCacheableRequest(url, options) {\n        return new Promise((resolve, reject) => {\n            // TODO: Remove `utils/url-to-options.ts` when `cacheable-request` is fixed\n            Object.assign(options, url_to_options_1.default(url));\n            // `http-cache-semantics` checks this\n            // TODO: Fix this ignore.\n            // @ts-expect-error\n            delete options.url;\n            let request;\n            // This is ugly\n            const cacheRequest = cacheableStore.get(options.cache)(options, async (response) => {\n                // TODO: Fix `cacheable-response`\n                response._readableState.autoDestroy = false;\n                if (request) {\n                    (await request).emit('cacheableResponse', response);\n                }\n                resolve(response);\n            });\n            // Restore options\n            options.url = url;\n            cacheRequest.once('error', reject);\n            cacheRequest.once('request', async (requestOrPromise) => {\n                request = requestOrPromise;\n                resolve(request);\n            });\n        });\n    }\n    async _makeRequest() {\n        var _a, _b, _c, _d, _e;\n        const { options } = this;\n        const { headers } = options;\n        for (const key in headers) {\n            if (is_1.default.undefined(headers[key])) {\n                // eslint-disable-next-line @typescript-eslint/no-dynamic-delete\n                delete headers[key];\n            }\n            else if (is_1.default.null_(headers[key])) {\n                throw new TypeError(`Use \\`undefined\\` instead of \\`null\\` to delete the \\`${key}\\` header`);\n            }\n        }\n        if (options.decompress && is_1.default.undefined(headers['accept-encoding'])) {\n            headers['accept-encoding'] = supportsBrotli ? 'gzip, deflate, br' : 'gzip, deflate';\n        }\n        // Set cookies\n        if (options.cookieJar) {\n            const cookieString = await options.cookieJar.getCookieString(options.url.toString());\n            if (is_1.default.nonEmptyString(cookieString)) {\n                options.headers.cookie = cookieString;\n            }\n        }\n        for (const hook of options.hooks.beforeRequest) {\n            // eslint-disable-next-line no-await-in-loop\n            const result = await hook(options);\n            if (!is_1.default.undefined(result)) {\n                // @ts-expect-error Skip the type mismatch to support abstract responses\n                options.request = () => result;\n                break;\n            }\n        }\n        if (options.body && this[kBody] !== options.body) {\n            this[kBody] = options.body;\n        }\n        const { agent, request, timeout, url } = options;\n        if (options.dnsCache && !('lookup' in options)) {\n            options.lookup = options.dnsCache.lookup;\n        }\n        // UNIX sockets\n        if (url.hostname === 'unix') {\n            const matches = /(?<socketPath>.+?):(?<path>.+)/.exec(`${url.pathname}${url.search}`);\n            if (matches === null || matches === void 0 ? void 0 : matches.groups) {\n                const { socketPath, path } = matches.groups;\n                Object.assign(options, {\n                    socketPath,\n                    path,\n                    host: ''\n                });\n            }\n        }\n        const isHttps = url.protocol === 'https:';\n        // Fallback function\n        let fallbackFn;\n        if (options.http2) {\n            fallbackFn = http2wrapper.auto;\n        }\n        else {\n            fallbackFn = isHttps ? https.request : http.request;\n        }\n        const realFn = (_a = options.request) !== null && _a !== void 0 ? _a : fallbackFn;\n        // Cache support\n        const fn = options.cache ? this._createCacheableRequest : realFn;\n        // Pass an agent directly when HTTP2 is disabled\n        if (agent && !options.http2) {\n            options.agent = agent[isHttps ? 'https' : 'http'];\n        }\n        // Prepare plain HTTP request options\n        options[kRequest] = realFn;\n        delete options.request;\n        // TODO: Fix this ignore.\n        // @ts-expect-error\n        delete options.timeout;\n        const requestOptions = options;\n        requestOptions.shared = (_b = options.cacheOptions) === null || _b === void 0 ? void 0 : _b.shared;\n        requestOptions.cacheHeuristic = (_c = options.cacheOptions) === null || _c === void 0 ? void 0 : _c.cacheHeuristic;\n        requestOptions.immutableMinTimeToLive = (_d = options.cacheOptions) === null || _d === void 0 ? void 0 : _d.immutableMinTimeToLive;\n        requestOptions.ignoreCargoCult = (_e = options.cacheOptions) === null || _e === void 0 ? void 0 : _e.ignoreCargoCult;\n        // If `dnsLookupIpVersion` is not present do not override `family`\n        if (options.dnsLookupIpVersion !== undefined) {\n            try {\n                requestOptions.family = dns_ip_version_1.dnsLookupIpVersionToFamily(options.dnsLookupIpVersion);\n            }\n            catch (_f) {\n                throw new Error('Invalid `dnsLookupIpVersion` option value');\n            }\n        }\n        // HTTPS options remapping\n        if (options.https) {\n            if ('rejectUnauthorized' in options.https) {\n                requestOptions.rejectUnauthorized = options.https.rejectUnauthorized;\n            }\n            if (options.https.checkServerIdentity) {\n                requestOptions.checkServerIdentity = options.https.checkServerIdentity;\n            }\n            if (options.https.certificateAuthority) {\n                requestOptions.ca = options.https.certificateAuthority;\n            }\n            if (options.https.certificate) {\n                requestOptions.cert = options.https.certificate;\n            }\n            if (options.https.key) {\n                requestOptions.key = options.https.key;\n            }\n            if (options.https.passphrase) {\n                requestOptions.passphrase = options.https.passphrase;\n            }\n            if (options.https.pfx) {\n                requestOptions.pfx = options.https.pfx;\n            }\n        }\n        try {\n            let requestOrResponse = await fn(url, requestOptions);\n            if (is_1.default.undefined(requestOrResponse)) {\n                requestOrResponse = fallbackFn(url, requestOptions);\n            }\n            // Restore options\n            options.request = request;\n            options.timeout = timeout;\n            options.agent = agent;\n            // HTTPS options restore\n            if (options.https) {\n                if ('rejectUnauthorized' in options.https) {\n                    delete requestOptions.rejectUnauthorized;\n                }\n                if (options.https.checkServerIdentity) {\n                    // @ts-expect-error - This one will be removed when we remove the alias.\n                    delete requestOptions.checkServerIdentity;\n                }\n                if (options.https.certificateAuthority) {\n                    delete requestOptions.ca;\n                }\n                if (options.https.certificate) {\n                    delete requestOptions.cert;\n                }\n                if (options.https.key) {\n                    delete requestOptions.key;\n                }\n                if (options.https.passphrase) {\n                    delete requestOptions.passphrase;\n                }\n                if (options.https.pfx) {\n                    delete requestOptions.pfx;\n                }\n            }\n            if (isClientRequest(requestOrResponse)) {\n                this._onRequest(requestOrResponse);\n                // Emit the response after the stream has been ended\n            }\n            else if (this.writable) {\n                this.once('finish', () => {\n                    void this._onResponse(requestOrResponse);\n                });\n                this._unlockWrite();\n                this.end();\n                this._lockWrite();\n            }\n            else {\n                void this._onResponse(requestOrResponse);\n            }\n        }\n        catch (error) {\n            if (error instanceof CacheableRequest.CacheError) {\n                throw new CacheError(error, this);\n            }\n            throw new RequestError(error.message, error, this);\n        }\n    }\n    async _error(error) {\n        try {\n            for (const hook of this.options.hooks.beforeError) {\n                // eslint-disable-next-line no-await-in-loop\n                error = await hook(error);\n            }\n        }\n        catch (error_) {\n            error = new RequestError(error_.message, error_, this);\n        }\n        this.destroy(error);\n    }\n    _beforeError(error) {\n        if (this[kStopReading]) {\n            return;\n        }\n        const { options } = this;\n        const retryCount = this.retryCount + 1;\n        this[kStopReading] = true;\n        if (!(error instanceof RequestError)) {\n            error = new RequestError(error.message, error, this);\n        }\n        const typedError = error;\n        const { response } = typedError;\n        void (async () => {\n            if (response && !response.body) {\n                response.setEncoding(this._readableState.encoding);\n                try {\n                    response.rawBody = await get_buffer_1.default(response);\n                    response.body = response.rawBody.toString();\n                }\n                catch (_a) { }\n            }\n            if (this.listenerCount('retry') !== 0) {\n                let backoff;\n                try {\n                    let retryAfter;\n                    if (response && 'retry-after' in response.headers) {\n                        retryAfter = Number(response.headers['retry-after']);\n                        if (Number.isNaN(retryAfter)) {\n                            retryAfter = Date.parse(response.headers['retry-after']) - Date.now();\n                            if (retryAfter <= 0) {\n                                retryAfter = 1;\n                            }\n                        }\n                        else {\n                            retryAfter *= 1000;\n                        }\n                    }\n                    backoff = await options.retry.calculateDelay({\n                        attemptCount: retryCount,\n                        retryOptions: options.retry,\n                        error: typedError,\n                        retryAfter,\n                        computedValue: calculate_retry_delay_1.default({\n                            attemptCount: retryCount,\n                            retryOptions: options.retry,\n                            error: typedError,\n                            retryAfter,\n                            computedValue: 0\n                        })\n                    });\n                }\n                catch (error_) {\n                    void this._error(new RequestError(error_.message, error_, this));\n                    return;\n                }\n                if (backoff) {\n                    const retry = async () => {\n                        try {\n                            for (const hook of this.options.hooks.beforeRetry) {\n                                // eslint-disable-next-line no-await-in-loop\n                                await hook(this.options, typedError, retryCount);\n                            }\n                        }\n                        catch (error_) {\n                            void this._error(new RequestError(error_.message, error, this));\n                            return;\n                        }\n                        // Something forced us to abort the retry\n                        if (this.destroyed) {\n                            return;\n                        }\n                        this.destroy();\n                        this.emit('retry', retryCount, error);\n                    };\n                    this[kRetryTimeout] = setTimeout(retry, backoff);\n                    return;\n                }\n            }\n            void this._error(typedError);\n        })();\n    }\n    _read() {\n        this[kTriggerRead] = true;\n        const response = this[kResponse];\n        if (response && !this[kStopReading]) {\n            // We cannot put this in the `if` above\n            // because `.read()` also triggers the `end` event\n            if (response.readableLength) {\n                this[kTriggerRead] = false;\n            }\n            let data;\n            while ((data = response.read()) !== null) {\n                this[kDownloadedSize] += data.length;\n                this[kStartedReading] = true;\n                const progress = this.downloadProgress;\n                if (progress.percent < 1) {\n                    this.emit('downloadProgress', progress);\n                }\n                this.push(data);\n            }\n        }\n    }\n    // Node.js 12 has incorrect types, so the encoding must be a string\n    _write(chunk, encoding, callback) {\n        const write = () => {\n            this._writeRequest(chunk, encoding, callback);\n        };\n        if (this.requestInitialized) {\n            write();\n        }\n        else {\n            this[kJobs].push(write);\n        }\n    }\n    _writeRequest(chunk, encoding, callback) {\n        if (this[kRequest].destroyed) {\n            // Probably the `ClientRequest` instance will throw\n            return;\n        }\n        this._progressCallbacks.push(() => {\n            this[kUploadedSize] += Buffer.byteLength(chunk, encoding);\n            const progress = this.uploadProgress;\n            if (progress.percent < 1) {\n                this.emit('uploadProgress', progress);\n            }\n        });\n        // TODO: What happens if it's from cache? Then this[kRequest] won't be defined.\n        this[kRequest].write(chunk, encoding, (error) => {\n            if (!error && this._progressCallbacks.length > 0) {\n                this._progressCallbacks.shift()();\n            }\n            callback(error);\n        });\n    }\n    _final(callback) {\n        const endRequest = () => {\n            // FIX: Node.js 10 calls the write callback AFTER the end callback!\n            while (this._progressCallbacks.length !== 0) {\n                this._progressCallbacks.shift()();\n            }\n            // We need to check if `this[kRequest]` is present,\n            // because it isn't when we use cache.\n            if (!(kRequest in this)) {\n                callback();\n                return;\n            }\n            if (this[kRequest].destroyed) {\n                callback();\n                return;\n            }\n            this[kRequest].end((error) => {\n                if (!error) {\n                    this[kBodySize] = this[kUploadedSize];\n                    this.emit('uploadProgress', this.uploadProgress);\n                    this[kRequest].emit('upload-complete');\n                }\n                callback(error);\n            });\n        };\n        if (this.requestInitialized) {\n            endRequest();\n        }\n        else {\n            this[kJobs].push(endRequest);\n        }\n    }\n    _destroy(error, callback) {\n        var _a;\n        this[kStopReading] = true;\n        // Prevent further retries\n        clearTimeout(this[kRetryTimeout]);\n        if (kRequest in this) {\n            this[kCancelTimeouts]();\n            // TODO: Remove the next `if` when these get fixed:\n            // - https://github.com/nodejs/node/issues/32851\n            if (!((_a = this[kResponse]) === null || _a === void 0 ? void 0 : _a.complete)) {\n                this[kRequest].destroy();\n            }\n        }\n        if (error !== null && !is_1.default.undefined(error) && !(error instanceof RequestError)) {\n            error = new RequestError(error.message, error, this);\n        }\n        callback(error);\n    }\n    get _isAboutToError() {\n        return this[kStopReading];\n    }\n    /**\n    The remote IP address.\n    */\n    get ip() {\n        var _a;\n        return (_a = this.socket) === null || _a === void 0 ? void 0 : _a.remoteAddress;\n    }\n    /**\n    Indicates whether the request has been aborted or not.\n    */\n    get aborted() {\n        var _a, _b, _c;\n        return ((_b = (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.destroyed) !== null && _b !== void 0 ? _b : this.destroyed) && !((_c = this[kOriginalResponse]) === null || _c === void 0 ? void 0 : _c.complete);\n    }\n    get socket() {\n        var _a, _b;\n        return (_b = (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.socket) !== null && _b !== void 0 ? _b : undefined;\n    }\n    /**\n    Progress event for downloading (receiving a response).\n    */\n    get downloadProgress() {\n        let percent;\n        if (this[kResponseSize]) {\n            percent = this[kDownloadedSize] / this[kResponseSize];\n        }\n        else if (this[kResponseSize] === this[kDownloadedSize]) {\n            percent = 1;\n        }\n        else {\n            percent = 0;\n        }\n        return {\n            percent,\n            transferred: this[kDownloadedSize],\n            total: this[kResponseSize]\n        };\n    }\n    /**\n    Progress event for uploading (sending a request).\n    */\n    get uploadProgress() {\n        let percent;\n        if (this[kBodySize]) {\n            percent = this[kUploadedSize] / this[kBodySize];\n        }\n        else if (this[kBodySize] === this[kUploadedSize]) {\n            percent = 1;\n        }\n        else {\n            percent = 0;\n        }\n        return {\n            percent,\n            transferred: this[kUploadedSize],\n            total: this[kBodySize]\n        };\n    }\n    /**\n    The object contains the following properties:\n\n    - `start` - Time when the request started.\n    - `socket` - Time when a socket was assigned to the request.\n    - `lookup` - Time when the DNS lookup finished.\n    - `connect` - Time when the socket successfully connected.\n    - `secureConnect` - Time when the socket securely connected.\n    - `upload` - Time when the request finished uploading.\n    - `response` - Time when the request fired `response` event.\n    - `end` - Time when the response fired `end` event.\n    - `error` - Time when the request fired `error` event.\n    - `abort` - Time when the request fired `abort` event.\n    - `phases`\n        - `wait` - `timings.socket - timings.start`\n        - `dns` - `timings.lookup - timings.socket`\n        - `tcp` - `timings.connect - timings.lookup`\n        - `tls` - `timings.secureConnect - timings.connect`\n        - `request` - `timings.upload - (timings.secureConnect || timings.connect)`\n        - `firstByte` - `timings.response - timings.upload`\n        - `download` - `timings.end - timings.response`\n        - `total` - `(timings.end || timings.error || timings.abort) - timings.start`\n\n    If something has not been measured yet, it will be `undefined`.\n\n    __Note__: The time is a `number` representing the milliseconds elapsed since the UNIX epoch.\n    */\n    get timings() {\n        var _a;\n        return (_a = this[kRequest]) === null || _a === void 0 ? void 0 : _a.timings;\n    }\n    /**\n    Whether the response was retrieved from the cache.\n    */\n    get isFromCache() {\n        return this[kIsFromCache];\n    }\n    pipe(destination, options) {\n        if (this[kStartedReading]) {\n            throw new Error('Failed to pipe. The response has been emitted already.');\n        }\n        if (destination instanceof http_1.ServerResponse) {\n            this[kServerResponsesPiped].add(destination);\n        }\n        return super.pipe(destination, options);\n    }\n    unpipe(destination) {\n        if (destination instanceof http_1.ServerResponse) {\n            this[kServerResponsesPiped].delete(destination);\n        }\n        super.unpipe(destination);\n        return this;\n    }\n}\nexports[\"default\"] = Request;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/core/index.js?\n}")},"./node_modules/got/dist/source/core/utils/dns-ip-version.js":(__unused_webpack_module,exports)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.dnsLookupIpVersionToFamily = exports.isDnsLookupIpVersion = void 0;\nconst conversionTable = {\n    auto: 0,\n    ipv4: 4,\n    ipv6: 6\n};\nexports.isDnsLookupIpVersion = (value) => {\n    return value in conversionTable;\n};\nexports.dnsLookupIpVersionToFamily = (dnsLookupIpVersion) => {\n    if (exports.isDnsLookupIpVersion(dnsLookupIpVersion)) {\n        return conversionTable[dnsLookupIpVersion];\n    }\n    throw new Error('Invalid DNS lookup IP version');\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/core/utils/dns-ip-version.js?\n}")},"./node_modules/got/dist/source/core/utils/get-body-size.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst fs_1 = __webpack_require__(/*! fs */ "fs");\nconst util_1 = __webpack_require__(/*! util */ "util");\nconst is_1 = __webpack_require__(/*! @sindresorhus/is */ "./node_modules/@sindresorhus/is/dist/index.js");\nconst is_form_data_1 = __webpack_require__(/*! ./is-form-data */ "./node_modules/got/dist/source/core/utils/is-form-data.js");\nconst statAsync = util_1.promisify(fs_1.stat);\nexports["default"] = async (body, headers) => {\n    if (headers && \'content-length\' in headers) {\n        return Number(headers[\'content-length\']);\n    }\n    if (!body) {\n        return 0;\n    }\n    if (is_1.default.string(body)) {\n        return Buffer.byteLength(body);\n    }\n    if (is_1.default.buffer(body)) {\n        return body.length;\n    }\n    if (is_form_data_1.default(body)) {\n        return util_1.promisify(body.getLength.bind(body))();\n    }\n    if (body instanceof fs_1.ReadStream) {\n        const { size } = await statAsync(body.path);\n        if (size === 0) {\n            return undefined;\n        }\n        return size;\n    }\n    return undefined;\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/core/utils/get-body-size.js?\n}')},"./node_modules/got/dist/source/core/utils/get-buffer.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n// TODO: Update https://github.com/sindresorhus/get-stream\nconst getBuffer = async (stream) => {\n    const chunks = [];\n    let length = 0;\n    for await (const chunk of stream) {\n        chunks.push(chunk);\n        length += Buffer.byteLength(chunk);\n    }\n    if (Buffer.isBuffer(chunks[0])) {\n        return Buffer.concat(chunks, length);\n    }\n    return Buffer.from(chunks.join(\'\'));\n};\nexports["default"] = getBuffer;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/core/utils/get-buffer.js?\n}')},"./node_modules/got/dist/source/core/utils/is-form-data.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst is_1 = __webpack_require__(/*! @sindresorhus/is */ "./node_modules/@sindresorhus/is/dist/index.js");\nexports["default"] = (body) => is_1.default.nodeStream(body) && is_1.default.function_(body.getBoundary);\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/core/utils/is-form-data.js?\n}')},"./node_modules/got/dist/source/core/utils/is-response-ok.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nexports.isResponseOk = void 0;\nexports.isResponseOk = (response) => {\n    const { statusCode } = response;\n    const limitStatusCode = response.request.options.followRedirect ? 299 : 399;\n    return (statusCode >= 200 && statusCode <= limitStatusCode) || statusCode === 304;\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/core/utils/is-response-ok.js?\n}')},"./node_modules/got/dist/source/core/utils/options-to-url.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\n/* istanbul ignore file: deprecated */\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst keys = [\n    'protocol',\n    'host',\n    'hostname',\n    'port',\n    'pathname',\n    'search'\n];\nexports[\"default\"] = (origin, options) => {\n    var _a, _b;\n    if (options.path) {\n        if (options.pathname) {\n            throw new TypeError('Parameters `path` and `pathname` are mutually exclusive.');\n        }\n        if (options.search) {\n            throw new TypeError('Parameters `path` and `search` are mutually exclusive.');\n        }\n        if (options.searchParams) {\n            throw new TypeError('Parameters `path` and `searchParams` are mutually exclusive.');\n        }\n    }\n    if (options.search && options.searchParams) {\n        throw new TypeError('Parameters `search` and `searchParams` are mutually exclusive.');\n    }\n    if (!origin) {\n        if (!options.protocol) {\n            throw new TypeError('No URL protocol specified');\n        }\n        origin = `${options.protocol}//${(_b = (_a = options.hostname) !== null && _a !== void 0 ? _a : options.host) !== null && _b !== void 0 ? _b : ''}`;\n    }\n    const url = new url_1.URL(origin);\n    if (options.path) {\n        const searchIndex = options.path.indexOf('?');\n        if (searchIndex === -1) {\n            options.pathname = options.path;\n        }\n        else {\n            options.pathname = options.path.slice(0, searchIndex);\n            options.search = options.path.slice(searchIndex + 1);\n        }\n        delete options.path;\n    }\n    for (const key of keys) {\n        if (options[key]) {\n            url[key] = options[key].toString();\n        }\n    }\n    return url;\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/core/utils/options-to-url.js?\n}")},"./node_modules/got/dist/source/core/utils/proxy-events.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nfunction default_1(from, to, events) {\n    const fns = {};\n    for (const event of events) {\n        fns[event] = (...args) => {\n            to.emit(event, ...args);\n        };\n        from.on(event, fns[event]);\n    }\n    return () => {\n        for (const event of events) {\n            from.off(event, fns[event]);\n        }\n    };\n}\nexports["default"] = default_1;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/core/utils/proxy-events.js?\n}')},"./node_modules/got/dist/source/core/utils/timed-out.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.TimeoutError = void 0;\nconst net = __webpack_require__(/*! net */ \"net\");\nconst unhandle_1 = __webpack_require__(/*! ./unhandle */ \"./node_modules/got/dist/source/core/utils/unhandle.js\");\nconst reentry = Symbol('reentry');\nconst noop = () => { };\nclass TimeoutError extends Error {\n    constructor(threshold, event) {\n        super(`Timeout awaiting '${event}' for ${threshold}ms`);\n        this.event = event;\n        this.name = 'TimeoutError';\n        this.code = 'ETIMEDOUT';\n    }\n}\nexports.TimeoutError = TimeoutError;\nexports[\"default\"] = (request, delays, options) => {\n    if (reentry in request) {\n        return noop;\n    }\n    request[reentry] = true;\n    const cancelers = [];\n    const { once, unhandleAll } = unhandle_1.default();\n    const addTimeout = (delay, callback, event) => {\n        var _a;\n        const timeout = setTimeout(callback, delay, delay, event);\n        (_a = timeout.unref) === null || _a === void 0 ? void 0 : _a.call(timeout);\n        const cancel = () => {\n            clearTimeout(timeout);\n        };\n        cancelers.push(cancel);\n        return cancel;\n    };\n    const { host, hostname } = options;\n    const timeoutHandler = (delay, event) => {\n        request.destroy(new TimeoutError(delay, event));\n    };\n    const cancelTimeouts = () => {\n        for (const cancel of cancelers) {\n            cancel();\n        }\n        unhandleAll();\n    };\n    request.once('error', error => {\n        cancelTimeouts();\n        // Save original behavior\n        /* istanbul ignore next */\n        if (request.listenerCount('error') === 0) {\n            throw error;\n        }\n    });\n    request.once('close', cancelTimeouts);\n    once(request, 'response', (response) => {\n        once(response, 'end', cancelTimeouts);\n    });\n    if (typeof delays.request !== 'undefined') {\n        addTimeout(delays.request, timeoutHandler, 'request');\n    }\n    if (typeof delays.socket !== 'undefined') {\n        const socketTimeoutHandler = () => {\n            timeoutHandler(delays.socket, 'socket');\n        };\n        request.setTimeout(delays.socket, socketTimeoutHandler);\n        // `request.setTimeout(0)` causes a memory leak.\n        // We can just remove the listener and forget about the timer - it's unreffed.\n        // See https://github.com/sindresorhus/got/issues/690\n        cancelers.push(() => {\n            request.removeListener('timeout', socketTimeoutHandler);\n        });\n    }\n    once(request, 'socket', (socket) => {\n        var _a;\n        const { socketPath } = request;\n        /* istanbul ignore next: hard to test */\n        if (socket.connecting) {\n            const hasPath = Boolean(socketPath !== null && socketPath !== void 0 ? socketPath : net.isIP((_a = hostname !== null && hostname !== void 0 ? hostname : host) !== null && _a !== void 0 ? _a : '') !== 0);\n            if (typeof delays.lookup !== 'undefined' && !hasPath && typeof socket.address().address === 'undefined') {\n                const cancelTimeout = addTimeout(delays.lookup, timeoutHandler, 'lookup');\n                once(socket, 'lookup', cancelTimeout);\n            }\n            if (typeof delays.connect !== 'undefined') {\n                const timeConnect = () => addTimeout(delays.connect, timeoutHandler, 'connect');\n                if (hasPath) {\n                    once(socket, 'connect', timeConnect());\n                }\n                else {\n                    once(socket, 'lookup', (error) => {\n                        if (error === null) {\n                            once(socket, 'connect', timeConnect());\n                        }\n                    });\n                }\n            }\n            if (typeof delays.secureConnect !== 'undefined' && options.protocol === 'https:') {\n                once(socket, 'connect', () => {\n                    const cancelTimeout = addTimeout(delays.secureConnect, timeoutHandler, 'secureConnect');\n                    once(socket, 'secureConnect', cancelTimeout);\n                });\n            }\n        }\n        if (typeof delays.send !== 'undefined') {\n            const timeRequest = () => addTimeout(delays.send, timeoutHandler, 'send');\n            /* istanbul ignore next: hard to test */\n            if (socket.connecting) {\n                once(socket, 'connect', () => {\n                    once(request, 'upload-complete', timeRequest());\n                });\n            }\n            else {\n                once(request, 'upload-complete', timeRequest());\n            }\n        }\n    });\n    if (typeof delays.response !== 'undefined') {\n        once(request, 'upload-complete', () => {\n            const cancelTimeout = addTimeout(delays.response, timeoutHandler, 'response');\n            once(request, 'response', cancelTimeout);\n        });\n    }\n    return cancelTimeouts;\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/core/utils/timed-out.js?\n}")},"./node_modules/got/dist/source/core/utils/unhandle.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n// When attaching listeners, it\'s very easy to forget about them.\n// Especially if you do error handling and set timeouts.\n// So instead of checking if it\'s proper to throw an error on every timeout ever,\n// use this simple tool which will remove all listeners you have attached.\nexports["default"] = () => {\n    const handlers = [];\n    return {\n        once(origin, event, fn) {\n            origin.once(event, fn);\n            handlers.push({ origin, event, fn });\n        },\n        unhandleAll() {\n            for (const handler of handlers) {\n                const { origin, event, fn } = handler;\n                origin.removeListener(event, fn);\n            }\n            handlers.length = 0;\n        }\n    };\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/core/utils/unhandle.js?\n}')},"./node_modules/got/dist/source/core/utils/url-to-options.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst is_1 = __webpack_require__(/*! @sindresorhus/is */ \"./node_modules/@sindresorhus/is/dist/index.js\");\nexports[\"default\"] = (url) => {\n    // Cast to URL\n    url = url;\n    const options = {\n        protocol: url.protocol,\n        hostname: is_1.default.string(url.hostname) && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,\n        host: url.host,\n        hash: url.hash,\n        search: url.search,\n        pathname: url.pathname,\n        href: url.href,\n        path: `${url.pathname || ''}${url.search || ''}`\n    };\n    if (is_1.default.string(url.port) && url.port.length > 0) {\n        options.port = Number(url.port);\n    }\n    if (url.username || url.password) {\n        options.auth = `${url.username || ''}:${url.password || ''}`;\n    }\n    return options;\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/core/utils/url-to-options.js?\n}")},"./node_modules/got/dist/source/core/utils/weakable-map.js":(__unused_webpack_module,exports)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nclass WeakableMap {\n    constructor() {\n        this.weakMap = new WeakMap();\n        this.map = new Map();\n    }\n    set(key, value) {\n        if (typeof key === 'object') {\n            this.weakMap.set(key, value);\n        }\n        else {\n            this.map.set(key, value);\n        }\n    }\n    get(key) {\n        if (typeof key === 'object') {\n            return this.weakMap.get(key);\n        }\n        return this.map.get(key);\n    }\n    has(key) {\n        if (typeof key === 'object') {\n            return this.weakMap.has(key);\n        }\n        return this.map.has(key);\n    }\n}\nexports[\"default\"] = WeakableMap;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/core/utils/weakable-map.js?\n}")},"./node_modules/got/dist/source/create.js":function(__unused_webpack_module,exports,__webpack_require__){"use strict";eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.defaultHandler = void 0;\nconst is_1 = __webpack_require__(/*! @sindresorhus/is */ \"./node_modules/@sindresorhus/is/dist/index.js\");\nconst as_promise_1 = __webpack_require__(/*! ./as-promise */ \"./node_modules/got/dist/source/as-promise/index.js\");\nconst create_rejection_1 = __webpack_require__(/*! ./as-promise/create-rejection */ \"./node_modules/got/dist/source/as-promise/create-rejection.js\");\nconst core_1 = __webpack_require__(/*! ./core */ \"./node_modules/got/dist/source/core/index.js\");\nconst deep_freeze_1 = __webpack_require__(/*! ./utils/deep-freeze */ \"./node_modules/got/dist/source/utils/deep-freeze.js\");\nconst errors = {\n    RequestError: as_promise_1.RequestError,\n    CacheError: as_promise_1.CacheError,\n    ReadError: as_promise_1.ReadError,\n    HTTPError: as_promise_1.HTTPError,\n    MaxRedirectsError: as_promise_1.MaxRedirectsError,\n    TimeoutError: as_promise_1.TimeoutError,\n    ParseError: as_promise_1.ParseError,\n    CancelError: as_promise_1.CancelError,\n    UnsupportedProtocolError: as_promise_1.UnsupportedProtocolError,\n    UploadError: as_promise_1.UploadError\n};\n// The `delay` package weighs 10KB (!)\nconst delay = async (ms) => new Promise(resolve => {\n    setTimeout(resolve, ms);\n});\nconst { normalizeArguments } = core_1.default;\nconst mergeOptions = (...sources) => {\n    let mergedOptions;\n    for (const source of sources) {\n        mergedOptions = normalizeArguments(undefined, source, mergedOptions);\n    }\n    return mergedOptions;\n};\nconst getPromiseOrStream = (options) => options.isStream ? new core_1.default(undefined, options) : as_promise_1.default(options);\nconst isGotInstance = (value) => ('defaults' in value && 'options' in value.defaults);\nconst aliases = [\n    'get',\n    'post',\n    'put',\n    'patch',\n    'head',\n    'delete'\n];\nexports.defaultHandler = (options, next) => next(options);\nconst callInitHooks = (hooks, options) => {\n    if (hooks) {\n        for (const hook of hooks) {\n            hook(options);\n        }\n    }\n};\nconst create = (defaults) => {\n    // Proxy properties from next handlers\n    defaults._rawHandlers = defaults.handlers;\n    defaults.handlers = defaults.handlers.map(fn => ((options, next) => {\n        // This will be assigned by assigning result\n        let root;\n        const result = fn(options, newOptions => {\n            root = next(newOptions);\n            return root;\n        });\n        if (result !== root && !options.isStream && root) {\n            const typedResult = result;\n            const { then: promiseThen, catch: promiseCatch, finally: promiseFianlly } = typedResult;\n            Object.setPrototypeOf(typedResult, Object.getPrototypeOf(root));\n            Object.defineProperties(typedResult, Object.getOwnPropertyDescriptors(root));\n            // These should point to the new promise\n            // eslint-disable-next-line promise/prefer-await-to-then\n            typedResult.then = promiseThen;\n            typedResult.catch = promiseCatch;\n            typedResult.finally = promiseFianlly;\n        }\n        return result;\n    }));\n    // Got interface\n    const got = ((url, options = {}, _defaults) => {\n        var _a, _b;\n        let iteration = 0;\n        const iterateHandlers = (newOptions) => {\n            return defaults.handlers[iteration++](newOptions, iteration === defaults.handlers.length ? getPromiseOrStream : iterateHandlers);\n        };\n        // TODO: Remove this in Got 12.\n        if (is_1.default.plainObject(url)) {\n            const mergedOptions = {\n                ...url,\n                ...options\n            };\n            core_1.setNonEnumerableProperties([url, options], mergedOptions);\n            options = mergedOptions;\n            url = undefined;\n        }\n        try {\n            // Call `init` hooks\n            let initHookError;\n            try {\n                callInitHooks(defaults.options.hooks.init, options);\n                callInitHooks((_a = options.hooks) === null || _a === void 0 ? void 0 : _a.init, options);\n            }\n            catch (error) {\n                initHookError = error;\n            }\n            // Normalize options & call handlers\n            const normalizedOptions = normalizeArguments(url, options, _defaults !== null && _defaults !== void 0 ? _defaults : defaults.options);\n            normalizedOptions[core_1.kIsNormalizedAlready] = true;\n            if (initHookError) {\n                throw new as_promise_1.RequestError(initHookError.message, initHookError, normalizedOptions);\n            }\n            return iterateHandlers(normalizedOptions);\n        }\n        catch (error) {\n            if (options.isStream) {\n                throw error;\n            }\n            else {\n                return create_rejection_1.default(error, defaults.options.hooks.beforeError, (_b = options.hooks) === null || _b === void 0 ? void 0 : _b.beforeError);\n            }\n        }\n    });\n    got.extend = (...instancesOrOptions) => {\n        const optionsArray = [defaults.options];\n        let handlers = [...defaults._rawHandlers];\n        let isMutableDefaults;\n        for (const value of instancesOrOptions) {\n            if (isGotInstance(value)) {\n                optionsArray.push(value.defaults.options);\n                handlers.push(...value.defaults._rawHandlers);\n                isMutableDefaults = value.defaults.mutableDefaults;\n            }\n            else {\n                optionsArray.push(value);\n                if ('handlers' in value) {\n                    handlers.push(...value.handlers);\n                }\n                isMutableDefaults = value.mutableDefaults;\n            }\n        }\n        handlers = handlers.filter(handler => handler !== exports.defaultHandler);\n        if (handlers.length === 0) {\n            handlers.push(exports.defaultHandler);\n        }\n        return create({\n            options: mergeOptions(...optionsArray),\n            handlers,\n            mutableDefaults: Boolean(isMutableDefaults)\n        });\n    };\n    // Pagination\n    const paginateEach = (async function* (url, options) {\n        // TODO: Remove this `@ts-expect-error` when upgrading to TypeScript 4.\n        // Error: Argument of type 'Merge<Options, PaginationOptions<T, R>> | undefined' is not assignable to parameter of type 'Options | undefined'.\n        // @ts-expect-error\n        let normalizedOptions = normalizeArguments(url, options, defaults.options);\n        normalizedOptions.resolveBodyOnly = false;\n        const pagination = normalizedOptions.pagination;\n        if (!is_1.default.object(pagination)) {\n            throw new TypeError('`options.pagination` must be implemented');\n        }\n        const all = [];\n        let { countLimit } = pagination;\n        let numberOfRequests = 0;\n        while (numberOfRequests < pagination.requestLimit) {\n            if (numberOfRequests !== 0) {\n                // eslint-disable-next-line no-await-in-loop\n                await delay(pagination.backoff);\n            }\n            // @ts-expect-error FIXME!\n            // TODO: Throw when result is not an instance of Response\n            // eslint-disable-next-line no-await-in-loop\n            const result = (await got(undefined, undefined, normalizedOptions));\n            // eslint-disable-next-line no-await-in-loop\n            const parsed = await pagination.transform(result);\n            const current = [];\n            for (const item of parsed) {\n                if (pagination.filter(item, all, current)) {\n                    if (!pagination.shouldContinue(item, all, current)) {\n                        return;\n                    }\n                    yield item;\n                    if (pagination.stackAllItems) {\n                        all.push(item);\n                    }\n                    current.push(item);\n                    if (--countLimit <= 0) {\n                        return;\n                    }\n                }\n            }\n            const optionsToMerge = pagination.paginate(result, all, current);\n            if (optionsToMerge === false) {\n                return;\n            }\n            if (optionsToMerge === result.request.options) {\n                normalizedOptions = result.request.options;\n            }\n            else if (optionsToMerge !== undefined) {\n                normalizedOptions = normalizeArguments(undefined, optionsToMerge, normalizedOptions);\n            }\n            numberOfRequests++;\n        }\n    });\n    got.paginate = paginateEach;\n    got.paginate.all = (async (url, options) => {\n        const results = [];\n        for await (const item of paginateEach(url, options)) {\n            results.push(item);\n        }\n        return results;\n    });\n    // For those who like very descriptive names\n    got.paginate.each = paginateEach;\n    // Stream API\n    got.stream = ((url, options) => got(url, { ...options, isStream: true }));\n    // Shortcuts\n    for (const method of aliases) {\n        got[method] = ((url, options) => got(url, { ...options, method }));\n        got.stream[method] = ((url, options) => {\n            return got(url, { ...options, method, isStream: true });\n        });\n    }\n    Object.assign(got, errors);\n    Object.defineProperty(got, 'defaults', {\n        value: defaults.mutableDefaults ? defaults : deep_freeze_1.default(defaults),\n        writable: defaults.mutableDefaults,\n        configurable: defaults.mutableDefaults,\n        enumerable: true\n    });\n    got.mergeOptions = mergeOptions;\n    return got;\n};\nexports[\"default\"] = create;\n__exportStar(__webpack_require__(/*! ./types */ \"./node_modules/got/dist/source/types.js\"), exports);\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/create.js?\n}")},"./node_modules/got/dist/source/index.js":function(module,exports,__webpack_require__){"use strict";eval("{\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst url_1 = __webpack_require__(/*! url */ \"url\");\nconst create_1 = __webpack_require__(/*! ./create */ \"./node_modules/got/dist/source/create.js\");\nconst defaults = {\n    options: {\n        method: 'GET',\n        retry: {\n            limit: 2,\n            methods: [\n                'GET',\n                'PUT',\n                'HEAD',\n                'DELETE',\n                'OPTIONS',\n                'TRACE'\n            ],\n            statusCodes: [\n                408,\n                413,\n                429,\n                500,\n                502,\n                503,\n                504,\n                521,\n                522,\n                524\n            ],\n            errorCodes: [\n                'ETIMEDOUT',\n                'ECONNRESET',\n                'EADDRINUSE',\n                'ECONNREFUSED',\n                'EPIPE',\n                'ENOTFOUND',\n                'ENETUNREACH',\n                'EAI_AGAIN'\n            ],\n            maxRetryAfter: undefined,\n            calculateDelay: ({ computedValue }) => computedValue\n        },\n        timeout: {},\n        headers: {\n            'user-agent': 'got (https://github.com/sindresorhus/got)'\n        },\n        hooks: {\n            init: [],\n            beforeRequest: [],\n            beforeRedirect: [],\n            beforeRetry: [],\n            beforeError: [],\n            afterResponse: []\n        },\n        cache: undefined,\n        dnsCache: undefined,\n        decompress: true,\n        throwHttpErrors: true,\n        followRedirect: true,\n        isStream: false,\n        responseType: 'text',\n        resolveBodyOnly: false,\n        maxRedirects: 10,\n        prefixUrl: '',\n        methodRewriting: true,\n        ignoreInvalidCookies: false,\n        context: {},\n        // TODO: Set this to `true` when Got 12 gets released\n        http2: false,\n        allowGetBody: false,\n        https: undefined,\n        pagination: {\n            transform: (response) => {\n                if (response.request.options.responseType === 'json') {\n                    return response.body;\n                }\n                return JSON.parse(response.body);\n            },\n            paginate: response => {\n                if (!Reflect.has(response.headers, 'link')) {\n                    return false;\n                }\n                const items = response.headers.link.split(',');\n                let next;\n                for (const item of items) {\n                    const parsed = item.split(';');\n                    if (parsed[1].includes('next')) {\n                        next = parsed[0].trimStart().trim();\n                        next = next.slice(1, -1);\n                        break;\n                    }\n                }\n                if (next) {\n                    const options = {\n                        url: new url_1.URL(next)\n                    };\n                    return options;\n                }\n                return false;\n            },\n            filter: () => true,\n            shouldContinue: () => true,\n            countLimit: Infinity,\n            backoff: 0,\n            requestLimit: 10000,\n            stackAllItems: true\n        },\n        parseJson: (text) => JSON.parse(text),\n        stringifyJson: (object) => JSON.stringify(object),\n        cacheOptions: {}\n    },\n    handlers: [create_1.defaultHandler],\n    mutableDefaults: false\n};\nconst got = create_1.default(defaults);\nexports[\"default\"] = got;\n// For CommonJS default export support\nmodule.exports = got;\nmodule.exports[\"default\"] = got;\nmodule.exports.__esModule = true; // Workaround for TS issue: https://github.com/sindresorhus/got/pull/1267\n__exportStar(__webpack_require__(/*! ./create */ \"./node_modules/got/dist/source/create.js\"), exports);\n__exportStar(__webpack_require__(/*! ./as-promise */ \"./node_modules/got/dist/source/as-promise/index.js\"), exports);\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/index.js?\n}")},"./node_modules/got/dist/source/types.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/types.js?\n}')},"./node_modules/got/dist/source/utils/deep-freeze.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst is_1 = __webpack_require__(/*! @sindresorhus/is */ "./node_modules/@sindresorhus/is/dist/index.js");\nfunction deepFreeze(object) {\n    for (const value of Object.values(object)) {\n        if (is_1.default.plainObject(value) || is_1.default.array(value)) {\n            deepFreeze(value);\n        }\n    }\n    return Object.freeze(object);\n}\nexports["default"] = deepFreeze;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/utils/deep-freeze.js?\n}')},"./node_modules/got/dist/source/utils/deprecation-warning.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst alreadyWarned = new Set();\nexports["default"] = (message) => {\n    if (alreadyWarned.has(message)) {\n        return;\n    }\n    alreadyWarned.add(message);\n    // @ts-expect-error Missing types.\n    process.emitWarning(`Got: ${message}`, {\n        type: \'DeprecationWarning\'\n    });\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/got/dist/source/utils/deprecation-warning.js?\n}')},"./node_modules/http-cache-semantics/index.js":module=>{"use strict";eval("{\n\n/**\n * @typedef {Object} HttpRequest\n * @property {Record<string, string>} headers - Request headers\n * @property {string} [method] - HTTP method\n * @property {string} [url] - Request URL\n */\n\n/**\n * @typedef {Object} HttpResponse\n * @property {Record<string, string>} headers - Response headers\n * @property {number} [status] - HTTP status code\n */\n\n/**\n * Set of default cacheable status codes per RFC 7231 section 6.1.\n * @type {Set<number>}\n */\nconst statusCodeCacheableByDefault = new Set([\n    200,\n    203,\n    204,\n    206,\n    300,\n    301,\n    308,\n    404,\n    405,\n    410,\n    414,\n    501,\n]);\n\n/**\n * Set of HTTP status codes that the cache implementation understands.\n * Note: This implementation does not understand partial responses (206).\n * @type {Set<number>}\n */\nconst understoodStatuses = new Set([\n    200,\n    203,\n    204,\n    300,\n    301,\n    302,\n    303,\n    307,\n    308,\n    404,\n    405,\n    410,\n    414,\n    501,\n]);\n\n/**\n * Set of HTTP error status codes.\n * @type {Set<number>}\n */\nconst errorStatusCodes = new Set([\n    500,\n    502,\n    503,\n    504,\n]);\n\n/**\n * Object representing hop-by-hop headers that should be removed.\n * @type {Record<string, boolean>}\n */\nconst hopByHopHeaders = {\n    date: true, // included, because we add Age update Date\n    connection: true,\n    'keep-alive': true,\n    'proxy-authenticate': true,\n    'proxy-authorization': true,\n    te: true,\n    trailer: true,\n    'transfer-encoding': true,\n    upgrade: true,\n};\n\n/**\n * Headers that are excluded from revalidation update.\n * @type {Record<string, boolean>}\n */\nconst excludedFromRevalidationUpdate = {\n    // Since the old body is reused, it doesn't make sense to change properties of the body\n    'content-length': true,\n    'content-encoding': true,\n    'transfer-encoding': true,\n    'content-range': true,\n};\n\n/**\n * Converts a string to a number or returns zero if the conversion fails.\n * @param {string} s - The string to convert.\n * @returns {number} The parsed number or 0.\n */\nfunction toNumberOrZero(s) {\n    const n = parseInt(s, 10);\n    return isFinite(n) ? n : 0;\n}\n\n/**\n * Determines if the given response is an error response.\n * Implements RFC 5861 behavior.\n * @param {HttpResponse|undefined} response - The HTTP response object.\n * @returns {boolean} true if the response is an error or undefined, false otherwise.\n */\nfunction isErrorResponse(response) {\n    // consider undefined response as faulty\n    if (!response) {\n        return true;\n    }\n    return errorStatusCodes.has(response.status);\n}\n\n/**\n * Parses a Cache-Control header string into an object.\n * @param {string} [header] - The Cache-Control header value.\n * @returns {Record<string, string|boolean>} An object representing Cache-Control directives.\n */\nfunction parseCacheControl(header) {\n    /** @type {Record<string, string|boolean>} */\n    const cc = {};\n    if (!header) return cc;\n\n    // TODO: When there is more than one value present for a given directive (e.g., two Expires header fields, multiple Cache-Control: max-age directives),\n    // the directive's value is considered invalid. Caches are encouraged to consider responses that have invalid freshness information to be stale\n    const parts = header.trim().split(/,/);\n    for (const part of parts) {\n        const [k, v] = part.split(/=/, 2);\n        cc[k.trim()] = v === undefined ? true : v.trim().replace(/^\"|\"$/g, '');\n    }\n\n    return cc;\n}\n\n/**\n * Formats a Cache-Control directives object into a header string.\n * @param {Record<string, string|boolean>} cc - The Cache-Control directives.\n * @returns {string|undefined} A formatted Cache-Control header string or undefined if empty.\n */\nfunction formatCacheControl(cc) {\n    let parts = [];\n    for (const k in cc) {\n        const v = cc[k];\n        parts.push(v === true ? k : k + '=' + v);\n    }\n    if (!parts.length) {\n        return undefined;\n    }\n    return parts.join(', ');\n}\n\nmodule.exports = class CachePolicy {\n    /**\n     * Creates a new CachePolicy instance.\n     * @param {HttpRequest} req - Incoming client request.\n     * @param {HttpResponse} res - Received server response.\n     * @param {Object} [options={}] - Configuration options.\n     * @param {boolean} [options.shared=true] - Is the cache shared (a public proxy)? `false` for personal browser caches.\n     * @param {number} [options.cacheHeuristic=0.1] - Fallback heuristic (age fraction) for cache duration.\n     * @param {number} [options.immutableMinTimeToLive=86400000] - Minimum TTL for immutable responses in milliseconds.\n     * @param {boolean} [options.ignoreCargoCult=false] - Detect nonsense cache headers, and override them.\n     * @param {any} [options._fromObject] - Internal parameter for deserialization. Do not use.\n     */\n    constructor(\n        req,\n        res,\n        {\n            shared,\n            cacheHeuristic,\n            immutableMinTimeToLive,\n            ignoreCargoCult,\n            _fromObject,\n        } = {}\n    ) {\n        if (_fromObject) {\n            this._fromObject(_fromObject);\n            return;\n        }\n\n        if (!res || !res.headers) {\n            throw Error('Response headers missing');\n        }\n        this._assertRequestHasHeaders(req);\n\n        /** @type {number} Timestamp when the response was received */\n        this._responseTime = this.now();\n        /** @type {boolean} Indicates if the cache is shared */\n        this._isShared = shared !== false;\n        /** @type {boolean} Indicates if legacy cargo cult directives should be ignored */\n        this._ignoreCargoCult = !!ignoreCargoCult;\n        /** @type {number} Heuristic cache fraction */\n        this._cacheHeuristic =\n            undefined !== cacheHeuristic ? cacheHeuristic : 0.1; // 10% matches IE\n        /** @type {number} Minimum TTL for immutable responses in ms */\n        this._immutableMinTtl =\n            undefined !== immutableMinTimeToLive\n                ? immutableMinTimeToLive\n                : 24 * 3600 * 1000;\n\n        /** @type {number} HTTP status code */\n        this._status = 'status' in res ? res.status : 200;\n        /** @type {Record<string, string>} Response headers */\n        this._resHeaders = res.headers;\n        /** @type {Record<string, string|boolean>} Parsed Cache-Control directives from response */\n        this._rescc = parseCacheControl(res.headers['cache-control']);\n        /** @type {string} HTTP method (e.g., GET, POST) */\n        this._method = 'method' in req ? req.method : 'GET';\n        /** @type {string} Request URL */\n        this._url = req.url;\n        /** @type {string} Host header from the request */\n        this._host = req.headers.host;\n        /** @type {boolean} Whether the request does not include an Authorization header */\n        this._noAuthorization = !req.headers.authorization;\n        /** @type {Record<string, string>|null} Request headers used for Vary matching */\n        this._reqHeaders = res.headers.vary ? req.headers : null; // Don't keep all request headers if they won't be used\n        /** @type {Record<string, string|boolean>} Parsed Cache-Control directives from request */\n        this._reqcc = parseCacheControl(req.headers['cache-control']);\n\n        // Assume that if someone uses legacy, non-standard uncecessary options they don't understand caching,\n        // so there's no point stricly adhering to the blindly copy&pasted directives.\n        if (\n            this._ignoreCargoCult &&\n            'pre-check' in this._rescc &&\n            'post-check' in this._rescc\n        ) {\n            delete this._rescc['pre-check'];\n            delete this._rescc['post-check'];\n            delete this._rescc['no-cache'];\n            delete this._rescc['no-store'];\n            delete this._rescc['must-revalidate'];\n            this._resHeaders = Object.assign({}, this._resHeaders, {\n                'cache-control': formatCacheControl(this._rescc),\n            });\n            delete this._resHeaders.expires;\n            delete this._resHeaders.pragma;\n        }\n\n        // When the Cache-Control header field is not present in a request, caches MUST consider the no-cache request pragma-directive\n        // as having the same effect as if \"Cache-Control: no-cache\" were present (see Section 5.2.1).\n        if (\n            res.headers['cache-control'] == null &&\n            /no-cache/.test(res.headers.pragma)\n        ) {\n            this._rescc['no-cache'] = true;\n        }\n    }\n\n    /**\n     * You can monkey-patch it for testing.\n     * @returns {number} Current time in milliseconds.\n     */\n    now() {\n        return Date.now();\n    }\n\n    /**\n     * Determines if the response is storable in a cache.\n     * @returns {boolean} `false` if can never be cached.\n     */\n    storable() {\n        // The \"no-store\" request directive indicates that a cache MUST NOT store any part of either this request or any response to it.\n        return !!(\n            !this._reqcc['no-store'] &&\n            // A cache MUST NOT store a response to any request, unless:\n            // The request method is understood by the cache and defined as being cacheable, and\n            ('GET' === this._method ||\n                'HEAD' === this._method ||\n                ('POST' === this._method && this._hasExplicitExpiration())) &&\n            // the response status code is understood by the cache, and\n            understoodStatuses.has(this._status) &&\n            // the \"no-store\" cache directive does not appear in request or response header fields, and\n            !this._rescc['no-store'] &&\n            // the \"private\" response directive does not appear in the response, if the cache is shared, and\n            (!this._isShared || !this._rescc.private) &&\n            // the Authorization header field does not appear in the request, if the cache is shared,\n            (!this._isShared ||\n                this._noAuthorization ||\n                this._allowsStoringAuthenticated()) &&\n            // the response either:\n            // contains an Expires header field, or\n            (this._resHeaders.expires ||\n                // contains a max-age response directive, or\n                // contains a s-maxage response directive and the cache is shared, or\n                // contains a public response directive.\n                this._rescc['max-age'] ||\n                (this._isShared && this._rescc['s-maxage']) ||\n                this._rescc.public ||\n                // has a status code that is defined as cacheable by default\n                statusCodeCacheableByDefault.has(this._status))\n        );\n    }\n\n    /**\n     * @returns {boolean} true if expiration is explicitly defined.\n     */\n    _hasExplicitExpiration() {\n        // 4.2.1 Calculating Freshness Lifetime\n        return !!(\n            (this._isShared && this._rescc['s-maxage']) ||\n            this._rescc['max-age'] ||\n            this._resHeaders.expires\n        );\n    }\n\n    /**\n     * @param {HttpRequest} req - a request\n     * @throws {Error} if the headers are missing.\n     */\n    _assertRequestHasHeaders(req) {\n        if (!req || !req.headers) {\n            throw Error('Request headers missing');\n        }\n    }\n\n    /**\n     * Checks if the request matches the cache and can be satisfied from the cache immediately,\n     * without having to make a request to the server.\n     *\n     * This doesn't support `stale-while-revalidate`. See `evaluateRequest()` for a more complete solution.\n     *\n     * @param {HttpRequest} req - The new incoming HTTP request.\n     * @returns {boolean} `true`` if the cached response used to construct this cache policy satisfies the request without revalidation.\n     */\n    satisfiesWithoutRevalidation(req) {\n        const result = this.evaluateRequest(req);\n        return !result.revalidation;\n    }\n\n    /**\n     * @param {{headers: Record<string, string>, synchronous: boolean}|undefined} revalidation - Revalidation information, if any.\n     * @returns {{response: {headers: Record<string, string>}, revalidation: {headers: Record<string, string>, synchronous: boolean}|undefined}} An object with a cached response headers and revalidation info.\n     */\n    _evaluateRequestHitResult(revalidation) {\n        return {\n            response: {\n                headers: this.responseHeaders(),\n            },\n            revalidation,\n        };\n    }\n\n    /**\n     * @param {HttpRequest} request - new incoming\n     * @param {boolean} synchronous - whether revalidation must be synchronous (not s-w-r).\n     * @returns {{headers: Record<string, string>, synchronous: boolean}} An object with revalidation headers and a synchronous flag.\n     */\n    _evaluateRequestRevalidation(request, synchronous) {\n        return {\n            synchronous,\n            headers: this.revalidationHeaders(request),\n        };\n    }\n\n    /**\n     * @param {HttpRequest} request - new incoming\n     * @returns {{response: undefined, revalidation: {headers: Record<string, string>, synchronous: boolean}}} An object indicating no cached response and revalidation details.\n     */\n    _evaluateRequestMissResult(request) {\n        return {\n            response: undefined,\n            revalidation: this._evaluateRequestRevalidation(request, true),\n        };\n    }\n\n    /**\n     * Checks if the given request matches this cache entry, and how the cache can be used to satisfy it. Returns an object with:\n     *\n     * ```\n     * {\n     *     // If defined, you must send a request to the server.\n     *     revalidation: {\n     *         headers: {}, // HTTP headers to use when sending the revalidation response\n     *         // If true, you MUST wait for a response from the server before using the cache\n     *         // If false, this is stale-while-revalidate. The cache is stale, but you can use it while you update it asynchronously.\n     *         synchronous: bool,\n     *     },\n     *     // If defined, you can use this cached response.\n     *     response: {\n     *         headers: {}, // Updated cached HTTP headers you must use when responding to the client\n     *     },\n     * }\n     * ```\n     * @param {HttpRequest} req - new incoming HTTP request\n     * @returns {{response: {headers: Record<string, string>}|undefined, revalidation: {headers: Record<string, string>, synchronous: boolean}|undefined}} An object containing keys:\n     *   - revalidation: { headers: Record<string, string>, synchronous: boolean } Set if you should send this to the origin server\n     *   - response: { headers: Record<string, string> } Set if you can respond to the client with these cached headers\n     */\n    evaluateRequest(req) {\n        this._assertRequestHasHeaders(req);\n\n        // In all circumstances, a cache MUST NOT ignore the must-revalidate directive\n        if (this._rescc['must-revalidate']) {\n            return this._evaluateRequestMissResult(req);\n        }\n\n        if (!this._requestMatches(req, false)) {\n            return this._evaluateRequestMissResult(req);\n        }\n\n        // When presented with a request, a cache MUST NOT reuse a stored response, unless:\n        // the presented request does not contain the no-cache pragma (Section 5.4), nor the no-cache cache directive,\n        // unless the stored response is successfully validated (Section 4.3), and\n        const requestCC = parseCacheControl(req.headers['cache-control']);\n\n        if (requestCC['no-cache'] || /no-cache/.test(req.headers.pragma)) {\n            return this._evaluateRequestMissResult(req);\n        }\n\n        if (requestCC['max-age'] && this.age() > toNumberOrZero(requestCC['max-age'])) {\n            return this._evaluateRequestMissResult(req);\n        }\n\n        if (requestCC['min-fresh'] && this.maxAge() - this.age() < toNumberOrZero(requestCC['min-fresh'])) {\n            return this._evaluateRequestMissResult(req);\n        }\n\n        // the stored response is either:\n        // fresh, or allowed to be served stale\n        if (this.stale()) {\n            // If a value is present, then the client is willing to accept a response that has\n            // exceeded its freshness lifetime by no more than the specified number of seconds\n            const allowsStaleWithoutRevalidation = 'max-stale' in requestCC &&\n                (true === requestCC['max-stale'] || requestCC['max-stale'] > this.age() - this.maxAge());\n\n            if (allowsStaleWithoutRevalidation) {\n                return this._evaluateRequestHitResult(undefined);\n            }\n\n            if (this.useStaleWhileRevalidate()) {\n                return this._evaluateRequestHitResult(this._evaluateRequestRevalidation(req, false));\n            }\n\n            return this._evaluateRequestMissResult(req);\n        }\n\n        return this._evaluateRequestHitResult(undefined);\n    }\n\n    /**\n     * @param {HttpRequest} req - check if this is for the same cache entry\n     * @param {boolean} allowHeadMethod - allow a HEAD method to match.\n     * @returns {boolean} `true` if the request matches.\n     */\n    _requestMatches(req, allowHeadMethod) {\n        // The presented effective request URI and that of the stored response match, and\n        return !!(\n            (!this._url || this._url === req.url) &&\n            this._host === req.headers.host &&\n            // the request method associated with the stored response allows it to be used for the presented request, and\n            (!req.method ||\n                this._method === req.method ||\n                (allowHeadMethod && 'HEAD' === req.method)) &&\n            // selecting header fields nominated by the stored response (if any) match those presented, and\n            this._varyMatches(req)\n        );\n    }\n\n    /**\n     * Determines whether storing authenticated responses is allowed.\n     * @returns {boolean} `true` if allowed.\n     */\n    _allowsStoringAuthenticated() {\n        // following Cache-Control response directives (Section 5.2.2) have such an effect: must-revalidate, public, and s-maxage.\n        return !!(\n            this._rescc['must-revalidate'] ||\n            this._rescc.public ||\n            this._rescc['s-maxage']\n        );\n    }\n\n    /**\n     * Checks whether the Vary header in the response matches the new request.\n     * @param {HttpRequest} req - incoming HTTP request\n     * @returns {boolean} `true` if the vary headers match.\n     */\n    _varyMatches(req) {\n        if (!this._resHeaders.vary) {\n            return true;\n        }\n\n        // A Vary header field-value of \"*\" always fails to match\n        if (this._resHeaders.vary === '*') {\n            return false;\n        }\n\n        const fields = this._resHeaders.vary\n            .trim()\n            .toLowerCase()\n            .split(/\\s*,\\s*/);\n        for (const name of fields) {\n            if (req.headers[name] !== this._reqHeaders[name]) return false;\n        }\n        return true;\n    }\n\n    /**\n     * Creates a copy of the given headers without any hop-by-hop headers.\n     * @param {Record<string, string>} inHeaders - old headers from the cached response\n     * @returns {Record<string, string>} A new headers object without hop-by-hop headers.\n     */\n    _copyWithoutHopByHopHeaders(inHeaders) {\n        /** @type {Record<string, string>} */\n        const headers = {};\n        for (const name in inHeaders) {\n            if (hopByHopHeaders[name]) continue;\n            headers[name] = inHeaders[name];\n        }\n        // 9.1.  Connection\n        if (inHeaders.connection) {\n            const tokens = inHeaders.connection.trim().split(/\\s*,\\s*/);\n            for (const name of tokens) {\n                delete headers[name];\n            }\n        }\n        if (headers.warning) {\n            const warnings = headers.warning.split(/,/).filter(warning => {\n                return !/^\\s*1[0-9][0-9]/.test(warning);\n            });\n            if (!warnings.length) {\n                delete headers.warning;\n            } else {\n                headers.warning = warnings.join(',').trim();\n            }\n        }\n        return headers;\n    }\n\n    /**\n     * Returns the response headers adjusted for serving the cached response.\n     * Removes hop-by-hop headers and updates the Age and Date headers.\n     * @returns {Record<string, string>} The adjusted response headers.\n     */\n    responseHeaders() {\n        const headers = this._copyWithoutHopByHopHeaders(this._resHeaders);\n        const age = this.age();\n\n        // A cache SHOULD generate 113 warning if it heuristically chose a freshness\n        // lifetime greater than 24 hours and the response's age is greater than 24 hours.\n        if (\n            age > 3600 * 24 &&\n            !this._hasExplicitExpiration() &&\n            this.maxAge() > 3600 * 24\n        ) {\n            headers.warning =\n                (headers.warning ? `${headers.warning}, ` : '') +\n                '113 - \"rfc7234 5.5.4\"';\n        }\n        headers.age = `${Math.round(age)}`;\n        headers.date = new Date(this.now()).toUTCString();\n        return headers;\n    }\n\n    /**\n     * Returns the Date header value from the response or the current time if invalid.\n     * @returns {number} Timestamp (in milliseconds) representing the Date header or response time.\n     */\n    date() {\n        const serverDate = Date.parse(this._resHeaders.date);\n        if (isFinite(serverDate)) {\n            return serverDate;\n        }\n        return this._responseTime;\n    }\n\n    /**\n     * Value of the Age header, in seconds, updated for the current time.\n     * May be fractional.\n     * @returns {number} The age in seconds.\n     */\n    age() {\n        let age = this._ageValue();\n\n        const residentTime = (this.now() - this._responseTime) / 1000;\n        return age + residentTime;\n    }\n\n    /**\n     * @returns {number} The Age header value as a number.\n     */\n    _ageValue() {\n        return toNumberOrZero(this._resHeaders.age);\n    }\n\n    /**\n     * Possibly outdated value of applicable max-age (or heuristic equivalent) in seconds.\n     * This counts since response's `Date`.\n     *\n     * For an up-to-date value, see `timeToLive()`.\n     *\n     * Returns the maximum age (freshness lifetime) of the response in seconds.\n     * @returns {number} The max-age value in seconds.\n     */\n    maxAge() {\n        if (!this.storable() || this._rescc['no-cache']) {\n            return 0;\n        }\n\n        // Shared responses with cookies are cacheable according to the RFC, but IMHO it'd be unwise to do so by default\n        // so this implementation requires explicit opt-in via public header\n        if (\n            this._isShared &&\n            (this._resHeaders['set-cookie'] &&\n                !this._rescc.public &&\n                !this._rescc.immutable)\n        ) {\n            return 0;\n        }\n\n        if (this._resHeaders.vary === '*') {\n            return 0;\n        }\n\n        if (this._isShared) {\n            if (this._rescc['proxy-revalidate']) {\n                return 0;\n            }\n            // if a response includes the s-maxage directive, a shared cache recipient MUST ignore the Expires field.\n            if (this._rescc['s-maxage']) {\n                return toNumberOrZero(this._rescc['s-maxage']);\n            }\n        }\n\n        // If a response includes a Cache-Control field with the max-age directive, a recipient MUST ignore the Expires field.\n        if (this._rescc['max-age']) {\n            return toNumberOrZero(this._rescc['max-age']);\n        }\n\n        const defaultMinTtl = this._rescc.immutable ? this._immutableMinTtl : 0;\n\n        const serverDate = this.date();\n        if (this._resHeaders.expires) {\n            const expires = Date.parse(this._resHeaders.expires);\n            // A cache recipient MUST interpret invalid date formats, especially the value \"0\", as representing a time in the past (i.e., \"already expired\").\n            if (Number.isNaN(expires) || expires < serverDate) {\n                return 0;\n            }\n            return Math.max(defaultMinTtl, (expires - serverDate) / 1000);\n        }\n\n        if (this._resHeaders['last-modified']) {\n            const lastModified = Date.parse(this._resHeaders['last-modified']);\n            if (isFinite(lastModified) && serverDate > lastModified) {\n                return Math.max(\n                    defaultMinTtl,\n                    ((serverDate - lastModified) / 1000) * this._cacheHeuristic\n                );\n            }\n        }\n\n        return defaultMinTtl;\n    }\n\n    /**\n     * Remaining time this cache entry may be useful for, in *milliseconds*.\n     * You can use this as an expiration time for your cache storage.\n     *\n     * Prefer this method over `maxAge()`, because it includes other factors like `age` and `stale-while-revalidate`.\n     * @returns {number} Time-to-live in milliseconds.\n     */\n    timeToLive() {\n        const age = this.maxAge() - this.age();\n        const staleIfErrorAge = age + toNumberOrZero(this._rescc['stale-if-error']);\n        const staleWhileRevalidateAge = age + toNumberOrZero(this._rescc['stale-while-revalidate']);\n        return Math.round(Math.max(0, age, staleIfErrorAge, staleWhileRevalidateAge) * 1000);\n    }\n\n    /**\n     * If true, this cache entry is past its expiration date.\n     * Note that stale cache may be useful sometimes, see `evaluateRequest()`.\n     * @returns {boolean} `false` doesn't mean it's fresh nor usable\n     */\n    stale() {\n        return this.maxAge() <= this.age();\n    }\n\n    /**\n     * @returns {boolean} `true` if `stale-if-error` condition allows use of a stale response.\n     */\n    _useStaleIfError() {\n        return this.maxAge() + toNumberOrZero(this._rescc['stale-if-error']) > this.age();\n    }\n\n    /** See `evaluateRequest()` for a more complete solution\n     * @returns {boolean} `true` if `stale-while-revalidate` is currently allowed.\n     */\n    useStaleWhileRevalidate() {\n        const swr = toNumberOrZero(this._rescc['stale-while-revalidate']);\n        return swr > 0 && this.maxAge() + swr > this.age();\n    }\n\n    /**\n     * Creates a `CachePolicy` instance from a serialized object.\n     * @param {Object} obj - The serialized object.\n     * @returns {CachePolicy} A new CachePolicy instance.\n     */\n    static fromObject(obj) {\n        return new this(undefined, undefined, { _fromObject: obj });\n    }\n\n    /**\n     * @param {any} obj - The serialized object.\n     * @throws {Error} If already initialized or if the object is invalid.\n     */\n    _fromObject(obj) {\n        if (this._responseTime) throw Error('Reinitialized');\n        if (!obj || obj.v !== 1) throw Error('Invalid serialization');\n\n        this._responseTime = obj.t;\n        this._isShared = obj.sh;\n        this._cacheHeuristic = obj.ch;\n        this._immutableMinTtl =\n            obj.imm !== undefined ? obj.imm : 24 * 3600 * 1000;\n        this._ignoreCargoCult = !!obj.icc;\n        this._status = obj.st;\n        this._resHeaders = obj.resh;\n        this._rescc = obj.rescc;\n        this._method = obj.m;\n        this._url = obj.u;\n        this._host = obj.h;\n        this._noAuthorization = obj.a;\n        this._reqHeaders = obj.reqh;\n        this._reqcc = obj.reqcc;\n    }\n\n    /**\n     * Serializes the `CachePolicy` instance into a JSON-serializable object.\n     * @returns {Object} The serialized object.\n     */\n    toObject() {\n        return {\n            v: 1,\n            t: this._responseTime,\n            sh: this._isShared,\n            ch: this._cacheHeuristic,\n            imm: this._immutableMinTtl,\n            icc: this._ignoreCargoCult,\n            st: this._status,\n            resh: this._resHeaders,\n            rescc: this._rescc,\n            m: this._method,\n            u: this._url,\n            h: this._host,\n            a: this._noAuthorization,\n            reqh: this._reqHeaders,\n            reqcc: this._reqcc,\n        };\n    }\n\n    /**\n     * Headers for sending to the origin server to revalidate stale response.\n     * Allows server to return 304 to allow reuse of the previous response.\n     *\n     * Hop by hop headers are always stripped.\n     * Revalidation headers may be added or removed, depending on request.\n     * @param {HttpRequest} incomingReq - The incoming HTTP request.\n     * @returns {Record<string, string>} The headers for the revalidation request.\n     */\n    revalidationHeaders(incomingReq) {\n        this._assertRequestHasHeaders(incomingReq);\n        const headers = this._copyWithoutHopByHopHeaders(incomingReq.headers);\n\n        // This implementation does not understand range requests\n        delete headers['if-range'];\n\n        if (!this._requestMatches(incomingReq, true) || !this.storable()) {\n            // revalidation allowed via HEAD\n            // not for the same resource, or wasn't allowed to be cached anyway\n            delete headers['if-none-match'];\n            delete headers['if-modified-since'];\n            return headers;\n        }\n\n        /* MUST send that entity-tag in any cache validation request (using If-Match or If-None-Match) if an entity-tag has been provided by the origin server. */\n        if (this._resHeaders.etag) {\n            headers['if-none-match'] = headers['if-none-match']\n                ? `${headers['if-none-match']}, ${this._resHeaders.etag}`\n                : this._resHeaders.etag;\n        }\n\n        // Clients MAY issue simple (non-subrange) GET requests with either weak validators or strong validators. Clients MUST NOT use weak validators in other forms of request.\n        const forbidsWeakValidators =\n            headers['accept-ranges'] ||\n            headers['if-match'] ||\n            headers['if-unmodified-since'] ||\n            (this._method && this._method != 'GET');\n\n        /* SHOULD send the Last-Modified value in non-subrange cache validation requests (using If-Modified-Since) if only a Last-Modified value has been provided by the origin server.\n        Note: This implementation does not understand partial responses (206) */\n        if (forbidsWeakValidators) {\n            delete headers['if-modified-since'];\n\n            if (headers['if-none-match']) {\n                const etags = headers['if-none-match']\n                    .split(/,/)\n                    .filter(etag => {\n                        return !/^\\s*W\\//.test(etag);\n                    });\n                if (!etags.length) {\n                    delete headers['if-none-match'];\n                } else {\n                    headers['if-none-match'] = etags.join(',').trim();\n                }\n            }\n        } else if (\n            this._resHeaders['last-modified'] &&\n            !headers['if-modified-since']\n        ) {\n            headers['if-modified-since'] = this._resHeaders['last-modified'];\n        }\n\n        return headers;\n    }\n\n    /**\n     * Creates new CachePolicy with information combined from the previews response,\n     * and the new revalidation response.\n     *\n     * Returns {policy, modified} where modified is a boolean indicating\n     * whether the response body has been modified, and old cached body can't be used.\n     *\n     * @param {HttpRequest} request - The latest HTTP request asking for the cached entry.\n     * @param {HttpResponse} response - The latest revalidation HTTP response from the origin server.\n     * @returns {{policy: CachePolicy, modified: boolean, matches: boolean}} The updated policy and modification status.\n     * @throws {Error} If the response headers are missing.\n     */\n    revalidatedPolicy(request, response) {\n        this._assertRequestHasHeaders(request);\n\n        if (this._useStaleIfError() && isErrorResponse(response)) {\n          return {\n              policy: this,\n              modified: false,\n              matches: true,\n          };\n        }\n\n        if (!response || !response.headers) {\n            throw Error('Response headers missing');\n        }\n\n        // These aren't going to be supported exactly, since one CachePolicy object\n        // doesn't know about all the other cached objects.\n        let matches = false;\n        if (response.status !== undefined && response.status != 304) {\n            matches = false;\n        } else if (\n            response.headers.etag &&\n            !/^\\s*W\\//.test(response.headers.etag)\n        ) {\n            // \"All of the stored responses with the same strong validator are selected.\n            // If none of the stored responses contain the same strong validator,\n            // then the cache MUST NOT use the new response to update any stored responses.\"\n            matches =\n                this._resHeaders.etag &&\n                this._resHeaders.etag.replace(/^\\s*W\\//, '') ===\n                    response.headers.etag;\n        } else if (this._resHeaders.etag && response.headers.etag) {\n            // \"If the new response contains a weak validator and that validator corresponds\n            // to one of the cache's stored responses,\n            // then the most recent of those matching stored responses is selected for update.\"\n            matches =\n                this._resHeaders.etag.replace(/^\\s*W\\//, '') ===\n                response.headers.etag.replace(/^\\s*W\\//, '');\n        } else if (this._resHeaders['last-modified']) {\n            matches =\n                this._resHeaders['last-modified'] ===\n                response.headers['last-modified'];\n        } else {\n            // If the new response does not include any form of validator (such as in the case where\n            // a client generates an If-Modified-Since request from a source other than the Last-Modified\n            // response header field), and there is only one stored response, and that stored response also\n            // lacks a validator, then that stored response is selected for update.\n            if (\n                !this._resHeaders.etag &&\n                !this._resHeaders['last-modified'] &&\n                !response.headers.etag &&\n                !response.headers['last-modified']\n            ) {\n                matches = true;\n            }\n        }\n\n        const optionsCopy = {\n            shared: this._isShared,\n            cacheHeuristic: this._cacheHeuristic,\n            immutableMinTimeToLive: this._immutableMinTtl,\n            ignoreCargoCult: this._ignoreCargoCult,\n        };\n\n        if (!matches) {\n            return {\n                policy: new this.constructor(request, response, optionsCopy),\n                // Client receiving 304 without body, even if it's invalid/mismatched has no option\n                // but to reuse a cached body. We don't have a good way to tell clients to do\n                // error recovery in such case.\n                modified: response.status != 304,\n                matches: false,\n            };\n        }\n\n        // use other header fields provided in the 304 (Not Modified) response to replace all instances\n        // of the corresponding header fields in the stored response.\n        const headers = {};\n        for (const k in this._resHeaders) {\n            headers[k] =\n                k in response.headers && !excludedFromRevalidationUpdate[k]\n                    ? response.headers[k]\n                    : this._resHeaders[k];\n        }\n\n        const newResponse = Object.assign({}, response, {\n            status: this._status,\n            method: this._method,\n            headers,\n        });\n        return {\n            policy: new this.constructor(request, newResponse, optionsCopy),\n            modified: false,\n            matches: true,\n        };\n    }\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/http-cache-semantics/index.js?\n}")},"./node_modules/http2-wrapper/source/agent.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst tls = __webpack_require__(/*! tls */ \"tls\");\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst QuickLRU = __webpack_require__(/*! quick-lru */ \"./node_modules/quick-lru/index.js\");\n\nconst kCurrentStreamsCount = Symbol('currentStreamsCount');\nconst kRequest = Symbol('request');\nconst kOriginSet = Symbol('cachedOriginSet');\nconst kGracefullyClosing = Symbol('gracefullyClosing');\n\nconst nameKeys = [\n\t// `http2.connect()` options\n\t'maxDeflateDynamicTableSize',\n\t'maxSessionMemory',\n\t'maxHeaderListPairs',\n\t'maxOutstandingPings',\n\t'maxReservedRemoteStreams',\n\t'maxSendHeaderBlockLength',\n\t'paddingStrategy',\n\n\t// `tls.connect()` options\n\t'localAddress',\n\t'path',\n\t'rejectUnauthorized',\n\t'minDHSize',\n\n\t// `tls.createSecureContext()` options\n\t'ca',\n\t'cert',\n\t'clientCertEngine',\n\t'ciphers',\n\t'key',\n\t'pfx',\n\t'servername',\n\t'minVersion',\n\t'maxVersion',\n\t'secureProtocol',\n\t'crl',\n\t'honorCipherOrder',\n\t'ecdhCurve',\n\t'dhparam',\n\t'secureOptions',\n\t'sessionIdContext'\n];\n\nconst getSortedIndex = (array, value, compare) => {\n\tlet low = 0;\n\tlet high = array.length;\n\n\twhile (low < high) {\n\t\tconst mid = (low + high) >>> 1;\n\n\t\t/* istanbul ignore next */\n\t\tif (compare(array[mid], value)) {\n\t\t\t// This never gets called because we use descending sort. Better to have this anyway.\n\t\t\tlow = mid + 1;\n\t\t} else {\n\t\t\thigh = mid;\n\t\t}\n\t}\n\n\treturn low;\n};\n\nconst compareSessions = (a, b) => {\n\treturn a.remoteSettings.maxConcurrentStreams > b.remoteSettings.maxConcurrentStreams;\n};\n\n// See https://tools.ietf.org/html/rfc8336\nconst closeCoveredSessions = (where, session) => {\n\t// Clients SHOULD NOT emit new requests on any connection whose Origin\n\t// Set is a proper subset of another connection's Origin Set, and they\n\t// SHOULD close it once all outstanding requests are satisfied.\n\tfor (const coveredSession of where) {\n\t\tif (\n\t\t\t// The set is a proper subset when its length is less than the other set.\n\t\t\tcoveredSession[kOriginSet].length < session[kOriginSet].length &&\n\n\t\t\t// And the other set includes all elements of the subset.\n\t\t\tcoveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&\n\n\t\t\t// Makes sure that the session can handle all requests from the covered session.\n\t\t\tcoveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams\n\t\t) {\n\t\t\t// This allows pending requests to finish and prevents making new requests.\n\t\t\tgracefullyClose(coveredSession);\n\t\t}\n\t}\n};\n\n// This is basically inverted `closeCoveredSessions(...)`.\nconst closeSessionIfCovered = (where, coveredSession) => {\n\tfor (const session of where) {\n\t\tif (\n\t\t\tcoveredSession[kOriginSet].length < session[kOriginSet].length &&\n\t\t\tcoveredSession[kOriginSet].every(origin => session[kOriginSet].includes(origin)) &&\n\t\t\tcoveredSession[kCurrentStreamsCount] + session[kCurrentStreamsCount] <= session.remoteSettings.maxConcurrentStreams\n\t\t) {\n\t\t\tgracefullyClose(coveredSession);\n\t\t}\n\t}\n};\n\nconst getSessions = ({agent, isFree}) => {\n\tconst result = {};\n\n\t// eslint-disable-next-line guard-for-in\n\tfor (const normalizedOptions in agent.sessions) {\n\t\tconst sessions = agent.sessions[normalizedOptions];\n\n\t\tconst filtered = sessions.filter(session => {\n\t\t\tconst result = session[Agent.kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n\n\t\t\treturn isFree ? result : !result;\n\t\t});\n\n\t\tif (filtered.length !== 0) {\n\t\t\tresult[normalizedOptions] = filtered;\n\t\t}\n\t}\n\n\treturn result;\n};\n\nconst gracefullyClose = session => {\n\tsession[kGracefullyClosing] = true;\n\n\tif (session[kCurrentStreamsCount] === 0) {\n\t\tsession.close();\n\t}\n};\n\nclass Agent extends EventEmitter {\n\tconstructor({timeout = 60000, maxSessions = Infinity, maxFreeSessions = 10, maxCachedTlsSessions = 100} = {}) {\n\t\tsuper();\n\n\t\t// A session is considered busy when its current streams count\n\t\t// is equal to or greater than the `maxConcurrentStreams` value.\n\n\t\t// A session is considered free when its current streams count\n\t\t// is less than the `maxConcurrentStreams` value.\n\n\t\t// SESSIONS[NORMALIZED_OPTIONS] = [];\n\t\tthis.sessions = {};\n\n\t\t// The queue for creating new sessions. It looks like this:\n\t\t// QUEUE[NORMALIZED_OPTIONS][NORMALIZED_ORIGIN] = ENTRY_FUNCTION\n\t\t//\n\t\t// The entry function has `listeners`, `completed` and `destroyed` properties.\n\t\t// `listeners` is an array of objects containing `resolve` and `reject` functions.\n\t\t// `completed` is a boolean. It's set to true after ENTRY_FUNCTION is executed.\n\t\t// `destroyed` is a boolean. If it's set to true, the session will be destroyed if hasn't connected yet.\n\t\tthis.queue = {};\n\n\t\t// Each session will use this timeout value.\n\t\tthis.timeout = timeout;\n\n\t\t// Max sessions in total\n\t\tthis.maxSessions = maxSessions;\n\n\t\t// Max free sessions in total\n\t\t// TODO: decreasing `maxFreeSessions` should close some sessions\n\t\tthis.maxFreeSessions = maxFreeSessions;\n\n\t\tthis._freeSessionsCount = 0;\n\t\tthis._sessionsCount = 0;\n\n\t\t// We don't support push streams by default.\n\t\tthis.settings = {\n\t\t\tenablePush: false\n\t\t};\n\n\t\t// Reusing TLS sessions increases performance.\n\t\tthis.tlsSessionCache = new QuickLRU({maxSize: maxCachedTlsSessions});\n\t}\n\n\tstatic normalizeOrigin(url, servername) {\n\t\tif (typeof url === 'string') {\n\t\t\turl = new URL(url);\n\t\t}\n\n\t\tif (servername && url.hostname !== servername) {\n\t\t\turl.hostname = servername;\n\t\t}\n\n\t\treturn url.origin;\n\t}\n\n\tnormalizeOptions(options) {\n\t\tlet normalized = '';\n\n\t\tif (options) {\n\t\t\tfor (const key of nameKeys) {\n\t\t\t\tif (options[key]) {\n\t\t\t\t\tnormalized += `:${options[key]}`;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\treturn normalized;\n\t}\n\n\t_tryToCreateNewSession(normalizedOptions, normalizedOrigin) {\n\t\tif (!(normalizedOptions in this.queue) || !(normalizedOrigin in this.queue[normalizedOptions])) {\n\t\t\treturn;\n\t\t}\n\n\t\tconst item = this.queue[normalizedOptions][normalizedOrigin];\n\n\t\t// The entry function can be run only once.\n\t\t// BUG: The session may be never created when:\n\t\t// - the first condition is false AND\n\t\t// - this function is never called with the same arguments in the future.\n\t\tif (this._sessionsCount < this.maxSessions && !item.completed) {\n\t\t\titem.completed = true;\n\n\t\t\titem();\n\t\t}\n\t}\n\n\tgetSession(origin, options, listeners) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tif (Array.isArray(listeners)) {\n\t\t\t\tlisteners = [...listeners];\n\n\t\t\t\t// Resolve the current promise ASAP, we're just moving the listeners.\n\t\t\t\t// They will be executed at a different time.\n\t\t\t\tresolve();\n\t\t\t} else {\n\t\t\t\tlisteners = [{resolve, reject}];\n\t\t\t}\n\n\t\t\tconst normalizedOptions = this.normalizeOptions(options);\n\t\t\tconst normalizedOrigin = Agent.normalizeOrigin(origin, options && options.servername);\n\n\t\t\tif (normalizedOrigin === undefined) {\n\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\treject(new TypeError('The `origin` argument needs to be a string or an URL object'));\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (normalizedOptions in this.sessions) {\n\t\t\t\tconst sessions = this.sessions[normalizedOptions];\n\n\t\t\t\tlet maxConcurrentStreams = -1;\n\t\t\t\tlet currentStreamsCount = -1;\n\t\t\t\tlet optimalSession;\n\n\t\t\t\t// We could just do this.sessions[normalizedOptions].find(...) but that isn't optimal.\n\t\t\t\t// Additionally, we are looking for session which has biggest current pending streams count.\n\t\t\t\tfor (const session of sessions) {\n\t\t\t\t\tconst sessionMaxConcurrentStreams = session.remoteSettings.maxConcurrentStreams;\n\n\t\t\t\t\tif (sessionMaxConcurrentStreams < maxConcurrentStreams) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif (session[kOriginSet].includes(normalizedOrigin)) {\n\t\t\t\t\t\tconst sessionCurrentStreamsCount = session[kCurrentStreamsCount];\n\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\tsessionCurrentStreamsCount >= sessionMaxConcurrentStreams ||\n\t\t\t\t\t\t\tsession[kGracefullyClosing] ||\n\t\t\t\t\t\t\t// Unfortunately the `close` event isn't called immediately,\n\t\t\t\t\t\t\t// so `session.destroyed` is `true`, but `session.closed` is `false`.\n\t\t\t\t\t\t\tsession.destroyed\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We only need set this once.\n\t\t\t\t\t\tif (!optimalSession) {\n\t\t\t\t\t\t\tmaxConcurrentStreams = sessionMaxConcurrentStreams;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// We're looking for the session which has biggest current pending stream count,\n\t\t\t\t\t\t// in order to minimalize the amount of active sessions.\n\t\t\t\t\t\tif (sessionCurrentStreamsCount > currentStreamsCount) {\n\t\t\t\t\t\t\toptimalSession = session;\n\t\t\t\t\t\t\tcurrentStreamsCount = sessionCurrentStreamsCount;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (optimalSession) {\n\t\t\t\t\t/* istanbul ignore next: safety check */\n\t\t\t\t\tif (listeners.length !== 1) {\n\t\t\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\t\t\tconst error = new Error(\n\t\t\t\t\t\t\t\t`Expected the length of listeners to be 1, got ${listeners.length}.\\n` +\n\t\t\t\t\t\t\t\t'Please report this to https://github.com/szmarczak/http2-wrapper/'\n\t\t\t\t\t\t\t);\n\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tlisteners[0].resolve(optimalSession);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (normalizedOptions in this.queue) {\n\t\t\t\tif (normalizedOrigin in this.queue[normalizedOptions]) {\n\t\t\t\t\t// There's already an item in the queue, just attach ourselves to it.\n\t\t\t\t\tthis.queue[normalizedOptions][normalizedOrigin].listeners.push(...listeners);\n\n\t\t\t\t\t// This shouldn't be executed here.\n\t\t\t\t\t// See the comment inside _tryToCreateNewSession.\n\t\t\t\t\tthis._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis.queue[normalizedOptions] = {};\n\t\t\t}\n\n\t\t\t// The entry must be removed from the queue IMMEDIATELY when:\n\t\t\t// 1. the session connects successfully,\n\t\t\t// 2. an error occurs.\n\t\t\tconst removeFromQueue = () => {\n\t\t\t\t// Our entry can be replaced. We cannot remove the new one.\n\t\t\t\tif (normalizedOptions in this.queue && this.queue[normalizedOptions][normalizedOrigin] === entry) {\n\t\t\t\t\tdelete this.queue[normalizedOptions][normalizedOrigin];\n\n\t\t\t\t\tif (Object.keys(this.queue[normalizedOptions]).length === 0) {\n\t\t\t\t\t\tdelete this.queue[normalizedOptions];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\n\t\t\t// The main logic is here\n\t\t\tconst entry = () => {\n\t\t\t\tconst name = `${normalizedOrigin}:${normalizedOptions}`;\n\t\t\t\tlet receivedSettings = false;\n\n\t\t\t\ttry {\n\t\t\t\t\tconst session = http2.connect(origin, {\n\t\t\t\t\t\tcreateConnection: this.createConnection,\n\t\t\t\t\t\tsettings: this.settings,\n\t\t\t\t\t\tsession: this.tlsSessionCache.get(name),\n\t\t\t\t\t\t...options\n\t\t\t\t\t});\n\t\t\t\t\tsession[kCurrentStreamsCount] = 0;\n\t\t\t\t\tsession[kGracefullyClosing] = false;\n\n\t\t\t\t\tconst isFree = () => session[kCurrentStreamsCount] < session.remoteSettings.maxConcurrentStreams;\n\t\t\t\t\tlet wasFree = true;\n\n\t\t\t\t\tsession.socket.once('session', tlsSession => {\n\t\t\t\t\t\tthis.tlsSessionCache.set(name, tlsSession);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('error', error => {\n\t\t\t\t\t\t// Listeners are empty when the session successfully connected.\n\t\t\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// The connection got broken, purge the cache.\n\t\t\t\t\t\tthis.tlsSessionCache.delete(name);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.setTimeout(this.timeout, () => {\n\t\t\t\t\t\t// Terminates all streams owned by this session.\n\t\t\t\t\t\t// TODO: Maybe the streams should have a \"Session timed out\" error?\n\t\t\t\t\t\tsession.destroy();\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('close', () => {\n\t\t\t\t\t\tif (receivedSettings) {\n\t\t\t\t\t\t\t// 1. If it wasn't free then no need to decrease because\n\t\t\t\t\t\t\t//    it has been decreased already in session.request().\n\t\t\t\t\t\t\t// 2. `stream.once('close')` won't increment the count\n\t\t\t\t\t\t\t//    because the session is already closed.\n\t\t\t\t\t\t\tif (wasFree) {\n\t\t\t\t\t\t\t\tthis._freeSessionsCount--;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tthis._sessionsCount--;\n\n\t\t\t\t\t\t\t// This cannot be moved to the stream logic,\n\t\t\t\t\t\t\t// because there may be a session that hadn't made a single request.\n\t\t\t\t\t\t\tconst where = this.sessions[normalizedOptions];\n\t\t\t\t\t\t\twhere.splice(where.indexOf(session), 1);\n\n\t\t\t\t\t\t\tif (where.length === 0) {\n\t\t\t\t\t\t\t\tdelete this.sessions[normalizedOptions];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t// Broken connection\n\t\t\t\t\t\t\tconst error = new Error('Session closed without receiving a SETTINGS frame');\n\t\t\t\t\t\t\terror.code = 'HTTP2WRAPPER_NOSETTINGS';\n\n\t\t\t\t\t\t\tfor (const {reject} of listeners) {\n\t\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tremoveFromQueue();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// There may be another session awaiting.\n\t\t\t\t\t\tthis._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\t\t\t\t\t});\n\n\t\t\t\t\t// Iterates over the queue and processes listeners.\n\t\t\t\t\tconst processListeners = () => {\n\t\t\t\t\t\tif (!(normalizedOptions in this.queue) || !isFree()) {\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tfor (const origin of session[kOriginSet]) {\n\t\t\t\t\t\t\tif (origin in this.queue[normalizedOptions]) {\n\t\t\t\t\t\t\t\tconst {listeners} = this.queue[normalizedOptions][origin];\n\n\t\t\t\t\t\t\t\t// Prevents session overloading.\n\t\t\t\t\t\t\t\twhile (listeners.length !== 0 && isFree()) {\n\t\t\t\t\t\t\t\t\t// We assume `resolve(...)` calls `request(...)` *directly*,\n\t\t\t\t\t\t\t\t\t// otherwise the session will get overloaded.\n\t\t\t\t\t\t\t\t\tlisteners.shift().resolve(session);\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tconst where = this.queue[normalizedOptions];\n\t\t\t\t\t\t\t\tif (where[origin].listeners.length === 0) {\n\t\t\t\t\t\t\t\t\tdelete where[origin];\n\n\t\t\t\t\t\t\t\t\tif (Object.keys(where).length === 0) {\n\t\t\t\t\t\t\t\t\t\tdelete this.queue[normalizedOptions];\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// We're no longer free, no point in continuing.\n\t\t\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t};\n\n\t\t\t\t\t// The Origin Set cannot shrink. No need to check if it suddenly became covered by another one.\n\t\t\t\t\tsession.on('origin', () => {\n\t\t\t\t\t\tsession[kOriginSet] = session.originSet;\n\n\t\t\t\t\t\tif (!isFree()) {\n\t\t\t\t\t\t\t// The session is full.\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tprocessListeners();\n\n\t\t\t\t\t\t// Close covered sessions (if possible).\n\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t});\n\n\t\t\t\t\tsession.once('remoteSettings', () => {\n\t\t\t\t\t\t// Fix Node.js bug preventing the process from exiting\n\t\t\t\t\t\tsession.ref();\n\t\t\t\t\t\tsession.unref();\n\n\t\t\t\t\t\tthis._sessionsCount++;\n\n\t\t\t\t\t\t// The Agent could have been destroyed already.\n\t\t\t\t\t\tif (entry.destroyed) {\n\t\t\t\t\t\t\tconst error = new Error('Agent has been destroyed');\n\n\t\t\t\t\t\t\tfor (const listener of listeners) {\n\t\t\t\t\t\t\t\tlistener.reject(error);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tsession.destroy();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tsession[kOriginSet] = session.originSet;\n\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconst where = this.sessions;\n\n\t\t\t\t\t\t\tif (normalizedOptions in where) {\n\t\t\t\t\t\t\t\tconst sessions = where[normalizedOptions];\n\t\t\t\t\t\t\t\tsessions.splice(getSortedIndex(sessions, session, compareSessions), 0, session);\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\twhere[normalizedOptions] = [session];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthis._freeSessionsCount += 1;\n\t\t\t\t\t\treceivedSettings = true;\n\n\t\t\t\t\t\tthis.emit('session', session);\n\n\t\t\t\t\t\tprocessListeners();\n\t\t\t\t\t\tremoveFromQueue();\n\n\t\t\t\t\t\t// TODO: Close last recently used (or least used?) session\n\t\t\t\t\t\tif (session[kCurrentStreamsCount] === 0 && this._freeSessionsCount > this.maxFreeSessions) {\n\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Check if we haven't managed to execute all listeners.\n\t\t\t\t\t\tif (listeners.length !== 0) {\n\t\t\t\t\t\t\t// Request for a new session with predefined listeners.\n\t\t\t\t\t\t\tthis.getSession(normalizedOrigin, options, listeners);\n\t\t\t\t\t\t\tlisteners.length = 0;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// `session.remoteSettings.maxConcurrentStreams` might get increased\n\t\t\t\t\t\tsession.on('remoteSettings', () => {\n\t\t\t\t\t\t\tprocessListeners();\n\n\t\t\t\t\t\t\t// In case the Origin Set changes\n\t\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t\t});\n\t\t\t\t\t});\n\n\t\t\t\t\t// Shim `session.request()` in order to catch all streams\n\t\t\t\t\tsession[kRequest] = session.request;\n\t\t\t\t\tsession.request = (headers, streamOptions) => {\n\t\t\t\t\t\tif (session[kGracefullyClosing]) {\n\t\t\t\t\t\t\tthrow new Error('The session is gracefully closing. No new streams are allowed.');\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tconst stream = session[kRequest](headers, streamOptions);\n\n\t\t\t\t\t\t// The process won't exit until the session is closed or all requests are gone.\n\t\t\t\t\t\tsession.ref();\n\n\t\t\t\t\t\t++session[kCurrentStreamsCount];\n\n\t\t\t\t\t\tif (session[kCurrentStreamsCount] === session.remoteSettings.maxConcurrentStreams) {\n\t\t\t\t\t\t\tthis._freeSessionsCount--;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tstream.once('close', () => {\n\t\t\t\t\t\t\twasFree = isFree();\n\n\t\t\t\t\t\t\t--session[kCurrentStreamsCount];\n\n\t\t\t\t\t\t\tif (!session.destroyed && !session.closed) {\n\t\t\t\t\t\t\t\tcloseSessionIfCovered(this.sessions[normalizedOptions], session);\n\n\t\t\t\t\t\t\t\tif (isFree() && !session.closed) {\n\t\t\t\t\t\t\t\t\tif (!wasFree) {\n\t\t\t\t\t\t\t\t\t\tthis._freeSessionsCount++;\n\n\t\t\t\t\t\t\t\t\t\twasFree = true;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tconst isEmpty = session[kCurrentStreamsCount] === 0;\n\n\t\t\t\t\t\t\t\t\tif (isEmpty) {\n\t\t\t\t\t\t\t\t\t\tsession.unref();\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tif (\n\t\t\t\t\t\t\t\t\t\tisEmpty &&\n\t\t\t\t\t\t\t\t\t\t(\n\t\t\t\t\t\t\t\t\t\t\tthis._freeSessionsCount > this.maxFreeSessions ||\n\t\t\t\t\t\t\t\t\t\t\tsession[kGracefullyClosing]\n\t\t\t\t\t\t\t\t\t\t)\n\t\t\t\t\t\t\t\t\t) {\n\t\t\t\t\t\t\t\t\t\tsession.close();\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\tcloseCoveredSessions(this.sessions[normalizedOptions], session);\n\t\t\t\t\t\t\t\t\t\tprocessListeners();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\treturn stream;\n\t\t\t\t\t};\n\t\t\t\t} catch (error) {\n\t\t\t\t\tfor (const listener of listeners) {\n\t\t\t\t\t\tlistener.reject(error);\n\t\t\t\t\t}\n\n\t\t\t\t\tremoveFromQueue();\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tentry.listeners = listeners;\n\t\t\tentry.completed = false;\n\t\t\tentry.destroyed = false;\n\n\t\t\tthis.queue[normalizedOptions][normalizedOrigin] = entry;\n\t\t\tthis._tryToCreateNewSession(normalizedOptions, normalizedOrigin);\n\t\t});\n\t}\n\n\trequest(origin, options, headers, streamOptions) {\n\t\treturn new Promise((resolve, reject) => {\n\t\t\tthis.getSession(origin, options, [{\n\t\t\t\treject,\n\t\t\t\tresolve: session => {\n\t\t\t\t\ttry {\n\t\t\t\t\t\tresolve(session.request(headers, streamOptions));\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}]);\n\t\t});\n\t}\n\n\tcreateConnection(origin, options) {\n\t\treturn Agent.connect(origin, options);\n\t}\n\n\tstatic connect(origin, options) {\n\t\toptions.ALPNProtocols = ['h2'];\n\n\t\tconst port = origin.port || 443;\n\t\tconst host = origin.hostname || origin.host;\n\n\t\tif (typeof options.servername === 'undefined') {\n\t\t\toptions.servername = host;\n\t\t}\n\n\t\treturn tls.connect(port, host, options);\n\t}\n\n\tcloseFreeSessions() {\n\t\tfor (const sessions of Object.values(this.sessions)) {\n\t\t\tfor (const session of sessions) {\n\t\t\t\tif (session[kCurrentStreamsCount] === 0) {\n\t\t\t\t\tsession.close();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tdestroy(reason) {\n\t\tfor (const sessions of Object.values(this.sessions)) {\n\t\t\tfor (const session of sessions) {\n\t\t\t\tsession.destroy(reason);\n\t\t\t}\n\t\t}\n\n\t\tfor (const entriesOfAuthority of Object.values(this.queue)) {\n\t\t\tfor (const entry of Object.values(entriesOfAuthority)) {\n\t\t\t\tentry.destroyed = true;\n\t\t\t}\n\t\t}\n\n\t\t// New requests should NOT attach to destroyed sessions\n\t\tthis.queue = {};\n\t}\n\n\tget freeSessions() {\n\t\treturn getSessions({agent: this, isFree: true});\n\t}\n\n\tget busySessions() {\n\t\treturn getSessions({agent: this, isFree: false});\n\t}\n}\n\nAgent.kCurrentStreamsCount = kCurrentStreamsCount;\nAgent.kGracefullyClosing = kGracefullyClosing;\n\nmodule.exports = {\n\tAgent,\n\tglobalAgent: new Agent()\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/http2-wrapper/source/agent.js?\n}")},"./node_modules/http2-wrapper/source/auto.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{\nconst http = __webpack_require__(/*! http */ \"http\");\nconst https = __webpack_require__(/*! https */ \"https\");\nconst resolveALPN = __webpack_require__(/*! resolve-alpn */ \"./node_modules/resolve-alpn/index.js\");\nconst QuickLRU = __webpack_require__(/*! quick-lru */ \"./node_modules/quick-lru/index.js\");\nconst Http2ClientRequest = __webpack_require__(/*! ./client-request */ \"./node_modules/http2-wrapper/source/client-request.js\");\nconst calculateServerName = __webpack_require__(/*! ./utils/calculate-server-name */ \"./node_modules/http2-wrapper/source/utils/calculate-server-name.js\");\nconst urlToOptions = __webpack_require__(/*! ./utils/url-to-options */ \"./node_modules/http2-wrapper/source/utils/url-to-options.js\");\n\nconst cache = new QuickLRU({maxSize: 100});\nconst queue = new Map();\n\nconst installSocket = (agent, socket, options) => {\n\tsocket._httpMessage = {shouldKeepAlive: true};\n\n\tconst onFree = () => {\n\t\tagent.emit('free', socket, options);\n\t};\n\n\tsocket.on('free', onFree);\n\n\tconst onClose = () => {\n\t\tagent.removeSocket(socket, options);\n\t};\n\n\tsocket.on('close', onClose);\n\n\tconst onRemove = () => {\n\t\tagent.removeSocket(socket, options);\n\t\tsocket.off('close', onClose);\n\t\tsocket.off('free', onFree);\n\t\tsocket.off('agentRemove', onRemove);\n\t};\n\n\tsocket.on('agentRemove', onRemove);\n\n\tagent.emit('free', socket, options);\n};\n\nconst resolveProtocol = async options => {\n\tconst name = `${options.host}:${options.port}:${options.ALPNProtocols.sort()}`;\n\n\tif (!cache.has(name)) {\n\t\tif (queue.has(name)) {\n\t\t\tconst result = await queue.get(name);\n\t\t\treturn result.alpnProtocol;\n\t\t}\n\n\t\tconst {path, agent} = options;\n\t\toptions.path = options.socketPath;\n\n\t\tconst resultPromise = resolveALPN(options);\n\t\tqueue.set(name, resultPromise);\n\n\t\ttry {\n\t\t\tconst {socket, alpnProtocol} = await resultPromise;\n\t\t\tcache.set(name, alpnProtocol);\n\n\t\t\toptions.path = path;\n\n\t\t\tif (alpnProtocol === 'h2') {\n\t\t\t\t// https://github.com/nodejs/node/issues/33343\n\t\t\t\tsocket.destroy();\n\t\t\t} else {\n\t\t\t\tconst {globalAgent} = https;\n\t\t\t\tconst defaultCreateConnection = https.Agent.prototype.createConnection;\n\n\t\t\t\tif (agent) {\n\t\t\t\t\tif (agent.createConnection === defaultCreateConnection) {\n\t\t\t\t\t\tinstallSocket(agent, socket, options);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tsocket.destroy();\n\t\t\t\t\t}\n\t\t\t\t} else if (globalAgent.createConnection === defaultCreateConnection) {\n\t\t\t\t\tinstallSocket(globalAgent, socket, options);\n\t\t\t\t} else {\n\t\t\t\t\tsocket.destroy();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tqueue.delete(name);\n\n\t\t\treturn alpnProtocol;\n\t\t} catch (error) {\n\t\t\tqueue.delete(name);\n\n\t\t\tthrow error;\n\t\t}\n\t}\n\n\treturn cache.get(name);\n};\n\nmodule.exports = async (input, options, callback) => {\n\tif (typeof input === 'string' || input instanceof URL) {\n\t\tinput = urlToOptions(new URL(input));\n\t}\n\n\tif (typeof options === 'function') {\n\t\tcallback = options;\n\t\toptions = undefined;\n\t}\n\n\toptions = {\n\t\tALPNProtocols: ['h2', 'http/1.1'],\n\t\t...input,\n\t\t...options,\n\t\tresolveSocket: true\n\t};\n\n\tif (!Array.isArray(options.ALPNProtocols) || options.ALPNProtocols.length === 0) {\n\t\tthrow new Error('The `ALPNProtocols` option must be an Array with at least one entry');\n\t}\n\n\toptions.protocol = options.protocol || 'https:';\n\tconst isHttps = options.protocol === 'https:';\n\n\toptions.host = options.hostname || options.host || 'localhost';\n\toptions.session = options.tlsSession;\n\toptions.servername = options.servername || calculateServerName(options);\n\toptions.port = options.port || (isHttps ? 443 : 80);\n\toptions._defaultAgent = isHttps ? https.globalAgent : http.globalAgent;\n\n\tconst agents = options.agent;\n\n\tif (agents) {\n\t\tif (agents.addRequest) {\n\t\t\tthrow new Error('The `options.agent` object can contain only `http`, `https` or `http2` properties');\n\t\t}\n\n\t\toptions.agent = agents[isHttps ? 'https' : 'http'];\n\t}\n\n\tif (isHttps) {\n\t\tconst protocol = await resolveProtocol(options);\n\n\t\tif (protocol === 'h2') {\n\t\t\tif (agents) {\n\t\t\t\toptions.agent = agents.http2;\n\t\t\t}\n\n\t\t\treturn new Http2ClientRequest(options, callback);\n\t\t}\n\t}\n\n\treturn http.request(options, callback);\n};\n\nmodule.exports.protocolCache = cache;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/http2-wrapper/source/auto.js?\n}")},"./node_modules/http2-wrapper/source/client-request.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{\nconst http2 = __webpack_require__(/*! http2 */ \"http2\");\nconst {Writable} = __webpack_require__(/*! stream */ \"stream\");\nconst {Agent, globalAgent} = __webpack_require__(/*! ./agent */ \"./node_modules/http2-wrapper/source/agent.js\");\nconst IncomingMessage = __webpack_require__(/*! ./incoming-message */ \"./node_modules/http2-wrapper/source/incoming-message.js\");\nconst urlToOptions = __webpack_require__(/*! ./utils/url-to-options */ \"./node_modules/http2-wrapper/source/utils/url-to-options.js\");\nconst proxyEvents = __webpack_require__(/*! ./utils/proxy-events */ \"./node_modules/http2-wrapper/source/utils/proxy-events.js\");\nconst isRequestPseudoHeader = __webpack_require__(/*! ./utils/is-request-pseudo-header */ \"./node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js\");\nconst {\n\tERR_INVALID_ARG_TYPE,\n\tERR_INVALID_PROTOCOL,\n\tERR_HTTP_HEADERS_SENT,\n\tERR_INVALID_HTTP_TOKEN,\n\tERR_HTTP_INVALID_HEADER_VALUE,\n\tERR_INVALID_CHAR\n} = __webpack_require__(/*! ./utils/errors */ \"./node_modules/http2-wrapper/source/utils/errors.js\");\n\nconst {\n\tHTTP2_HEADER_STATUS,\n\tHTTP2_HEADER_METHOD,\n\tHTTP2_HEADER_PATH,\n\tHTTP2_METHOD_CONNECT\n} = http2.constants;\n\nconst kHeaders = Symbol('headers');\nconst kOrigin = Symbol('origin');\nconst kSession = Symbol('session');\nconst kOptions = Symbol('options');\nconst kFlushedHeaders = Symbol('flushedHeaders');\nconst kJobs = Symbol('jobs');\n\nconst isValidHttpToken = /^[\\^`\\-\\w!#$%&*+.|~]+$/;\nconst isInvalidHeaderValue = /[^\\t\\u0020-\\u007E\\u0080-\\u00FF]/;\n\nclass ClientRequest extends Writable {\n\tconstructor(input, options, callback) {\n\t\tsuper({\n\t\t\tautoDestroy: false\n\t\t});\n\n\t\tconst hasInput = typeof input === 'string' || input instanceof URL;\n\t\tif (hasInput) {\n\t\t\tinput = urlToOptions(input instanceof URL ? input : new URL(input));\n\t\t}\n\n\t\tif (typeof options === 'function' || options === undefined) {\n\t\t\t// (options, callback)\n\t\t\tcallback = options;\n\t\t\toptions = hasInput ? input : {...input};\n\t\t} else {\n\t\t\t// (input, options, callback)\n\t\t\toptions = {...input, ...options};\n\t\t}\n\n\t\tif (options.h2session) {\n\t\t\tthis[kSession] = options.h2session;\n\t\t} else if (options.agent === false) {\n\t\t\tthis.agent = new Agent({maxFreeSessions: 0});\n\t\t} else if (typeof options.agent === 'undefined' || options.agent === null) {\n\t\t\tif (typeof options.createConnection === 'function') {\n\t\t\t\t// This is a workaround - we don't have to create the session on our own.\n\t\t\t\tthis.agent = new Agent({maxFreeSessions: 0});\n\t\t\t\tthis.agent.createConnection = options.createConnection;\n\t\t\t} else {\n\t\t\t\tthis.agent = globalAgent;\n\t\t\t}\n\t\t} else if (typeof options.agent.request === 'function') {\n\t\t\tthis.agent = options.agent;\n\t\t} else {\n\t\t\tthrow new ERR_INVALID_ARG_TYPE('options.agent', ['Agent-like Object', 'undefined', 'false'], options.agent);\n\t\t}\n\n\t\tif (options.protocol && options.protocol !== 'https:') {\n\t\t\tthrow new ERR_INVALID_PROTOCOL(options.protocol, 'https:');\n\t\t}\n\n\t\tconst port = options.port || options.defaultPort || (this.agent && this.agent.defaultPort) || 443;\n\t\tconst host = options.hostname || options.host || 'localhost';\n\n\t\t// Don't enforce the origin via options. It may be changed in an Agent.\n\t\tdelete options.hostname;\n\t\tdelete options.host;\n\t\tdelete options.port;\n\n\t\tconst {timeout} = options;\n\t\toptions.timeout = undefined;\n\n\t\tthis[kHeaders] = Object.create(null);\n\t\tthis[kJobs] = [];\n\n\t\tthis.socket = null;\n\t\tthis.connection = null;\n\n\t\tthis.method = options.method || 'GET';\n\t\tthis.path = options.path;\n\n\t\tthis.res = null;\n\t\tthis.aborted = false;\n\t\tthis.reusedSocket = false;\n\n\t\tif (options.headers) {\n\t\t\tfor (const [header, value] of Object.entries(options.headers)) {\n\t\t\t\tthis.setHeader(header, value);\n\t\t\t}\n\t\t}\n\n\t\tif (options.auth && !('authorization' in this[kHeaders])) {\n\t\t\tthis[kHeaders].authorization = 'Basic ' + Buffer.from(options.auth).toString('base64');\n\t\t}\n\n\t\toptions.session = options.tlsSession;\n\t\toptions.path = options.socketPath;\n\n\t\tthis[kOptions] = options;\n\n\t\t// Clients that generate HTTP/2 requests directly SHOULD use the :authority pseudo-header field instead of the Host header field.\n\t\tif (port === 443) {\n\t\t\tthis[kOrigin] = `https://${host}`;\n\n\t\t\tif (!(':authority' in this[kHeaders])) {\n\t\t\t\tthis[kHeaders][':authority'] = host;\n\t\t\t}\n\t\t} else {\n\t\t\tthis[kOrigin] = `https://${host}:${port}`;\n\n\t\t\tif (!(':authority' in this[kHeaders])) {\n\t\t\t\tthis[kHeaders][':authority'] = `${host}:${port}`;\n\t\t\t}\n\t\t}\n\n\t\tif (timeout) {\n\t\t\tthis.setTimeout(timeout);\n\t\t}\n\n\t\tif (callback) {\n\t\t\tthis.once('response', callback);\n\t\t}\n\n\t\tthis[kFlushedHeaders] = false;\n\t}\n\n\tget method() {\n\t\treturn this[kHeaders][HTTP2_HEADER_METHOD];\n\t}\n\n\tset method(value) {\n\t\tif (value) {\n\t\t\tthis[kHeaders][HTTP2_HEADER_METHOD] = value.toUpperCase();\n\t\t}\n\t}\n\n\tget path() {\n\t\treturn this[kHeaders][HTTP2_HEADER_PATH];\n\t}\n\n\tset path(value) {\n\t\tif (value) {\n\t\t\tthis[kHeaders][HTTP2_HEADER_PATH] = value;\n\t\t}\n\t}\n\n\tget _mustNotHaveABody() {\n\t\treturn this.method === 'GET' || this.method === 'HEAD' || this.method === 'DELETE';\n\t}\n\n\t_write(chunk, encoding, callback) {\n\t\t// https://github.com/nodejs/node/blob/654df09ae0c5e17d1b52a900a545f0664d8c7627/lib/internal/http2/util.js#L148-L156\n\t\tif (this._mustNotHaveABody) {\n\t\t\tcallback(new Error('The GET, HEAD and DELETE methods must NOT have a body'));\n\t\t\t/* istanbul ignore next: Node.js 12 throws directly */\n\t\t\treturn;\n\t\t}\n\n\t\tthis.flushHeaders();\n\n\t\tconst callWrite = () => this._request.write(chunk, encoding, callback);\n\t\tif (this._request) {\n\t\t\tcallWrite();\n\t\t} else {\n\t\t\tthis[kJobs].push(callWrite);\n\t\t}\n\t}\n\n\t_final(callback) {\n\t\tif (this.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.flushHeaders();\n\n\t\tconst callEnd = () => {\n\t\t\t// For GET, HEAD and DELETE\n\t\t\tif (this._mustNotHaveABody) {\n\t\t\t\tcallback();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tthis._request.end(callback);\n\t\t};\n\n\t\tif (this._request) {\n\t\t\tcallEnd();\n\t\t} else {\n\t\t\tthis[kJobs].push(callEnd);\n\t\t}\n\t}\n\n\tabort() {\n\t\tif (this.res && this.res.complete) {\n\t\t\treturn;\n\t\t}\n\n\t\tif (!this.aborted) {\n\t\t\tprocess.nextTick(() => this.emit('abort'));\n\t\t}\n\n\t\tthis.aborted = true;\n\n\t\tthis.destroy();\n\t}\n\n\t_destroy(error, callback) {\n\t\tif (this.res) {\n\t\t\tthis.res._dump();\n\t\t}\n\n\t\tif (this._request) {\n\t\t\tthis._request.destroy();\n\t\t}\n\n\t\tcallback(error);\n\t}\n\n\tasync flushHeaders() {\n\t\tif (this[kFlushedHeaders] || this.destroyed) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis[kFlushedHeaders] = true;\n\n\t\tconst isConnectMethod = this.method === HTTP2_METHOD_CONNECT;\n\n\t\t// The real magic is here\n\t\tconst onStream = stream => {\n\t\t\tthis._request = stream;\n\n\t\t\tif (this.destroyed) {\n\t\t\t\tstream.destroy();\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\t// Forwards `timeout`, `continue`, `close` and `error` events to this instance.\n\t\t\tif (!isConnectMethod) {\n\t\t\t\tproxyEvents(stream, this, ['timeout', 'continue', 'close', 'error']);\n\t\t\t}\n\n\t\t\t// Wait for the `finish` event. We don't want to emit the `response` event\n\t\t\t// before `request.end()` is called.\n\t\t\tconst waitForEnd = fn => {\n\t\t\t\treturn (...args) => {\n\t\t\t\t\tif (!this.writable && !this.destroyed) {\n\t\t\t\t\t\tfn(...args);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tthis.once('finish', () => {\n\t\t\t\t\t\t\tfn(...args);\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t};\n\n\t\t\t// This event tells we are ready to listen for the data.\n\t\t\tstream.once('response', waitForEnd((headers, flags, rawHeaders) => {\n\t\t\t\t// If we were to emit raw request stream, it would be as fast as the native approach.\n\t\t\t\t// Note that wrapping the raw stream in a Proxy instance won't improve the performance (already tested it).\n\t\t\t\tconst response = new IncomingMessage(this.socket, stream.readableHighWaterMark);\n\t\t\t\tthis.res = response;\n\n\t\t\t\tresponse.req = this;\n\t\t\t\tresponse.statusCode = headers[HTTP2_HEADER_STATUS];\n\t\t\t\tresponse.headers = headers;\n\t\t\t\tresponse.rawHeaders = rawHeaders;\n\n\t\t\t\tresponse.once('end', () => {\n\t\t\t\t\tif (this.aborted) {\n\t\t\t\t\t\tresponse.aborted = true;\n\t\t\t\t\t\tresponse.emit('aborted');\n\t\t\t\t\t} else {\n\t\t\t\t\t\tresponse.complete = true;\n\n\t\t\t\t\t\t// Has no effect, just be consistent with the Node.js behavior\n\t\t\t\t\t\tresponse.socket = null;\n\t\t\t\t\t\tresponse.connection = null;\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\t\tif (isConnectMethod) {\n\t\t\t\t\tresponse.upgrade = true;\n\n\t\t\t\t\t// The HTTP1 API says the socket is detached here,\n\t\t\t\t\t// but we can't do that so we pass the original HTTP2 request.\n\t\t\t\t\tif (this.emit('connect', response, stream, Buffer.alloc(0))) {\n\t\t\t\t\t\tthis.emit('close');\n\t\t\t\t\t} else {\n\t\t\t\t\t\t// No listeners attached, destroy the original request.\n\t\t\t\t\t\tstream.destroy();\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\t// Forwards data\n\t\t\t\t\tstream.on('data', chunk => {\n\t\t\t\t\t\tif (!response._dumped && !response.push(chunk)) {\n\t\t\t\t\t\t\tstream.pause();\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\n\t\t\t\t\tstream.once('end', () => {\n\t\t\t\t\t\tresponse.push(null);\n\t\t\t\t\t});\n\n\t\t\t\t\tif (!this.emit('response', response)) {\n\t\t\t\t\t\t// No listeners attached, dump the response.\n\t\t\t\t\t\tresponse._dump();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}));\n\n\t\t\t// Emits `information` event\n\t\t\tstream.once('headers', waitForEnd(\n\t\t\t\theaders => this.emit('information', {statusCode: headers[HTTP2_HEADER_STATUS]})\n\t\t\t));\n\n\t\t\tstream.once('trailers', waitForEnd((trailers, flags, rawTrailers) => {\n\t\t\t\tconst {res} = this;\n\n\t\t\t\t// Assigns trailers to the response object.\n\t\t\t\tres.trailers = trailers;\n\t\t\t\tres.rawTrailers = rawTrailers;\n\t\t\t}));\n\n\t\t\tconst {socket} = stream.session;\n\t\t\tthis.socket = socket;\n\t\t\tthis.connection = socket;\n\n\t\t\tfor (const job of this[kJobs]) {\n\t\t\t\tjob();\n\t\t\t}\n\n\t\t\tthis.emit('socket', this.socket);\n\t\t};\n\n\t\t// Makes a HTTP2 request\n\t\tif (this[kSession]) {\n\t\t\ttry {\n\t\t\t\tonStream(this[kSession].request(this[kHeaders]));\n\t\t\t} catch (error) {\n\t\t\t\tthis.emit('error', error);\n\t\t\t}\n\t\t} else {\n\t\t\tthis.reusedSocket = true;\n\n\t\t\ttry {\n\t\t\t\tonStream(await this.agent.request(this[kOrigin], this[kOptions], this[kHeaders]));\n\t\t\t} catch (error) {\n\t\t\t\tthis.emit('error', error);\n\t\t\t}\n\t\t}\n\t}\n\n\tgetHeader(name) {\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new ERR_INVALID_ARG_TYPE('name', 'string', name);\n\t\t}\n\n\t\treturn this[kHeaders][name.toLowerCase()];\n\t}\n\n\tget headersSent() {\n\t\treturn this[kFlushedHeaders];\n\t}\n\n\tremoveHeader(name) {\n\t\tif (typeof name !== 'string') {\n\t\t\tthrow new ERR_INVALID_ARG_TYPE('name', 'string', name);\n\t\t}\n\n\t\tif (this.headersSent) {\n\t\t\tthrow new ERR_HTTP_HEADERS_SENT('remove');\n\t\t}\n\n\t\tdelete this[kHeaders][name.toLowerCase()];\n\t}\n\n\tsetHeader(name, value) {\n\t\tif (this.headersSent) {\n\t\t\tthrow new ERR_HTTP_HEADERS_SENT('set');\n\t\t}\n\n\t\tif (typeof name !== 'string' || (!isValidHttpToken.test(name) && !isRequestPseudoHeader(name))) {\n\t\t\tthrow new ERR_INVALID_HTTP_TOKEN('Header name', name);\n\t\t}\n\n\t\tif (typeof value === 'undefined') {\n\t\t\tthrow new ERR_HTTP_INVALID_HEADER_VALUE(value, name);\n\t\t}\n\n\t\tif (isInvalidHeaderValue.test(value)) {\n\t\t\tthrow new ERR_INVALID_CHAR('header content', name);\n\t\t}\n\n\t\tthis[kHeaders][name.toLowerCase()] = value;\n\t}\n\n\tsetNoDelay() {\n\t\t// HTTP2 sockets cannot be malformed, do nothing.\n\t}\n\n\tsetSocketKeepAlive() {\n\t\t// HTTP2 sockets cannot be malformed, do nothing.\n\t}\n\n\tsetTimeout(ms, callback) {\n\t\tconst applyTimeout = () => this._request.setTimeout(ms, callback);\n\n\t\tif (this._request) {\n\t\t\tapplyTimeout();\n\t\t} else {\n\t\t\tthis[kJobs].push(applyTimeout);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tget maxHeadersCount() {\n\t\tif (!this.destroyed && this._request) {\n\t\t\treturn this._request.session.localSettings.maxHeaderListSize;\n\t\t}\n\n\t\treturn undefined;\n\t}\n\n\tset maxHeadersCount(_value) {\n\t\t// Updating HTTP2 settings would affect all requests, do nothing.\n\t}\n}\n\nmodule.exports = ClientRequest;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/http2-wrapper/source/client-request.js?\n}")},"./node_modules/http2-wrapper/source/incoming-message.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{\nconst {Readable} = __webpack_require__(/*! stream */ \"stream\");\n\nclass IncomingMessage extends Readable {\n\tconstructor(socket, highWaterMark) {\n\t\tsuper({\n\t\t\thighWaterMark,\n\t\t\tautoDestroy: false\n\t\t});\n\n\t\tthis.statusCode = null;\n\t\tthis.statusMessage = '';\n\t\tthis.httpVersion = '2.0';\n\t\tthis.httpVersionMajor = 2;\n\t\tthis.httpVersionMinor = 0;\n\t\tthis.headers = {};\n\t\tthis.trailers = {};\n\t\tthis.req = null;\n\n\t\tthis.aborted = false;\n\t\tthis.complete = false;\n\t\tthis.upgrade = null;\n\n\t\tthis.rawHeaders = [];\n\t\tthis.rawTrailers = [];\n\n\t\tthis.socket = socket;\n\t\tthis.connection = socket;\n\n\t\tthis._dumped = false;\n\t}\n\n\t_destroy(error) {\n\t\tthis.req._request.destroy(error);\n\t}\n\n\tsetTimeout(ms, callback) {\n\t\tthis.req.setTimeout(ms, callback);\n\t\treturn this;\n\t}\n\n\t_dump() {\n\t\tif (!this._dumped) {\n\t\t\tthis._dumped = true;\n\n\t\t\tthis.removeAllListeners('data');\n\t\t\tthis.resume();\n\t\t}\n\t}\n\n\t_read() {\n\t\tif (this.req) {\n\t\t\tthis.req._request.resume();\n\t\t}\n\t}\n}\n\nmodule.exports = IncomingMessage;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/http2-wrapper/source/incoming-message.js?\n}")},"./node_modules/http2-wrapper/source/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval('{\nconst http2 = __webpack_require__(/*! http2 */ "http2");\nconst agent = __webpack_require__(/*! ./agent */ "./node_modules/http2-wrapper/source/agent.js");\nconst ClientRequest = __webpack_require__(/*! ./client-request */ "./node_modules/http2-wrapper/source/client-request.js");\nconst IncomingMessage = __webpack_require__(/*! ./incoming-message */ "./node_modules/http2-wrapper/source/incoming-message.js");\nconst auto = __webpack_require__(/*! ./auto */ "./node_modules/http2-wrapper/source/auto.js");\n\nconst request = (url, options, callback) => {\n\treturn new ClientRequest(url, options, callback);\n};\n\nconst get = (url, options, callback) => {\n\t// eslint-disable-next-line unicorn/prevent-abbreviations\n\tconst req = new ClientRequest(url, options, callback);\n\treq.end();\n\n\treturn req;\n};\n\nmodule.exports = {\n\t...http2,\n\tClientRequest,\n\tIncomingMessage,\n\t...agent,\n\trequest,\n\tget,\n\tauto\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/http2-wrapper/source/index.js?\n}')},"./node_modules/http2-wrapper/source/utils/calculate-server-name.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{\nconst net = __webpack_require__(/*! net */ \"net\");\n/* istanbul ignore file: https://github.com/nodejs/node/blob/v13.0.1/lib/_http_agent.js */\n\nmodule.exports = options => {\n\tlet servername = options.host;\n\tconst hostHeader = options.headers && options.headers.host;\n\n\tif (hostHeader) {\n\t\tif (hostHeader.startsWith('[')) {\n\t\t\tconst index = hostHeader.indexOf(']');\n\t\t\tif (index === -1) {\n\t\t\t\tservername = hostHeader;\n\t\t\t} else {\n\t\t\t\tservername = hostHeader.slice(1, -1);\n\t\t\t}\n\t\t} else {\n\t\t\tservername = hostHeader.split(':', 1)[0];\n\t\t}\n\t}\n\n\tif (net.isIP(servername)) {\n\t\treturn '';\n\t}\n\n\treturn servername;\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/http2-wrapper/source/utils/calculate-server-name.js?\n}")},"./node_modules/http2-wrapper/source/utils/errors.js":module=>{"use strict";eval("{\n/* istanbul ignore file: https://github.com/nodejs/node/blob/master/lib/internal/errors.js */\n\nconst makeError = (Base, key, getMessage) => {\n\tmodule.exports[key] = class NodeError extends Base {\n\t\tconstructor(...args) {\n\t\t\tsuper(typeof getMessage === 'string' ? getMessage : getMessage(args));\n\t\t\tthis.name = `${super.name} [${key}]`;\n\t\t\tthis.code = key;\n\t\t}\n\t};\n};\n\nmakeError(TypeError, 'ERR_INVALID_ARG_TYPE', args => {\n\tconst type = args[0].includes('.') ? 'property' : 'argument';\n\n\tlet valid = args[1];\n\tconst isManyTypes = Array.isArray(valid);\n\n\tif (isManyTypes) {\n\t\tvalid = `${valid.slice(0, -1).join(', ')} or ${valid.slice(-1)}`;\n\t}\n\n\treturn `The \"${args[0]}\" ${type} must be ${isManyTypes ? 'one of' : 'of'} type ${valid}. Received ${typeof args[2]}`;\n});\n\nmakeError(TypeError, 'ERR_INVALID_PROTOCOL', args => {\n\treturn `Protocol \"${args[0]}\" not supported. Expected \"${args[1]}\"`;\n});\n\nmakeError(Error, 'ERR_HTTP_HEADERS_SENT', args => {\n\treturn `Cannot ${args[0]} headers after they are sent to the client`;\n});\n\nmakeError(TypeError, 'ERR_INVALID_HTTP_TOKEN', args => {\n\treturn `${args[0]} must be a valid HTTP token [${args[1]}]`;\n});\n\nmakeError(TypeError, 'ERR_HTTP_INVALID_HEADER_VALUE', args => {\n\treturn `Invalid value \"${args[0]} for header \"${args[1]}\"`;\n});\n\nmakeError(TypeError, 'ERR_INVALID_CHAR', args => {\n\treturn `Invalid character in ${args[0]} [${args[1]}]`;\n});\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/http2-wrapper/source/utils/errors.js?\n}")},"./node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js":module=>{"use strict";eval("{\n\nmodule.exports = header => {\n\tswitch (header) {\n\t\tcase ':method':\n\t\tcase ':scheme':\n\t\tcase ':authority':\n\t\tcase ':path':\n\t\t\treturn true;\n\t\tdefault:\n\t\t\treturn false;\n\t}\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/http2-wrapper/source/utils/is-request-pseudo-header.js?\n}")},"./node_modules/http2-wrapper/source/utils/proxy-events.js":module=>{"use strict";eval("{\n\nmodule.exports = (from, to, events) => {\n\tfor (const event of events) {\n\t\tfrom.on(event, (...args) => to.emit(event, ...args));\n\t}\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/http2-wrapper/source/utils/proxy-events.js?\n}")},"./node_modules/http2-wrapper/source/utils/url-to-options.js":module=>{"use strict";eval("{\n/* istanbul ignore file: https://github.com/nodejs/node/blob/a91293d4d9ab403046ab5eb022332e4e3d249bd3/lib/internal/url.js#L1257 */\n\nmodule.exports = url => {\n\tconst options = {\n\t\tprotocol: url.protocol,\n\t\thostname: typeof url.hostname === 'string' && url.hostname.startsWith('[') ? url.hostname.slice(1, -1) : url.hostname,\n\t\thost: url.host,\n\t\thash: url.hash,\n\t\tsearch: url.search,\n\t\tpathname: url.pathname,\n\t\thref: url.href,\n\t\tpath: `${url.pathname || ''}${url.search || ''}`\n\t};\n\n\tif (typeof url.port === 'string' && url.port.length !== 0) {\n\t\toptions.port = Number(url.port);\n\t}\n\n\tif (url.username || url.password) {\n\t\toptions.auth = `${url.username || ''}:${url.password || ''}`;\n\t}\n\n\treturn options;\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/http2-wrapper/source/utils/url-to-options.js?\n}")},"./node_modules/json-buffer/index.js":(__unused_webpack_module,exports)=>{eval("{//TODO: handle reviver/dehydrate function like normal\n//and handle indentation, like normal.\n//if anyone needs this... please send pull request.\n\nexports.stringify = function stringify (o) {\n  if('undefined' == typeof o) return o\n\n  if(o && Buffer.isBuffer(o))\n    return JSON.stringify(':base64:' + o.toString('base64'))\n\n  if(o && o.toJSON)\n    o =  o.toJSON()\n\n  if(o && 'object' === typeof o) {\n    var s = ''\n    var array = Array.isArray(o)\n    s = array ? '[' : '{'\n    var first = true\n\n    for(var k in o) {\n      var ignore = 'function' == typeof o[k] || (!array && 'undefined' === typeof o[k])\n      if(Object.hasOwnProperty.call(o, k) && !ignore) {\n        if(!first)\n          s += ','\n        first = false\n        if (array) {\n          if(o[k] == undefined)\n            s += 'null'\n          else\n            s += stringify(o[k])\n        } else if (o[k] !== void(0)) {\n          s += stringify(k) + ':' + stringify(o[k])\n        }\n      }\n    }\n\n    s += array ? ']' : '}'\n\n    return s\n  } else if ('string' === typeof o) {\n    return JSON.stringify(/^:/.test(o) ? ':' + o : o)\n  } else if ('undefined' === typeof o) {\n    return 'null';\n  } else\n    return JSON.stringify(o)\n}\n\nexports.parse = function (s) {\n  return JSON.parse(s, function (key, value) {\n    if('string' === typeof value) {\n      if(/^:base64:/.test(value))\n        return Buffer.from(value.substring(8), 'base64')\n      else\n        return /^:/.test(value) ? value.substring(1) : value \n    }\n    return value\n  })\n}\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/json-buffer/index.js?\n}")},"./node_modules/keyv/src sync recursive":module=>{eval('{function webpackEmptyContext(req) {\n\tvar e = new Error("Cannot find module \'" + req + "\'");\n\te.code = \'MODULE_NOT_FOUND\';\n\tthrow e;\n}\nwebpackEmptyContext.keys = () => ([]);\nwebpackEmptyContext.resolve = webpackEmptyContext;\nwebpackEmptyContext.id = "./node_modules/keyv/src sync recursive";\nmodule.exports = webpackEmptyContext;\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/keyv/src/_sync?\n}')},"./node_modules/keyv/src/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst JSONB = __webpack_require__(/*! json-buffer */ \"./node_modules/json-buffer/index.js\");\n\nconst loadStore = options => {\n\tconst adapters = {\n\t\tredis: '@keyv/redis',\n\t\trediss: '@keyv/redis',\n\t\tmongodb: '@keyv/mongo',\n\t\tmongo: '@keyv/mongo',\n\t\tsqlite: '@keyv/sqlite',\n\t\tpostgresql: '@keyv/postgres',\n\t\tpostgres: '@keyv/postgres',\n\t\tmysql: '@keyv/mysql',\n\t\tetcd: '@keyv/etcd',\n\t\toffline: '@keyv/offline',\n\t\ttiered: '@keyv/tiered',\n\t};\n\tif (options.adapter || options.uri) {\n\t\tconst adapter = options.adapter || /^[^:+]*/.exec(options.uri)[0];\n\t\treturn new (__webpack_require__(\"./node_modules/keyv/src sync recursive\")(adapters[adapter]))(options);\n\t}\n\n\treturn new Map();\n};\n\nconst iterableAdapters = [\n\t'sqlite',\n\t'postgres',\n\t'mysql',\n\t'mongo',\n\t'redis',\n\t'tiered',\n];\n\nclass Keyv extends EventEmitter {\n\tconstructor(uri, {emitErrors = true, ...options} = {}) {\n\t\tsuper();\n\t\tthis.opts = {\n\t\t\tnamespace: 'keyv',\n\t\t\tserialize: JSONB.stringify,\n\t\t\tdeserialize: JSONB.parse,\n\t\t\t...((typeof uri === 'string') ? {uri} : uri),\n\t\t\t...options,\n\t\t};\n\n\t\tif (!this.opts.store) {\n\t\t\tconst adapterOptions = {...this.opts};\n\t\t\tthis.opts.store = loadStore(adapterOptions);\n\t\t}\n\n\t\tif (this.opts.compression) {\n\t\t\tconst compression = this.opts.compression;\n\t\t\tthis.opts.serialize = compression.serialize.bind(compression);\n\t\t\tthis.opts.deserialize = compression.deserialize.bind(compression);\n\t\t}\n\n\t\tif (typeof this.opts.store.on === 'function' && emitErrors) {\n\t\t\tthis.opts.store.on('error', error => this.emit('error', error));\n\t\t}\n\n\t\tthis.opts.store.namespace = this.opts.namespace;\n\n\t\tconst generateIterator = iterator => async function * () {\n\t\t\tfor await (const [key, raw] of typeof iterator === 'function'\n\t\t\t\t? iterator(this.opts.store.namespace)\n\t\t\t\t: iterator) {\n\t\t\t\tconst data = await this.opts.deserialize(raw);\n\t\t\t\tif (this.opts.store.namespace && !key.includes(this.opts.store.namespace)) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tif (typeof data.expires === 'number' && Date.now() > data.expires) {\n\t\t\t\t\tthis.delete(key);\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tyield [this._getKeyUnprefix(key), data.value];\n\t\t\t}\n\t\t};\n\n\t\t// Attach iterators\n\t\tif (typeof this.opts.store[Symbol.iterator] === 'function' && this.opts.store instanceof Map) {\n\t\t\tthis.iterator = generateIterator(this.opts.store);\n\t\t} else if (typeof this.opts.store.iterator === 'function' && this.opts.store.opts\n\t\t\t&& this._checkIterableAdaptar()) {\n\t\t\tthis.iterator = generateIterator(this.opts.store.iterator.bind(this.opts.store));\n\t\t}\n\t}\n\n\t_checkIterableAdaptar() {\n\t\treturn iterableAdapters.includes(this.opts.store.opts.dialect)\n\t\t\t|| iterableAdapters.findIndex(element => this.opts.store.opts.url.includes(element)) >= 0;\n\t}\n\n\t_getKeyPrefix(key) {\n\t\treturn `${this.opts.namespace}:${key}`;\n\t}\n\n\t_getKeyPrefixArray(keys) {\n\t\treturn keys.map(key => `${this.opts.namespace}:${key}`);\n\t}\n\n\t_getKeyUnprefix(key) {\n\t\treturn key\n\t\t\t.split(':')\n\t\t\t.splice(1)\n\t\t\t.join(':');\n\t}\n\n\tget(key, options) {\n\t\tconst {store} = this.opts;\n\t\tconst isArray = Array.isArray(key);\n\t\tconst keyPrefixed = isArray ? this._getKeyPrefixArray(key) : this._getKeyPrefix(key);\n\t\tif (isArray && store.getMany === undefined) {\n\t\t\tconst promises = [];\n\t\t\tfor (const key of keyPrefixed) {\n\t\t\t\tpromises.push(Promise.resolve()\n\t\t\t\t\t.then(() => store.get(key))\n\t\t\t\t\t.then(data => (typeof data === 'string') ? this.opts.deserialize(data) : (this.opts.compression ? this.opts.deserialize(data) : data))\n\t\t\t\t\t.then(data => {\n\t\t\t\t\t\tif (data === undefined || data === null) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof data.expires === 'number' && Date.now() > data.expires) {\n\t\t\t\t\t\t\treturn this.delete(key).then(() => undefined);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn (options && options.raw) ? data : data.value;\n\t\t\t\t\t}),\n\t\t\t\t);\n\t\t\t}\n\n\t\t\treturn Promise.allSettled(promises)\n\t\t\t\t.then(values => {\n\t\t\t\t\tconst data = [];\n\t\t\t\t\tfor (const value of values) {\n\t\t\t\t\t\tdata.push(value.value);\n\t\t\t\t\t}\n\n\t\t\t\t\treturn data;\n\t\t\t\t});\n\t\t}\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() => isArray ? store.getMany(keyPrefixed) : store.get(keyPrefixed))\n\t\t\t.then(data => (typeof data === 'string') ? this.opts.deserialize(data) : (this.opts.compression ? this.opts.deserialize(data) : data))\n\t\t\t.then(data => {\n\t\t\t\tif (data === undefined || data === null) {\n\t\t\t\t\treturn undefined;\n\t\t\t\t}\n\n\t\t\t\tif (isArray) {\n\t\t\t\t\treturn data.map((row, index) => {\n\t\t\t\t\t\tif ((typeof row === 'string')) {\n\t\t\t\t\t\t\trow = this.opts.deserialize(row);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (row === undefined || row === null) {\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (typeof row.expires === 'number' && Date.now() > row.expires) {\n\t\t\t\t\t\t\tthis.delete(key[index]).then(() => undefined);\n\t\t\t\t\t\t\treturn undefined;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\treturn (options && options.raw) ? row : row.value;\n\t\t\t\t\t});\n\t\t\t\t}\n\n\t\t\t\tif (typeof data.expires === 'number' && Date.now() > data.expires) {\n\t\t\t\t\treturn this.delete(key).then(() => undefined);\n\t\t\t\t}\n\n\t\t\t\treturn (options && options.raw) ? data : data.value;\n\t\t\t});\n\t}\n\n\tset(key, value, ttl) {\n\t\tconst keyPrefixed = this._getKeyPrefix(key);\n\t\tif (typeof ttl === 'undefined') {\n\t\t\tttl = this.opts.ttl;\n\t\t}\n\n\t\tif (ttl === 0) {\n\t\t\tttl = undefined;\n\t\t}\n\n\t\tconst {store} = this.opts;\n\n\t\treturn Promise.resolve()\n\t\t\t.then(() => {\n\t\t\t\tconst expires = (typeof ttl === 'number') ? (Date.now() + ttl) : null;\n\t\t\t\tif (typeof value === 'symbol') {\n\t\t\t\t\tthis.emit('error', 'symbol cannot be serialized');\n\t\t\t\t}\n\n\t\t\t\tvalue = {value, expires};\n\t\t\t\treturn this.opts.serialize(value);\n\t\t\t})\n\t\t\t.then(value => store.set(keyPrefixed, value, ttl))\n\t\t\t.then(() => true);\n\t}\n\n\tdelete(key) {\n\t\tconst {store} = this.opts;\n\t\tif (Array.isArray(key)) {\n\t\t\tconst keyPrefixed = this._getKeyPrefixArray(key);\n\t\t\tif (store.deleteMany === undefined) {\n\t\t\t\tconst promises = [];\n\t\t\t\tfor (const key of keyPrefixed) {\n\t\t\t\t\tpromises.push(store.delete(key));\n\t\t\t\t}\n\n\t\t\t\treturn Promise.allSettled(promises)\n\t\t\t\t\t.then(values => values.every(x => x.value === true));\n\t\t\t}\n\n\t\t\treturn Promise.resolve()\n\t\t\t\t.then(() => store.deleteMany(keyPrefixed));\n\t\t}\n\n\t\tconst keyPrefixed = this._getKeyPrefix(key);\n\t\treturn Promise.resolve()\n\t\t\t.then(() => store.delete(keyPrefixed));\n\t}\n\n\tclear() {\n\t\tconst {store} = this.opts;\n\t\treturn Promise.resolve()\n\t\t\t.then(() => store.clear());\n\t}\n\n\thas(key) {\n\t\tconst keyPrefixed = this._getKeyPrefix(key);\n\t\tconst {store} = this.opts;\n\t\treturn Promise.resolve()\n\t\t\t.then(async () => {\n\t\t\t\tif (typeof store.has === 'function') {\n\t\t\t\t\treturn store.has(keyPrefixed);\n\t\t\t\t}\n\n\t\t\t\tconst value = await store.get(keyPrefixed);\n\t\t\t\treturn value !== undefined;\n\t\t\t});\n\t}\n\n\tdisconnect() {\n\t\tconst {store} = this.opts;\n\t\tif (typeof store.disconnect === 'function') {\n\t\t\treturn store.disconnect();\n\t\t}\n\t}\n}\n\nmodule.exports = Keyv;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/keyv/src/index.js?\n}")},"./node_modules/lowercase-keys/index.js":module=>{"use strict";eval("{\nmodule.exports = object => {\n\tconst result = {};\n\n\tfor (const [key, value] of Object.entries(object)) {\n\t\tresult[key.toLowerCase()] = value;\n\t}\n\n\treturn result;\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/lowercase-keys/index.js?\n}")},"./node_modules/mimic-fn/index.js":module=>{"use strict";eval("{\n\nconst copyProperty = (to, from, property, ignoreNonConfigurable) => {\n\t// `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n\t// `Function#prototype` is non-writable and non-configurable so can never be modified.\n\tif (property === 'length' || property === 'prototype') {\n\t\treturn;\n\t}\n\n\t// `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n\tif (property === 'arguments' || property === 'caller') {\n\t\treturn;\n\t}\n\n\tconst toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n\tconst fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n\n\tif (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n\t\treturn;\n\t}\n\n\tObject.defineProperty(to, property, fromDescriptor);\n};\n\n// `Object.defineProperty()` throws if the property exists, is not configurable and either:\n//  - one its descriptors is changed\n//  - it is non-writable and its value is changed\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n\treturn toDescriptor === undefined || toDescriptor.configurable || (\n\t\ttoDescriptor.writable === fromDescriptor.writable &&\n\t\ttoDescriptor.enumerable === fromDescriptor.enumerable &&\n\t\ttoDescriptor.configurable === fromDescriptor.configurable &&\n\t\t(toDescriptor.writable || toDescriptor.value === fromDescriptor.value)\n\t);\n};\n\nconst changePrototype = (to, from) => {\n\tconst fromPrototype = Object.getPrototypeOf(from);\n\tif (fromPrototype === Object.getPrototypeOf(to)) {\n\t\treturn;\n\t}\n\n\tObject.setPrototypeOf(to, fromPrototype);\n};\n\nconst wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\\n${fromBody}`;\n\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n\n// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nconst changeToString = (to, from, name) => {\n\tconst withName = name === '' ? '' : `with ${name.trim()}() `;\n\tconst newToString = wrappedToString.bind(null, withName, from.toString());\n\t// Ensure `to.toString.toString` is non-enumerable and has the same `same`\n\tObject.defineProperty(newToString, 'name', toStringName);\n\tObject.defineProperty(to, 'toString', {...toStringDescriptor, value: newToString});\n};\n\nconst mimicFn = (to, from, {ignoreNonConfigurable = false} = {}) => {\n\tconst {name} = to;\n\n\tfor (const property of Reflect.ownKeys(from)) {\n\t\tcopyProperty(to, from, property, ignoreNonConfigurable);\n\t}\n\n\tchangePrototype(to, from);\n\tchangeToString(to, from, name);\n\n\treturn to;\n};\n\nmodule.exports = mimicFn;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/mimic-fn/index.js?\n}")},"./node_modules/mimic-response/index.js":module=>{"use strict";eval("{\n\n// We define these manually to ensure they're always copied\n// even if they would move up the prototype chain\n// https://nodejs.org/api/http.html#http_class_http_incomingmessage\nconst knownProperties = [\n\t'aborted',\n\t'complete',\n\t'headers',\n\t'httpVersion',\n\t'httpVersionMinor',\n\t'httpVersionMajor',\n\t'method',\n\t'rawHeaders',\n\t'rawTrailers',\n\t'setTimeout',\n\t'socket',\n\t'statusCode',\n\t'statusMessage',\n\t'trailers',\n\t'url'\n];\n\nmodule.exports = (fromStream, toStream) => {\n\tif (toStream._readableState.autoDestroy) {\n\t\tthrow new Error('The second stream must have the `autoDestroy` option set to `false`');\n\t}\n\n\tconst fromProperties = new Set(Object.keys(fromStream).concat(knownProperties));\n\n\tconst properties = {};\n\n\tfor (const property of fromProperties) {\n\t\t// Don't overwrite existing properties.\n\t\tif (property in toStream) {\n\t\t\tcontinue;\n\t\t}\n\n\t\tproperties[property] = {\n\t\t\tget() {\n\t\t\t\tconst value = fromStream[property];\n\t\t\t\tconst isFunction = typeof value === 'function';\n\n\t\t\t\treturn isFunction ? value.bind(fromStream) : value;\n\t\t\t},\n\t\t\tset(value) {\n\t\t\t\tfromStream[property] = value;\n\t\t\t},\n\t\t\tenumerable: true,\n\t\t\tconfigurable: false\n\t\t};\n\t}\n\n\tObject.defineProperties(toStream, properties);\n\n\tfromStream.once('aborted', () => {\n\t\ttoStream.destroy();\n\n\t\ttoStream.emit('aborted');\n\t});\n\n\tfromStream.once('close', () => {\n\t\tif (fromStream.complete) {\n\t\t\tif (toStream.readable) {\n\t\t\t\ttoStream.once('end', () => {\n\t\t\t\t\ttoStream.emit('close');\n\t\t\t\t});\n\t\t\t} else {\n\t\t\t\ttoStream.emit('close');\n\t\t\t}\n\t\t} else {\n\t\t\ttoStream.emit('close');\n\t\t}\n\t});\n\n\treturn toStream;\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/mimic-response/index.js?\n}")},"./node_modules/normalize-url/index.js":module=>{"use strict";eval("{\n\n// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\nconst DATA_URL_DEFAULT_MIME_TYPE = 'text/plain';\nconst DATA_URL_DEFAULT_CHARSET = 'us-ascii';\n\nconst testParameter = (name, filters) => {\n\treturn filters.some(filter => filter instanceof RegExp ? filter.test(name) : filter === name);\n};\n\nconst normalizeDataURL = (urlString, {stripHash}) => {\n\tconst match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);\n\n\tif (!match) {\n\t\tthrow new Error(`Invalid URL: ${urlString}`);\n\t}\n\n\tlet {type, data, hash} = match.groups;\n\tconst mediaType = type.split(';');\n\thash = stripHash ? '' : hash;\n\n\tlet isBase64 = false;\n\tif (mediaType[mediaType.length - 1] === 'base64') {\n\t\tmediaType.pop();\n\t\tisBase64 = true;\n\t}\n\n\t// Lowercase MIME type\n\tconst mimeType = (mediaType.shift() || '').toLowerCase();\n\tconst attributes = mediaType\n\t\t.map(attribute => {\n\t\t\tlet [key, value = ''] = attribute.split('=').map(string => string.trim());\n\n\t\t\t// Lowercase `charset`\n\t\t\tif (key === 'charset') {\n\t\t\t\tvalue = value.toLowerCase();\n\n\t\t\t\tif (value === DATA_URL_DEFAULT_CHARSET) {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn `${key}${value ? `=${value}` : ''}`;\n\t\t})\n\t\t.filter(Boolean);\n\n\tconst normalizedMediaType = [\n\t\t...attributes\n\t];\n\n\tif (isBase64) {\n\t\tnormalizedMediaType.push('base64');\n\t}\n\n\tif (normalizedMediaType.length !== 0 || (mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE)) {\n\t\tnormalizedMediaType.unshift(mimeType);\n\t}\n\n\treturn `data:${normalizedMediaType.join(';')},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ''}`;\n};\n\nconst normalizeUrl = (urlString, options) => {\n\toptions = {\n\t\tdefaultProtocol: 'http:',\n\t\tnormalizeProtocol: true,\n\t\tforceHttp: false,\n\t\tforceHttps: false,\n\t\tstripAuthentication: true,\n\t\tstripHash: false,\n\t\tstripTextFragment: true,\n\t\tstripWWW: true,\n\t\tremoveQueryParameters: [/^utm_\\w+/i],\n\t\tremoveTrailingSlash: true,\n\t\tremoveSingleSlash: true,\n\t\tremoveDirectoryIndex: false,\n\t\tsortQueryParameters: true,\n\t\t...options\n\t};\n\n\turlString = urlString.trim();\n\n\t// Data URL\n\tif (/^data:/i.test(urlString)) {\n\t\treturn normalizeDataURL(urlString, options);\n\t}\n\n\tif (/^view-source:/i.test(urlString)) {\n\t\tthrow new Error('`view-source:` is not supported as it is a non-standard protocol');\n\t}\n\n\tconst hasRelativeProtocol = urlString.startsWith('//');\n\tconst isRelativeUrl = !hasRelativeProtocol && /^\\.*\\//.test(urlString);\n\n\t// Prepend protocol\n\tif (!isRelativeUrl) {\n\t\turlString = urlString.replace(/^(?!(?:\\w+:)?\\/\\/)|^\\/\\//, options.defaultProtocol);\n\t}\n\n\tconst urlObj = new URL(urlString);\n\n\tif (options.forceHttp && options.forceHttps) {\n\t\tthrow new Error('The `forceHttp` and `forceHttps` options cannot be used together');\n\t}\n\n\tif (options.forceHttp && urlObj.protocol === 'https:') {\n\t\turlObj.protocol = 'http:';\n\t}\n\n\tif (options.forceHttps && urlObj.protocol === 'http:') {\n\t\turlObj.protocol = 'https:';\n\t}\n\n\t// Remove auth\n\tif (options.stripAuthentication) {\n\t\turlObj.username = '';\n\t\turlObj.password = '';\n\t}\n\n\t// Remove hash\n\tif (options.stripHash) {\n\t\turlObj.hash = '';\n\t} else if (options.stripTextFragment) {\n\t\turlObj.hash = urlObj.hash.replace(/#?:~:text.*?$/i, '');\n\t}\n\n\t// Remove duplicate slashes if not preceded by a protocol\n\tif (urlObj.pathname) {\n\t\turlObj.pathname = urlObj.pathname.replace(/(?<!\\b(?:[a-z][a-z\\d+\\-.]{1,50}:))\\/{2,}/g, '/');\n\t}\n\n\t// Decode URI octets\n\tif (urlObj.pathname) {\n\t\ttry {\n\t\t\turlObj.pathname = decodeURI(urlObj.pathname);\n\t\t} catch (_) {}\n\t}\n\n\t// Remove directory index\n\tif (options.removeDirectoryIndex === true) {\n\t\toptions.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n\t}\n\n\tif (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {\n\t\tlet pathComponents = urlObj.pathname.split('/');\n\t\tconst lastComponent = pathComponents[pathComponents.length - 1];\n\n\t\tif (testParameter(lastComponent, options.removeDirectoryIndex)) {\n\t\t\tpathComponents = pathComponents.slice(0, pathComponents.length - 1);\n\t\t\turlObj.pathname = pathComponents.slice(1).join('/') + '/';\n\t\t}\n\t}\n\n\tif (urlObj.hostname) {\n\t\t// Remove trailing dot\n\t\turlObj.hostname = urlObj.hostname.replace(/\\.$/, '');\n\n\t\t// Remove `www.`\n\t\tif (options.stripWWW && /^www\\.(?!www\\.)(?:[a-z\\-\\d]{1,63})\\.(?:[a-z.\\-\\d]{2,63})$/.test(urlObj.hostname)) {\n\t\t\t// Each label should be max 63 at length (min: 1).\n\t\t\t// Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names\n\t\t\t// Each TLD should be up to 63 characters long (min: 2).\n\t\t\t// It is technically possible to have a single character TLD, but none currently exist.\n\t\t\turlObj.hostname = urlObj.hostname.replace(/^www\\./, '');\n\t\t}\n\t}\n\n\t// Remove query unwanted parameters\n\tif (Array.isArray(options.removeQueryParameters)) {\n\t\tfor (const key of [...urlObj.searchParams.keys()]) {\n\t\t\tif (testParameter(key, options.removeQueryParameters)) {\n\t\t\t\turlObj.searchParams.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (options.removeQueryParameters === true) {\n\t\turlObj.search = '';\n\t}\n\n\t// Sort query parameters\n\tif (options.sortQueryParameters) {\n\t\turlObj.searchParams.sort();\n\t}\n\n\tif (options.removeTrailingSlash) {\n\t\turlObj.pathname = urlObj.pathname.replace(/\\/$/, '');\n\t}\n\n\tconst oldUrlString = urlString;\n\n\t// Take advantage of many of the Node `url` normalizations\n\turlString = urlObj.toString();\n\n\tif (!options.removeSingleSlash && urlObj.pathname === '/' && !oldUrlString.endsWith('/') && urlObj.hash === '') {\n\t\turlString = urlString.replace(/\\/$/, '');\n\t}\n\n\t// Remove ending `/` unless removeSingleSlash is false\n\tif ((options.removeTrailingSlash || urlObj.pathname === '/') && urlObj.hash === '' && options.removeSingleSlash) {\n\t\turlString = urlString.replace(/\\/$/, '');\n\t}\n\n\t// Restore relative protocol, if applicable\n\tif (hasRelativeProtocol && !options.normalizeProtocol) {\n\t\turlString = urlString.replace(/^http:\\/\\//, '//');\n\t}\n\n\t// Remove http/https\n\tif (options.stripProtocol) {\n\t\turlString = urlString.replace(/^(?:https?:)?\\/\\//, '');\n\t}\n\n\treturn urlString;\n};\n\nmodule.exports = normalizeUrl;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/normalize-url/index.js?\n}")},"./node_modules/once/once.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("{var wrappy = __webpack_require__(/*! wrappy */ \"./node_modules/wrappy/wrappy.js\")\nmodule.exports = wrappy(once)\nmodule.exports.strict = wrappy(onceStrict)\n\nonce.proto = once(function () {\n  Object.defineProperty(Function.prototype, 'once', {\n    value: function () {\n      return once(this)\n    },\n    configurable: true\n  })\n\n  Object.defineProperty(Function.prototype, 'onceStrict', {\n    value: function () {\n      return onceStrict(this)\n    },\n    configurable: true\n  })\n})\n\nfunction once (fn) {\n  var f = function () {\n    if (f.called) return f.value\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  f.called = false\n  return f\n}\n\nfunction onceStrict (fn) {\n  var f = function () {\n    if (f.called)\n      throw new Error(f.onceError)\n    f.called = true\n    return f.value = fn.apply(this, arguments)\n  }\n  var name = fn.name || 'Function wrapped with `once`'\n  f.onceError = name + \" shouldn't be called more than once\"\n  f.called = false\n  return f\n}\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/once/once.js?\n}")},"./node_modules/p-cancelable/index.js":module=>{"use strict";eval("{\n\nclass CancelError extends Error {\n\tconstructor(reason) {\n\t\tsuper(reason || 'Promise was canceled');\n\t\tthis.name = 'CancelError';\n\t}\n\n\tget isCanceled() {\n\t\treturn true;\n\t}\n}\n\nclass PCancelable {\n\tstatic fn(userFn) {\n\t\treturn (...arguments_) => {\n\t\t\treturn new PCancelable((resolve, reject, onCancel) => {\n\t\t\t\targuments_.push(onCancel);\n\t\t\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\t\t\tuserFn(...arguments_).then(resolve, reject);\n\t\t\t});\n\t\t};\n\t}\n\n\tconstructor(executor) {\n\t\tthis._cancelHandlers = [];\n\t\tthis._isPending = true;\n\t\tthis._isCanceled = false;\n\t\tthis._rejectOnCancel = true;\n\n\t\tthis._promise = new Promise((resolve, reject) => {\n\t\t\tthis._reject = reject;\n\n\t\t\tconst onResolve = value => {\n\t\t\t\tif (!this._isCanceled || !onCancel.shouldReject) {\n\t\t\t\t\tthis._isPending = false;\n\t\t\t\t\tresolve(value);\n\t\t\t\t}\n\t\t\t};\n\n\t\t\tconst onReject = error => {\n\t\t\t\tthis._isPending = false;\n\t\t\t\treject(error);\n\t\t\t};\n\n\t\t\tconst onCancel = handler => {\n\t\t\t\tif (!this._isPending) {\n\t\t\t\t\tthrow new Error('The `onCancel` handler was attached after the promise settled.');\n\t\t\t\t}\n\n\t\t\t\tthis._cancelHandlers.push(handler);\n\t\t\t};\n\n\t\t\tObject.defineProperties(onCancel, {\n\t\t\t\tshouldReject: {\n\t\t\t\t\tget: () => this._rejectOnCancel,\n\t\t\t\t\tset: boolean => {\n\t\t\t\t\t\tthis._rejectOnCancel = boolean;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t});\n\n\t\t\treturn executor(onResolve, onReject, onCancel);\n\t\t});\n\t}\n\n\tthen(onFulfilled, onRejected) {\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\treturn this._promise.then(onFulfilled, onRejected);\n\t}\n\n\tcatch(onRejected) {\n\t\treturn this._promise.catch(onRejected);\n\t}\n\n\tfinally(onFinally) {\n\t\treturn this._promise.finally(onFinally);\n\t}\n\n\tcancel(reason) {\n\t\tif (!this._isPending || this._isCanceled) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._isCanceled = true;\n\n\t\tif (this._cancelHandlers.length > 0) {\n\t\t\ttry {\n\t\t\t\tfor (const handler of this._cancelHandlers) {\n\t\t\t\t\thandler();\n\t\t\t\t}\n\t\t\t} catch (error) {\n\t\t\t\tthis._reject(error);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (this._rejectOnCancel) {\n\t\t\tthis._reject(new CancelError(reason));\n\t\t}\n\t}\n\n\tget isCanceled() {\n\t\treturn this._isCanceled;\n\t}\n}\n\nObject.setPrototypeOf(PCancelable.prototype, Promise.prototype);\n\nmodule.exports = PCancelable;\nmodule.exports.CancelError = CancelError;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/p-cancelable/index.js?\n}")},"./node_modules/p-finally/index.js":module=>{"use strict";eval("{\nmodule.exports = (promise, onFinally) => {\n\tonFinally = onFinally || (() => {});\n\n\treturn promise.then(\n\t\tval => new Promise(resolve => {\n\t\t\tresolve(onFinally());\n\t\t}).then(() => val),\n\t\terr => new Promise(resolve => {\n\t\t\tresolve(onFinally());\n\t\t}).then(() => {\n\t\t\tthrow err;\n\t\t})\n\t);\n};\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/p-finally/index.js?\n}")},"./node_modules/p-queue/dist/index.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval("{\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nconst EventEmitter = __webpack_require__(/*! eventemitter3 */ \"./node_modules/p-queue/node_modules/eventemitter3/index.js\");\nconst p_timeout_1 = __webpack_require__(/*! p-timeout */ \"./node_modules/p-queue/node_modules/p-timeout/index.js\");\nconst priority_queue_1 = __webpack_require__(/*! ./priority-queue */ \"./node_modules/p-queue/dist/priority-queue.js\");\n// eslint-disable-next-line @typescript-eslint/no-empty-function\nconst empty = () => { };\nconst timeoutError = new p_timeout_1.TimeoutError();\n/**\nPromise queue with concurrency control.\n*/\nclass PQueue extends EventEmitter {\n    constructor(options) {\n        var _a, _b, _c, _d;\n        super();\n        this._intervalCount = 0;\n        this._intervalEnd = 0;\n        this._pendingCount = 0;\n        this._resolveEmpty = empty;\n        this._resolveIdle = empty;\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = Object.assign({ carryoverConcurrencyCount: false, intervalCap: Infinity, interval: 0, concurrency: Infinity, autoStart: true, queueClass: priority_queue_1.default }, options);\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${(_b = (_a = options.intervalCap) === null || _a === void 0 ? void 0 : _a.toString()) !== null && _b !== void 0 ? _b : ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${(_d = (_c = options.interval) === null || _c === void 0 ? void 0 : _c.toString()) !== null && _d !== void 0 ? _d : ''}\\` (${typeof options.interval})`);\n        }\n        this._carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this._isIntervalIgnored = options.intervalCap === Infinity || options.interval === 0;\n        this._intervalCap = options.intervalCap;\n        this._interval = options.interval;\n        this._queue = new options.queueClass();\n        this._queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this._timeout = options.timeout;\n        this._throwOnTimeout = options.throwOnTimeout === true;\n        this._isPaused = options.autoStart === false;\n    }\n    get _doesIntervalAllowAnother() {\n        return this._isIntervalIgnored || this._intervalCount < this._intervalCap;\n    }\n    get _doesConcurrentAllowAnother() {\n        return this._pendingCount < this._concurrency;\n    }\n    _next() {\n        this._pendingCount--;\n        this._tryToStartAnother();\n        this.emit('next');\n    }\n    _resolvePromises() {\n        this._resolveEmpty();\n        this._resolveEmpty = empty;\n        if (this._pendingCount === 0) {\n            this._resolveIdle();\n            this._resolveIdle = empty;\n            this.emit('idle');\n        }\n    }\n    _onResumeInterval() {\n        this._onInterval();\n        this._initializeIntervalIfNeeded();\n        this._timeoutId = undefined;\n    }\n    _isIntervalPaused() {\n        const now = Date.now();\n        if (this._intervalId === undefined) {\n            const delay = this._intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this._intervalCount = (this._carryoverConcurrencyCount) ? this._pendingCount : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this._timeoutId === undefined) {\n                    this._timeoutId = setTimeout(() => {\n                        this._onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _tryToStartAnother() {\n        if (this._queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this._intervalId) {\n                clearInterval(this._intervalId);\n            }\n            this._intervalId = undefined;\n            this._resolvePromises();\n            return false;\n        }\n        if (!this._isPaused) {\n            const canInitializeInterval = !this._isIntervalPaused();\n            if (this._doesIntervalAllowAnother && this._doesConcurrentAllowAnother) {\n                const job = this._queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this._initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    _initializeIntervalIfNeeded() {\n        if (this._isIntervalIgnored || this._intervalId !== undefined) {\n            return;\n        }\n        this._intervalId = setInterval(() => {\n            this._onInterval();\n        }, this._interval);\n        this._intervalEnd = Date.now() + this._interval;\n    }\n    _onInterval() {\n        if (this._intervalCount === 0 && this._pendingCount === 0 && this._intervalId) {\n            clearInterval(this._intervalId);\n            this._intervalId = undefined;\n        }\n        this._intervalCount = this._carryoverConcurrencyCount ? this._pendingCount : 0;\n        this._processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    _processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this._tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this._concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this._concurrency = newConcurrency;\n        this._processQueue();\n    }\n    /**\n    Adds a sync or async task to the queue. Always returns a promise.\n    */\n    async add(fn, options = {}) {\n        return new Promise((resolve, reject) => {\n            const run = async () => {\n                this._pendingCount++;\n                this._intervalCount++;\n                try {\n                    const operation = (this._timeout === undefined && options.timeout === undefined) ? fn() : p_timeout_1.default(Promise.resolve(fn()), (options.timeout === undefined ? this._timeout : options.timeout), () => {\n                        if (options.throwOnTimeout === undefined ? this._throwOnTimeout : options.throwOnTimeout) {\n                            reject(timeoutError);\n                        }\n                        return undefined;\n                    });\n                    resolve(await operation);\n                }\n                catch (error) {\n                    reject(error);\n                }\n                this._next();\n            };\n            this._queue.enqueue(run, options);\n            this._tryToStartAnother();\n            this.emit('add');\n        });\n    }\n    /**\n    Same as `.add()`, but accepts an array of sync or async functions.\n\n    @returns A promise that resolves when all functions are resolved.\n    */\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this._isPaused) {\n            return this;\n        }\n        this._isPaused = false;\n        this._processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this._isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this._queue = new this._queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveEmpty;\n            this._resolveEmpty = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this._pendingCount === 0 && this._queue.size === 0) {\n            return;\n        }\n        return new Promise(resolve => {\n            const existingResolve = this._resolveIdle;\n            this._resolveIdle = () => {\n                existingResolve();\n                resolve();\n            };\n        });\n    }\n    /**\n    Size of the queue.\n    */\n    get size() {\n        return this._queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-fn-reference-in-iterator\n        return this._queue.filter(options).length;\n    }\n    /**\n    Number of pending promises.\n    */\n    get pending() {\n        return this._pendingCount;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this._isPaused;\n    }\n    get timeout() {\n        return this._timeout;\n    }\n    /**\n    Set the timeout for future operations.\n    */\n    set timeout(milliseconds) {\n        this._timeout = milliseconds;\n    }\n}\nexports[\"default\"] = PQueue;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/p-queue/dist/index.js?\n}")},"./node_modules/p-queue/dist/lower-bound.js":(__unused_webpack_module,exports)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\n// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nfunction lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = (count / 2) | 0;\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\nexports["default"] = lowerBound;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/p-queue/dist/lower-bound.js?\n}')},"./node_modules/p-queue/dist/priority-queue.js":(__unused_webpack_module,exports,__webpack_require__)=>{"use strict";eval('{\nObject.defineProperty(exports, "__esModule", ({ value: true }));\nconst lower_bound_1 = __webpack_require__(/*! ./lower-bound */ "./node_modules/p-queue/dist/lower-bound.js");\nclass PriorityQueue {\n    constructor() {\n        this._queue = [];\n    }\n    enqueue(run, options) {\n        options = Object.assign({ priority: 0 }, options);\n        const element = {\n            priority: options.priority,\n            run\n        };\n        if (this.size && this._queue[this.size - 1].priority >= options.priority) {\n            this._queue.push(element);\n            return;\n        }\n        const index = lower_bound_1.default(this._queue, element, (a, b) => b.priority - a.priority);\n        this._queue.splice(index, 0, element);\n    }\n    dequeue() {\n        const item = this._queue.shift();\n        return item === null || item === void 0 ? void 0 : item.run;\n    }\n    filter(options) {\n        return this._queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return this._queue.length;\n    }\n}\nexports["default"] = PriorityQueue;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/p-queue/dist/priority-queue.js?\n}')},"./node_modules/p-queue/node_modules/eventemitter3/index.js":module=>{"use strict";eval("{\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif (true) {\n  module.exports = EventEmitter;\n}\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/p-queue/node_modules/eventemitter3/index.js?\n}")},"./node_modules/p-queue/node_modules/p-timeout/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{\n\nconst pFinally = __webpack_require__(/*! p-finally */ \"./node_modules/p-finally/index.js\");\n\nclass TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\nconst pTimeout = (promise, milliseconds, fallback) => new Promise((resolve, reject) => {\n\tif (typeof milliseconds !== 'number' || milliseconds < 0) {\n\t\tthrow new TypeError('Expected `milliseconds` to be a positive number');\n\t}\n\n\tif (milliseconds === Infinity) {\n\t\tresolve(promise);\n\t\treturn;\n\t}\n\n\tconst timer = setTimeout(() => {\n\t\tif (typeof fallback === 'function') {\n\t\t\ttry {\n\t\t\t\tresolve(fallback());\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\n\t\t\treturn;\n\t\t}\n\n\t\tconst message = typeof fallback === 'string' ? fallback : `Promise timed out after ${milliseconds} milliseconds`;\n\t\tconst timeoutError = fallback instanceof Error ? fallback : new TimeoutError(message);\n\n\t\tif (typeof promise.cancel === 'function') {\n\t\t\tpromise.cancel();\n\t\t}\n\n\t\treject(timeoutError);\n\t}, milliseconds);\n\n\t// TODO: Use native `finally` keyword when targeting Node.js 10\n\tpFinally(\n\t\t// eslint-disable-next-line promise/prefer-await-to-then\n\t\tpromise.then(resolve, reject),\n\t\t() => {\n\t\t\tclearTimeout(timer);\n\t\t}\n\t);\n});\n\nmodule.exports = pTimeout;\n// TODO: Remove this for the next major release\nmodule.exports[\"default\"] = pTimeout;\n\nmodule.exports.TimeoutError = TimeoutError;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/p-queue/node_modules/p-timeout/index.js?\n}")},"./node_modules/pump/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{eval("{var once = __webpack_require__(/*! once */ \"./node_modules/once/once.js\")\nvar eos = __webpack_require__(/*! end-of-stream */ \"./node_modules/end-of-stream/index.js\")\nvar fs\n\ntry {\n  fs = __webpack_require__(/*! fs */ \"fs\") // we only need fs to get the ReadStream and WriteStream prototypes\n} catch (e) {}\n\nvar noop = function () {}\nvar ancient = typeof process === 'undefined' ? false : /^v?\\.0/.test(process.version)\n\nvar isFn = function (fn) {\n  return typeof fn === 'function'\n}\n\nvar isFS = function (stream) {\n  if (!ancient) return false // newer node version do not need to care about fs is a special way\n  if (!fs) return false // browser\n  return (stream instanceof (fs.ReadStream || noop) || stream instanceof (fs.WriteStream || noop)) && isFn(stream.close)\n}\n\nvar isRequest = function (stream) {\n  return stream.setHeader && isFn(stream.abort)\n}\n\nvar destroyer = function (stream, reading, writing, callback) {\n  callback = once(callback)\n\n  var closed = false\n  stream.on('close', function () {\n    closed = true\n  })\n\n  eos(stream, {readable: reading, writable: writing}, function (err) {\n    if (err) return callback(err)\n    closed = true\n    callback()\n  })\n\n  var destroyed = false\n  return function (err) {\n    if (closed) return\n    if (destroyed) return\n    destroyed = true\n\n    if (isFS(stream)) return stream.close(noop) // use close for fs streams to avoid fd leaks\n    if (isRequest(stream)) return stream.abort() // request.destroy just do .end - .abort is what we want\n\n    if (isFn(stream.destroy)) return stream.destroy()\n\n    callback(err || new Error('stream was destroyed'))\n  }\n}\n\nvar call = function (fn) {\n  fn()\n}\n\nvar pipe = function (from, to) {\n  return from.pipe(to)\n}\n\nvar pump = function () {\n  var streams = Array.prototype.slice.call(arguments)\n  var callback = isFn(streams[streams.length - 1] || noop) && streams.pop() || noop\n\n  if (Array.isArray(streams[0])) streams = streams[0]\n  if (streams.length < 2) throw new Error('pump requires two streams per minimum')\n\n  var error\n  var destroys = streams.map(function (stream, i) {\n    var reading = i < streams.length - 1\n    var writing = i > 0\n    return destroyer(stream, reading, writing, function (err) {\n      if (!error) error = err\n      if (err) destroys.forEach(call)\n      if (reading) return\n      destroys.forEach(call)\n      callback(error)\n    })\n  })\n\n  return streams.reduce(pipe)\n}\n\nmodule.exports = pump\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/pump/index.js?\n}")},"./node_modules/quick-lru/index.js":module=>{"use strict";eval("{\n\nclass QuickLRU {\n\tconstructor(options = {}) {\n\t\tif (!(options.maxSize && options.maxSize > 0)) {\n\t\t\tthrow new TypeError('`maxSize` must be a number greater than 0');\n\t\t}\n\n\t\tthis.maxSize = options.maxSize;\n\t\tthis.onEviction = options.onEviction;\n\t\tthis.cache = new Map();\n\t\tthis.oldCache = new Map();\n\t\tthis._size = 0;\n\t}\n\n\t_set(key, value) {\n\t\tthis.cache.set(key, value);\n\t\tthis._size++;\n\n\t\tif (this._size >= this.maxSize) {\n\t\t\tthis._size = 0;\n\n\t\t\tif (typeof this.onEviction === 'function') {\n\t\t\t\tfor (const [key, value] of this.oldCache.entries()) {\n\t\t\t\t\tthis.onEviction(key, value);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tthis.oldCache = this.cache;\n\t\t\tthis.cache = new Map();\n\t\t}\n\t}\n\n\tget(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this.cache.get(key);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\tconst value = this.oldCache.get(key);\n\t\t\tthis.oldCache.delete(key);\n\t\t\tthis._set(key, value);\n\t\t\treturn value;\n\t\t}\n\t}\n\n\tset(key, value) {\n\t\tif (this.cache.has(key)) {\n\t\t\tthis.cache.set(key, value);\n\t\t} else {\n\t\t\tthis._set(key, value);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\thas(key) {\n\t\treturn this.cache.has(key) || this.oldCache.has(key);\n\t}\n\n\tpeek(key) {\n\t\tif (this.cache.has(key)) {\n\t\t\treturn this.cache.get(key);\n\t\t}\n\n\t\tif (this.oldCache.has(key)) {\n\t\t\treturn this.oldCache.get(key);\n\t\t}\n\t}\n\n\tdelete(key) {\n\t\tconst deleted = this.cache.delete(key);\n\t\tif (deleted) {\n\t\t\tthis._size--;\n\t\t}\n\n\t\treturn this.oldCache.delete(key) || deleted;\n\t}\n\n\tclear() {\n\t\tthis.cache.clear();\n\t\tthis.oldCache.clear();\n\t\tthis._size = 0;\n\t}\n\n\t* keys() {\n\t\tfor (const [key] of this) {\n\t\t\tyield key;\n\t\t}\n\t}\n\n\t* values() {\n\t\tfor (const [, value] of this) {\n\t\t\tyield value;\n\t\t}\n\t}\n\n\t* [Symbol.iterator]() {\n\t\tfor (const item of this.cache) {\n\t\t\tyield item;\n\t\t}\n\n\t\tfor (const item of this.oldCache) {\n\t\t\tconst [key] = item;\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\tyield item;\n\t\t\t}\n\t\t}\n\t}\n\n\tget size() {\n\t\tlet oldCacheSize = 0;\n\t\tfor (const key of this.oldCache.keys()) {\n\t\t\tif (!this.cache.has(key)) {\n\t\t\t\toldCacheSize++;\n\t\t\t}\n\t\t}\n\n\t\treturn Math.min(this._size + oldCacheSize, this.maxSize);\n\t}\n}\n\nmodule.exports = QuickLRU;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/quick-lru/index.js?\n}")},"./node_modules/resolve-alpn/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{\nconst tls = __webpack_require__(/*! tls */ \"tls\");\n\nmodule.exports = (options = {}, connect = tls.connect) => new Promise((resolve, reject) => {\n\tlet timeout = false;\n\n\tlet socket;\n\n\tconst callback = async () => {\n\t\tawait socketPromise;\n\n\t\tsocket.off('timeout', onTimeout);\n\t\tsocket.off('error', reject);\n\n\t\tif (options.resolveSocket) {\n\t\t\tresolve({alpnProtocol: socket.alpnProtocol, socket, timeout});\n\n\t\t\tif (timeout) {\n\t\t\t\tawait Promise.resolve();\n\t\t\t\tsocket.emit('timeout');\n\t\t\t}\n\t\t} else {\n\t\t\tsocket.destroy();\n\t\t\tresolve({alpnProtocol: socket.alpnProtocol, timeout});\n\t\t}\n\t};\n\n\tconst onTimeout = async () => {\n\t\ttimeout = true;\n\t\tcallback();\n\t};\n\n\tconst socketPromise = (async () => {\n\t\ttry {\n\t\t\tsocket = await connect(options, callback);\n\n\t\t\tsocket.on('error', reject);\n\t\t\tsocket.once('timeout', onTimeout);\n\t\t} catch (error) {\n\t\t\treject(error);\n\t\t}\n\t})();\n});\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/resolve-alpn/index.js?\n}")},"./node_modules/responselike/src/index.js":(module,__unused_webpack_exports,__webpack_require__)=>{"use strict";eval("{\n\nconst Readable = (__webpack_require__(/*! stream */ \"stream\").Readable);\nconst lowercaseKeys = __webpack_require__(/*! lowercase-keys */ \"./node_modules/lowercase-keys/index.js\");\n\nclass Response extends Readable {\n\tconstructor(statusCode, headers, body, url) {\n\t\tif (typeof statusCode !== 'number') {\n\t\t\tthrow new TypeError('Argument `statusCode` should be a number');\n\t\t}\n\t\tif (typeof headers !== 'object') {\n\t\t\tthrow new TypeError('Argument `headers` should be an object');\n\t\t}\n\t\tif (!(body instanceof Buffer)) {\n\t\t\tthrow new TypeError('Argument `body` should be a buffer');\n\t\t}\n\t\tif (typeof url !== 'string') {\n\t\t\tthrow new TypeError('Argument `url` should be a string');\n\t\t}\n\n\t\tsuper();\n\t\tthis.statusCode = statusCode;\n\t\tthis.headers = lowercaseKeys(headers);\n\t\tthis.body = body;\n\t\tthis.url = url;\n\t}\n\n\t_read() {\n\t\tthis.push(this.body);\n\t\tthis.push(null);\n\t}\n}\n\nmodule.exports = Response;\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/responselike/src/index.js?\n}")},"./node_modules/tslib/tslib.es6.mjs":(__unused_webpack___webpack_module__,__webpack_exports__,__webpack_require__)=>{"use strict";eval('{__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   __addDisposableResource: () => (/* binding */ __addDisposableResource),\n/* harmony export */   __assign: () => (/* binding */ __assign),\n/* harmony export */   __asyncDelegator: () => (/* binding */ __asyncDelegator),\n/* harmony export */   __asyncGenerator: () => (/* binding */ __asyncGenerator),\n/* harmony export */   __asyncValues: () => (/* binding */ __asyncValues),\n/* harmony export */   __await: () => (/* binding */ __await),\n/* harmony export */   __awaiter: () => (/* binding */ __awaiter),\n/* harmony export */   __classPrivateFieldGet: () => (/* binding */ __classPrivateFieldGet),\n/* harmony export */   __classPrivateFieldIn: () => (/* binding */ __classPrivateFieldIn),\n/* harmony export */   __classPrivateFieldSet: () => (/* binding */ __classPrivateFieldSet),\n/* harmony export */   __createBinding: () => (/* binding */ __createBinding),\n/* harmony export */   __decorate: () => (/* binding */ __decorate),\n/* harmony export */   __disposeResources: () => (/* binding */ __disposeResources),\n/* harmony export */   __esDecorate: () => (/* binding */ __esDecorate),\n/* harmony export */   __exportStar: () => (/* binding */ __exportStar),\n/* harmony export */   __extends: () => (/* binding */ __extends),\n/* harmony export */   __generator: () => (/* binding */ __generator),\n/* harmony export */   __importDefault: () => (/* binding */ __importDefault),\n/* harmony export */   __importStar: () => (/* binding */ __importStar),\n/* harmony export */   __makeTemplateObject: () => (/* binding */ __makeTemplateObject),\n/* harmony export */   __metadata: () => (/* binding */ __metadata),\n/* harmony export */   __param: () => (/* binding */ __param),\n/* harmony export */   __propKey: () => (/* binding */ __propKey),\n/* harmony export */   __read: () => (/* binding */ __read),\n/* harmony export */   __rest: () => (/* binding */ __rest),\n/* harmony export */   __rewriteRelativeImportExtension: () => (/* binding */ __rewriteRelativeImportExtension),\n/* harmony export */   __runInitializers: () => (/* binding */ __runInitializers),\n/* harmony export */   __setFunctionName: () => (/* binding */ __setFunctionName),\n/* harmony export */   __spread: () => (/* binding */ __spread),\n/* harmony export */   __spreadArray: () => (/* binding */ __spreadArray),\n/* harmony export */   __spreadArrays: () => (/* binding */ __spreadArrays),\n/* harmony export */   __values: () => (/* binding */ __values),\n/* harmony export */   "default": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/******************************************************************************\nCopyright (c) Microsoft Corporation.\n\nPermission to use, copy, modify, and/or distribute this software for any\npurpose with or without fee is hereby granted.\n\nTHE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\nPERFORMANCE OF THIS SOFTWARE.\n***************************************************************************** */\n/* global Reflect, Promise, SuppressedError, Symbol, Iterator */\n\nvar extendStatics = function(d, b) {\n  extendStatics = Object.setPrototypeOf ||\n      ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\n      function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\n  return extendStatics(d, b);\n};\n\nfunction __extends(d, b) {\n  if (typeof b !== "function" && b !== null)\n      throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");\n  extendStatics(d, b);\n  function __() { this.constructor = d; }\n  d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n}\n\nvar __assign = function() {\n  __assign = Object.assign || function __assign(t) {\n      for (var s, i = 1, n = arguments.length; i < n; i++) {\n          s = arguments[i];\n          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n      }\n      return t;\n  }\n  return __assign.apply(this, arguments);\n}\n\nfunction __rest(s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n      t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === "function")\n      for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n          if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n              t[p[i]] = s[p[i]];\n      }\n  return t;\n}\n\nfunction __decorate(decorators, target, key, desc) {\n  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n  if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);\n  else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n}\n\nfunction __param(paramIndex, decorator) {\n  return function (target, key) { decorator(target, key, paramIndex); }\n}\n\nfunction __esDecorate(ctor, descriptorIn, decorators, contextIn, initializers, extraInitializers) {\n  function accept(f) { if (f !== void 0 && typeof f !== "function") throw new TypeError("Function expected"); return f; }\n  var kind = contextIn.kind, key = kind === "getter" ? "get" : kind === "setter" ? "set" : "value";\n  var target = !descriptorIn && ctor ? contextIn["static"] ? ctor : ctor.prototype : null;\n  var descriptor = descriptorIn || (target ? Object.getOwnPropertyDescriptor(target, contextIn.name) : {});\n  var _, done = false;\n  for (var i = decorators.length - 1; i >= 0; i--) {\n      var context = {};\n      for (var p in contextIn) context[p] = p === "access" ? {} : contextIn[p];\n      for (var p in contextIn.access) context.access[p] = contextIn.access[p];\n      context.addInitializer = function (f) { if (done) throw new TypeError("Cannot add initializers after decoration has completed"); extraInitializers.push(accept(f || null)); };\n      var result = (0, decorators[i])(kind === "accessor" ? { get: descriptor.get, set: descriptor.set } : descriptor[key], context);\n      if (kind === "accessor") {\n          if (result === void 0) continue;\n          if (result === null || typeof result !== "object") throw new TypeError("Object expected");\n          if (_ = accept(result.get)) descriptor.get = _;\n          if (_ = accept(result.set)) descriptor.set = _;\n          if (_ = accept(result.init)) initializers.unshift(_);\n      }\n      else if (_ = accept(result)) {\n          if (kind === "field") initializers.unshift(_);\n          else descriptor[key] = _;\n      }\n  }\n  if (target) Object.defineProperty(target, contextIn.name, descriptor);\n  done = true;\n};\n\nfunction __runInitializers(thisArg, initializers, value) {\n  var useValue = arguments.length > 2;\n  for (var i = 0; i < initializers.length; i++) {\n      value = useValue ? initializers[i].call(thisArg, value) : initializers[i].call(thisArg);\n  }\n  return useValue ? value : void 0;\n};\n\nfunction __propKey(x) {\n  return typeof x === "symbol" ? x : "".concat(x);\n};\n\nfunction __setFunctionName(f, name, prefix) {\n  if (typeof name === "symbol") name = name.description ? "[".concat(name.description, "]") : "";\n  return Object.defineProperty(f, "name", { configurable: true, value: prefix ? "".concat(prefix, " ", name) : name });\n};\n\nfunction __metadata(metadataKey, metadataValue) {\n  if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);\n}\n\nfunction __awaiter(thisArg, _arguments, P, generator) {\n  function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n  return new (P || (P = Promise))(function (resolve, reject) {\n      function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n      function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }\n      function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n      step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n}\n\nfunction __generator(thisArg, body) {\n  var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g = Object.create((typeof Iterator === "function" ? Iterator : Object).prototype);\n  return g.next = verb(0), g["throw"] = verb(1), g["return"] = verb(2), typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;\n  function verb(n) { return function (v) { return step([n, v]); }; }\n  function step(op) {\n      if (f) throw new TypeError("Generator is already executing.");\n      while (g && (g = 0, op[0] && (_ = 0)), _) try {\n          if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\n          if (y = 0, t) op = [op[0] & 2, t.value];\n          switch (op[0]) {\n              case 0: case 1: t = op; break;\n              case 4: _.label++; return { value: op[1], done: false };\n              case 5: _.label++; y = op[1]; op = [0]; continue;\n              case 7: op = _.ops.pop(); _.trys.pop(); continue;\n              default:\n                  if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\n                  if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\n                  if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\n                  if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\n                  if (t[2]) _.ops.pop();\n                  _.trys.pop(); continue;\n          }\n          op = body.call(thisArg, _);\n      } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\n      if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\n  }\n}\n\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  var desc = Object.getOwnPropertyDescriptor(m, k);\n  if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {\n      desc = { enumerable: true, get: function() { return m[k]; } };\n  }\n  Object.defineProperty(o, k2, desc);\n}) : (function(o, m, k, k2) {\n  if (k2 === undefined) k2 = k;\n  o[k2] = m[k];\n});\n\nfunction __exportStar(m, o) {\n  for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\n}\n\nfunction __values(o) {\n  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;\n  if (m) return m.call(o);\n  if (o && typeof o.length === "number") return {\n      next: function () {\n          if (o && i >= o.length) o = void 0;\n          return { value: o && o[i++], done: !o };\n      }\n  };\n  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");\n}\n\nfunction __read(o, n) {\n  var m = typeof Symbol === "function" && o[Symbol.iterator];\n  if (!m) return o;\n  var i = m.call(o), r, ar = [], e;\n  try {\n      while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\n  }\n  catch (error) { e = { error: error }; }\n  finally {\n      try {\n          if (r && !r.done && (m = i["return"])) m.call(i);\n      }\n      finally { if (e) throw e.error; }\n  }\n  return ar;\n}\n\n/** @deprecated */\nfunction __spread() {\n  for (var ar = [], i = 0; i < arguments.length; i++)\n      ar = ar.concat(__read(arguments[i]));\n  return ar;\n}\n\n/** @deprecated */\nfunction __spreadArrays() {\n  for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\n  for (var r = Array(s), k = 0, i = 0; i < il; i++)\n      for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\n          r[k] = a[j];\n  return r;\n}\n\nfunction __spreadArray(to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n      if (ar || !(i in from)) {\n          if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n          ar[i] = from[i];\n      }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n}\n\nfunction __await(v) {\n  return this instanceof __await ? (this.v = v, this) : new __await(v);\n}\n\nfunction __asyncGenerator(thisArg, _arguments, generator) {\n  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\n  var g = generator.apply(thisArg, _arguments || []), i, q = [];\n  return i = Object.create((typeof AsyncIterator === "function" ? AsyncIterator : Object).prototype), verb("next"), verb("throw"), verb("return", awaitReturn), i[Symbol.asyncIterator] = function () { return this; }, i;\n  function awaitReturn(f) { return function (v) { return Promise.resolve(v).then(f, reject); }; }\n  function verb(n, f) { if (g[n]) { i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; if (f) i[n] = f(i[n]); } }\n  function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\n  function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\n  function fulfill(value) { resume("next", value); }\n  function reject(value) { resume("throw", value); }\n  function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\n}\n\nfunction __asyncDelegator(o) {\n  var i, p;\n  return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;\n  function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: false } : f ? f(v) : v; } : f; }\n}\n\nfunction __asyncValues(o) {\n  if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");\n  var m = o[Symbol.asyncIterator], i;\n  return m ? m.call(o) : (o = typeof __values === "function" ? __values(o) : o[Symbol.iterator](), i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i);\n  function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\n  function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\n}\n\nfunction __makeTemplateObject(cooked, raw) {\n  if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }\n  return cooked;\n};\n\nvar __setModuleDefault = Object.create ? (function(o, v) {\n  Object.defineProperty(o, "default", { enumerable: true, value: v });\n}) : function(o, v) {\n  o["default"] = v;\n};\n\nvar ownKeys = function(o) {\n  ownKeys = Object.getOwnPropertyNames || function (o) {\n    var ar = [];\n    for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;\n    return ar;\n  };\n  return ownKeys(o);\n};\n\nfunction __importStar(mod) {\n  if (mod && mod.__esModule) return mod;\n  var result = {};\n  if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);\n  __setModuleDefault(result, mod);\n  return result;\n}\n\nfunction __importDefault(mod) {\n  return (mod && mod.__esModule) ? mod : { default: mod };\n}\n\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\n  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");\n  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");\n  return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);\n}\n\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\n  if (kind === "m") throw new TypeError("Private method is not writable");\n  if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");\n  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");\n  return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\n}\n\nfunction __classPrivateFieldIn(state, receiver) {\n  if (receiver === null || (typeof receiver !== "object" && typeof receiver !== "function")) throw new TypeError("Cannot use \'in\' operator on non-object");\n  return typeof state === "function" ? receiver === state : state.has(receiver);\n}\n\nfunction __addDisposableResource(env, value, async) {\n  if (value !== null && value !== void 0) {\n    if (typeof value !== "object" && typeof value !== "function") throw new TypeError("Object expected.");\n    var dispose, inner;\n    if (async) {\n      if (!Symbol.asyncDispose) throw new TypeError("Symbol.asyncDispose is not defined.");\n      dispose = value[Symbol.asyncDispose];\n    }\n    if (dispose === void 0) {\n      if (!Symbol.dispose) throw new TypeError("Symbol.dispose is not defined.");\n      dispose = value[Symbol.dispose];\n      if (async) inner = dispose;\n    }\n    if (typeof dispose !== "function") throw new TypeError("Object not disposable.");\n    if (inner) dispose = function() { try { inner.call(this); } catch (e) { return Promise.reject(e); } };\n    env.stack.push({ value: value, dispose: dispose, async: async });\n  }\n  else if (async) {\n    env.stack.push({ async: true });\n  }\n  return value;\n}\n\nvar _SuppressedError = typeof SuppressedError === "function" ? SuppressedError : function (error, suppressed, message) {\n  var e = new Error(message);\n  return e.name = "SuppressedError", e.error = error, e.suppressed = suppressed, e;\n};\n\nfunction __disposeResources(env) {\n  function fail(e) {\n    env.error = env.hasError ? new _SuppressedError(e, env.error, "An error was suppressed during disposal.") : e;\n    env.hasError = true;\n  }\n  var r, s = 0;\n  function next() {\n    while (r = env.stack.pop()) {\n      try {\n        if (!r.async && s === 1) return s = 0, env.stack.push(r), Promise.resolve().then(next);\n        if (r.dispose) {\n          var result = r.dispose.call(r.value);\n          if (r.async) return s |= 2, Promise.resolve(result).then(next, function(e) { fail(e); return next(); });\n        }\n        else s |= 1;\n      }\n      catch (e) {\n        fail(e);\n      }\n    }\n    if (s === 1) return env.hasError ? Promise.reject(env.error) : Promise.resolve();\n    if (env.hasError) throw env.error;\n  }\n  return next();\n}\n\nfunction __rewriteRelativeImportExtension(path, preserveJsx) {\n  if (typeof path === "string" && /^\\.\\.?\\//.test(path)) {\n      return path.replace(/\\.(tsx)$|((?:\\.d)?)((?:\\.[^./]+?)?)\\.([cm]?)ts$/i, function (m, tsx, d, ext, cm) {\n          return tsx ? preserveJsx ? ".jsx" : ".js" : d && (!ext || !cm) ? m : (d + ext + "." + cm.toLowerCase() + "js");\n      });\n  }\n  return path;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ({\n  __extends,\n  __assign,\n  __rest,\n  __decorate,\n  __param,\n  __esDecorate,\n  __runInitializers,\n  __propKey,\n  __setFunctionName,\n  __metadata,\n  __awaiter,\n  __generator,\n  __createBinding,\n  __exportStar,\n  __values,\n  __read,\n  __spread,\n  __spreadArrays,\n  __spreadArray,\n  __await,\n  __asyncGenerator,\n  __asyncDelegator,\n  __asyncValues,\n  __makeTemplateObject,\n  __importStar,\n  __importDefault,\n  __classPrivateFieldGet,\n  __classPrivateFieldSet,\n  __classPrivateFieldIn,\n  __addDisposableResource,\n  __disposeResources,\n  __rewriteRelativeImportExtension,\n});\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/tslib/tslib.es6.mjs?\n}')},"./node_modules/wrappy/wrappy.js":module=>{eval("{// Returns a wrapper function that returns a wrapped callback\n// The wrapper function should do some stuff, and return a\n// presumably different callback function.\n// This makes sure that own properties are retained, so that\n// decorations and such are not lost along the way.\nmodule.exports = wrappy\nfunction wrappy (fn, cb) {\n  if (fn && cb) return wrappy(fn)(cb)\n\n  if (typeof fn !== 'function')\n    throw new TypeError('need wrapper function')\n\n  Object.keys(fn).forEach(function (k) {\n    wrapper[k] = fn[k]\n  })\n\n  return wrapper\n\n  function wrapper() {\n    var args = new Array(arguments.length)\n    for (var i = 0; i < args.length; i++) {\n      args[i] = arguments[i]\n    }\n    var ret = fn.apply(this, args)\n    var cb = args[args.length-1]\n    if (typeof ret === 'function' && ret !== cb) {\n      Object.keys(cb).forEach(function (k) {\n        ret[k] = cb[k]\n      })\n    }\n    return ret\n  }\n}\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./node_modules/wrappy/wrappy.js?\n}")},"./variables.js":module=>{eval("{module.exports = function (self) {\n\treturn [\n\t\t{\n\t\t\tname: 'Status',\n\t\t\tvariableId: 'status',\n\t\t\tdescription: 'Current status of the restream preparation (idle, in_progress, ok, fail)',\n\t\t},\n\t\t{\n\t\t\tname: 'Last Error',\n\t\t\tvariableId: 'last_error',\n\t\t\tdescription: 'Error message from the last failed operation (empty if no error)',\n\t\t},\n\t\t{\n\t\t\tname: 'Facebook Video ID',\n\t\t\tvariableId: 'facebook_video_id',\n\t\t\tdescription: 'ID of the last created Facebook Live Video',\n\t\t},\n\t\t{\n\t\t\tname: 'Selected Live Stream',\n\t\t\tvariableId: 'selected_livestream',\n\t\t\tdescription: 'Name of the currently selected api.video live stream',\n\t\t},\n\t\t{\n\t\t\tname: 'Live Streams Count',\n\t\t\tvariableId: 'livestreams_count',\n\t\t\tdescription: 'Number of available api.video live streams',\n\t\t},\n\t\t{\n\t\t\tname: 'Module Ready',\n\t\t\tvariableId: 'module_ready',\n\t\t\tdescription: 'Whether the module is properly configured and ready (true/false)',\n\t\t},\n\t]\n}\n\n\n//# sourceURL=webpack://companion-module-facebook-apivideo/./variables.js?\n}")},buffer:e=>{"use strict";e.exports=require("buffer")},dgram:e=>{"use strict";e.exports=require("dgram")},dns:e=>{"use strict";e.exports=require("dns")},events:e=>{"use strict";e.exports=require("events")},fs:e=>{"use strict";e.exports=require("fs")},"fs/promises":e=>{"use strict";e.exports=require("fs/promises")},http:e=>{"use strict";e.exports=require("http")},http2:e=>{"use strict";e.exports=require("http2")},https:e=>{"use strict";e.exports=require("https")},net:e=>{"use strict";e.exports=require("net")},os:e=>{"use strict";e.exports=require("os")},path:e=>{"use strict";e.exports=require("path")},stream:e=>{"use strict";e.exports=require("stream")},tls:e=>{"use strict";e.exports=require("tls")},url:e=>{"use strict";e.exports=require("url")},util:e=>{"use strict";e.exports=require("util")},zlib:e=>{"use strict";e.exports=require("zlib")}},__webpack_module_cache__={};function __webpack_require__(e){var t=__webpack_module_cache__[e];if(void 0!==t)return t.exports;var n=__webpack_module_cache__[e]={exports:{}};return __webpack_modules__[e].call(n.exports,n,n.exports,__webpack_require__),n.exports}__webpack_require__.d=(e,t)=>{for(var n in t)__webpack_require__.o(t,n)&&!__webpack_require__.o(e,n)&&Object.defineProperty(e,n,{enumerable:!0,get:t[n]})},__webpack_require__.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),__webpack_require__.r=e=>{"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})};var __webpack_exports__=__webpack_require__("./main.js")})();